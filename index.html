<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM STRIKE | بازی اکشن سه‌بعدی</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body { 
            overflow: hidden; 
            font-family: 'Tahoma', 'Arial', sans-serif;
            background: #000000;
            color: #ffffff;
            width: 100vw;
            height: 100vh;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
        }
        
        /* UI Styles */
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .hud-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 40, 80, 0.9), rgba(0, 20, 40, 0.9));
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 15px 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        #healthPanel {
            top: 20px;
            left: 20px;
            min-width: 250px;
        }
        
        #healthBar {
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 8px;
            border: 1px solid #ff4444;
        }
        
        #healthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            transition: width 0.3s ease;
            border-radius: 8px;
        }
        
        #scorePanel {
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(100, 0, 200, 0.9), rgba(50, 0, 100, 0.9));
            border-color: #aa00ff;
        }
        
        #ammoPanel {
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(200, 100, 0, 0.9), rgba(100, 50, 0, 0.9));
            border-color: #ffaa00;
        }
        
        #wavePanel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(100, 0, 100, 0.9), rgba(50, 0, 50, 0.9));
            border-color: #ff00ff;
        }
        
        .hud-text {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            margin-bottom: 5px;
        }
        
        .hud-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.7);
        }
        
        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 80, 0.95));
            padding: 50px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            text-align: center;
            pointer-events: all;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
            min-width: 400px;
        }
        
        .menu-title {
            font-size: 42px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            margin-bottom: 40px;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu-button {
            background: linear-gradient(45deg, #00ff88, #0088ff);
            border: none;
            padding: 18px 35px;
            margin: 12px;
            border-radius: 30px;
            color: #002244;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 250px;
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        
        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.5);
            background: linear-gradient(45deg, #00ffaa, #00aaff);
        }
        
        .menu-button:active {
            transform: translateY(1px);
            box-shadow: 0 3px 10px rgba(0, 255, 136, 0.3);
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loading-title {
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 40px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }
        
        .loading-bar-container {
            width: 400px;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin: 20px;
            overflow: hidden;
            border: 2px solid #00ff88;
        }
        
        .loading-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0088ff);
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        
        .loading-text {
            font-size: 18px;
            color: #00ff88;
            margin-top: 20px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 150;
        }
        
        .crosshair-dot {
            width: 4px;
            height: 4px;
            background: #00ff88;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }
        
        .crosshair-line {
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
        }
        
        .crosshair-horizontal {
            width: 15px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-vertical {
            width: 2px;
            height: 15px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #debugInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ff88;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
        }
        
        .notification {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 40, 80, 0.9);
            color: #00ff88;
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas" tabindex="0"></canvas>
        
        <div id="uiContainer">
            <!-- HUD Elements -->
            <div class="hud-panel" id="healthPanel">
                <div class="hud-text">سلامت</div>
                <div id="healthBar">
                    <div id="healthFill"></div>
                </div>
                <div class="hud-value" id="healthValue">100%</div>
            </div>
            
            <div class="hud-panel" id="scorePanel">
                <div class="hud-text">امتیاز</div>
                <div class="hud-value" id="scoreValue">0</div>
            </div>
            
            <div class="hud-panel" id="ammoPanel">
                <div class="hud-text">خشاب</div>
                <div class="hud-value" id="ammoValue">30/150</div>
            </div>
            
            <div class="hud-panel" id="wavePanel">
                <div class="hud-text">موج</div>
                <div class="hud-value" id="waveValue">1</div>
                <div class="hud-text" id="enemiesValue">دشمنان: 10</div>
            </div>
            
            <!-- Crosshair -->
            <div id="crosshair">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line crosshair-horizontal"></div>
                <div class="crosshair-line crosshair-vertical"></div>
            </div>
            
            <!-- Game Menu -->
            <div id="gameMenu">
                <div class="menu-title">QUANTUM STRIKE</div>
                <button class="menu-button" onclick="game.startNewGame()">شروع بازی جدید</button>
                <button class="menu-button" onclick="game.showInstructions()">راهنمای بازی</button>
                <button class="menu-button" onclick="game.showSettings()">تنظیمات</button>
                <div style="margin-top: 30px; color: #00ff88; font-size: 14px;">
                    ساخته شده با Babylon.js
                </div>
            </div>
            
            <!-- Loading Screen -->
            <div id="loadingScreen">
                <div class="loading-title">QUANTUM STRIKE</div>
                <div class="loading-bar-container">
                    <div class="loading-bar-fill" id="loadingBar"></div>
                </div>
                <div class="loading-text" id="loadingText">در حال راه‌اندازی موتور بازی...</div>
            </div>
            
            <!-- Notifications -->
            <div class="notification" id="waveNotification"></div>
            <div class="notification" id="powerupNotification"></div>
            
            <!-- Debug Info -->
            <div id="debugInfo"></div>
        </div>
    </div>

    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materials/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

    <script>
        // =====================================================
        // QUANTUM STRIKE - بازی اکشن سه‌بعدی کامل
        // نسخه پایدار و قابل اجرا
        // =====================================================

        class QuantumStrikeGame {
            constructor() {
                this.engine = null;
                this.scene = null;
                this.player = null;
                this.currentWave = 1;
                this.score = 0;
                this.isGameRunning = false;
                this.isPaused = false;
                this.gameTime = 0;
                
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerUps = [];
                
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                
                this.init();
            }

            async init() {
                try {
                    this.updateLoading(10, "در حال راه‌اندازی موتور بازی...");
                    
                    // Create engine
                    const canvas = document.getElementById("renderCanvas");
                    this.engine = new BABYLON.Engine(canvas, true, {
                        preserveDrawingBuffer: true,
                        stencil: true
                    });

                    this.updateLoading(30, "در حال ایجاد صحنه اصلی...");
                    await this.createScene();

                    this.updateLoading(50, "در حال ساخت محیط بازی...");
                    await this.createEnvironment();

                    this.updateLoading(70, "در حال ایجاد بازیکن...");
                    await this.createPlayer();

                    this.updateLoading(85, "در حال راه‌اندازی سیستم دشمنان...");
                    await this.createEnemies();

                    this.updateLoading(95, "در حال راه‌اندازی صداها...");
                    await this.setupAudio();

                    this.updateLoading(100, "آماده!");
                    
                    setTimeout(() => {
                        this.hideLoadingScreen();
                        this.showMainMenu();
                        this.startGameLoop();
                    }, 1000);

                } catch (error) {
                    console.error("خطا در راه‌اندازی بازی:", error);
                    this.showError("خطا در بارگذاری بازی: " + error.message);
                }
            }

            updateLoading(percent, text) {
                document.getElementById('loadingBar').style.width = percent + '%';
                document.getElementById('loadingText').textContent = text;
                console.log(`Loading: ${percent}% - ${text}`);
            }

            hideLoadingScreen() {
                document.getElementById('loadingScreen').style.display = 'none';
            }

            showMainMenu() {
                document.getElementById('gameMenu').style.display = 'block';
            }

            hideMainMenu() {
                document.getElementById('gameMenu').style.display = 'none';
            }

            showError(message) {
                alert("خطا: " + message);
            }

            async createScene() {
                // Create basic scene
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1.0);
                
                // Create simple lighting
                this.createBasicLighting();
                
                // Create camera
                this.createCamera();
                
                // Setup input
                this.setupInput();
                
                console.log("صحنه ایجاد شد");
            }

            createBasicLighting() {
                // Directional light (sun)
                const light = new BABYLON.DirectionalLight("dirLight", 
                    new BABYLON.Vector3(-1, -2, -1), this.scene);
                light.intensity = 1.0;
                
                // Ambient light
                const ambient = new BABYLON.HemisphericLight("ambient", 
                    new BABYLON.Vector3(0, 1, 0), this.scene);
                ambient.intensity = 0.4;
                
                console.log("نورپردازی ایجاد شد");
            }

            createCamera() {
                // Universal camera for first-person view
                this.camera = new BABYLON.UniversalCamera("camera", 
                    new BABYLON.Vector3(0, 2, -10), this.scene);
                this.camera.setTarget(BABYLON.Vector3.Zero());
                this.camera.speed = 0.5;
                this.camera.angularSensibility = 2000;
                this.camera.inertia = 0.8;
                this.camera.attachControl(this.engine.getRenderingCanvas(), true);
                
                this.scene.activeCamera = this.camera;
                console.log("دوربین ایجاد شد");
            }

            setupInput() {
                const canvas = this.engine.getRenderingCanvas();
                
                // Keyboard events
                this.scene.onKeyboardObservable.add((kbInfo) => {
                    const key = kbInfo.event.key.toLowerCase();
                    if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
                        this.keys[key] = true;
                    } else if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYUP) {
                        this.keys[key] = false;
                    }
                });

                // Mouse events
                canvas.addEventListener("mousedown", (e) => {
                    this.mouse.down = true;
                    if (this.isGameRunning && !this.isPaused) {
                        this.playerShoot();
                    }
                });

                canvas.addEventListener("mouseup", (e) => {
                    this.mouse.down = false;
                });

                canvas.addEventListener("mousemove", (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                // Prevent context menu
                canvas.addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                });

                console.log("کنترل‌ها راه‌اندازی شد");
            }

            async createEnvironment() {
                // Create ground
                this.createGround();
                
                // Create walls
                this.createWalls();
                
                // Create some obstacles
                this.createObstacles();
                
                // Create skybox
                this.createSkybox();
                
                console.log("محیط بازی ایجاد شد");
            }

            createGround() {
                const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                    width: 100,
                    height: 100
                }, this.scene);
                
                const material = new BABYLON.StandardMaterial("groundMat", this.scene);
                material.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
                material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                ground.material = material;
                
                // Enable collisions
                ground.checkCollisions = true;
            }

            createWalls() {
                const wallMaterial = new BABYLON.StandardMaterial("wallMat", this.scene);
                wallMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.6);
                
                // Create 4 walls around the arena
                const walls = [
                    { position: [0, 5, -50], size: [100, 10, 2] },  // North
                    { position: [0, 5, 50], size: [100, 10, 2] },   // South
                    { position: [-50, 5, 0], size: [2, 10, 100] },  // West
                    { position: [50, 5, 0], size: [2, 10, 100] }    // East
                ];
                
                walls.forEach((wall, i) => {
                    const wallMesh = BABYLON.MeshBuilder.CreateBox(`wall${i}`, {
                        width: wall.size[0],
                        height: wall.size[1],
                        depth: wall.size[2]
                    }, this.scene);
                    
                    wallMesh.position = new BABYLON.Vector3(...wall.position);
                    wallMesh.material = wallMaterial;
                    wallMesh.checkCollisions = true;
                });
            }

            createObstacles() {
                const obstacleMaterial = new BABYLON.StandardMaterial("obstacleMat", this.scene);
                obstacleMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                
                // Create some random obstacles
                for (let i = 0; i < 8; i++) {
                    const size = 2 + Math.random() * 3;
                    const obstacle = BABYLON.MeshBuilder.CreateBox(`obstacle${i}`, {
                        width: size,
                        height: size,
                        depth: size
                    }, this.scene);
                    
                    obstacle.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 80,
                        size / 2,
                        (Math.random() - 0.5) * 80
                    );
                    
                    obstacle.material = obstacleMaterial;
                    obstacle.checkCollisions = true;
                }
            }

            createSkybox() {
                const skybox = BABYLON.MeshBuilder.CreateBox("skybox", { size: 1000 }, this.scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyboxMat", this.scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skybox.material = skyboxMaterial;
            }

            async createPlayer() {
                this.player = {
                    mesh: null,
                    health: 100,
                    maxHealth: 100,
                    ammo: 30,
                    maxAmmo: 150,
                    position: new BABYLON.Vector3(0, 2, 0),
                    speed: 0.2,
                    isAlive: true
                };
                
                // Create player capsule
                this.player.mesh = BABYLON.MeshBuilder.CreateCapsule("player", {
                    height: 2,
                    radius: 0.4
                }, this.scene);
                
                this.player.mesh.position = this.player.position;
                
                const material = new BABYLON.StandardMaterial("playerMat", this.scene);
                material.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1.0);
                this.player.mesh.material = material;
                
                // Enable collisions
                this.player.mesh.checkCollisions = true;
                
                // Position camera at player position
                this.camera.position = new BABYLON.Vector3(0, 1.6, 0);
                this.player.mesh.addChild(this.camera);
                
                console.log("بازیکن ایجاد شد");
            }

            async createEnemies() {
                this.enemies = [];
                console.log("سیستم دشمنان راه‌اندازی شد");
            }

            async setupAudio() {
                // Audio system placeholder
                console.log("سیستم صدا راه‌اندازی شد");
            }

            startGameLoop() {
                this.engine.runRenderLoop(() => {
                    if (this.isGameRunning && !this.isPaused) {
                        const deltaTime = this.engine.getDeltaTime() / 1000;
                        this.update(deltaTime);
                    }
                    this.scene.render();
                });
                
                // Handle window resize
                window.addEventListener("resize", () => {
                    this.engine.resize();
                });
                
                console.log("حلقه بازی شروع شد");
            }

            update(deltaTime) {
                this.gameTime += deltaTime;
                
                // Update player
                this.updatePlayer(deltaTime);
                
                // Update enemies
                this.updateEnemies(deltaTime);
                
                // Update bullets
                this.updateBullets(deltaTime);
                
                // Update particles
                this.updateParticles(deltaTime);
                
                // Update power-ups
                this.updatePowerUps(deltaTime);
                
                // Update UI
                this.updateUI();
                
                // Check game state
                this.checkGameState();
            }

            updatePlayer(deltaTime) {
                if (!this.player.isAlive) return;
                
                const moveVector = new BABYLON.Vector3(0, 0, 0);
                
                // Keyboard movement
                if (this.keys['w'] || this.keys['arrowup']) {
                    moveVector.z = 1;
                }
                if (this.keys['s'] || this.keys['arrowdown']) {
                    moveVector.z = -1;
                }
                if (this.keys['a'] || this.keys['arrowleft']) {
                    moveVector.x = -1;
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    moveVector.x = 1;
                }
                
                // Normalize and apply movement
                if (moveVector.lengthSquared() > 0) {
                    moveVector.normalize();
                    moveVector.scaleInPlace(this.player.speed);
                    
                    // Move player mesh
                    this.player.mesh.moveWithCollisions(moveVector);
                }
                
                // Running
                if (this.keys['shift']) {
                    this.player.speed = 0.4;
                } else {
                    this.player.speed = 0.2;
                }
                
                // Jumping (simple implementation)
                if ((this.keys[' '] || this.keys['space']) && this.player.mesh.position.y <= 2.1) {
                    this.player.mesh.position.y += 0.5;
                }
            }

            playerShoot() {
                if (this.player.ammo > 0 && this.player.isAlive) {
                    this.player.ammo--;
                    this.createBullet();
                    this.createMuzzleFlash();
                } else if (this.player.ammo <= 0) {
                    this.showNotification("خشاب خالی است! کلید R برای reload");
                }
            }

            createBullet() {
                const bullet = {
                    mesh: BABYLON.MeshBuilder.CreateSphere("bullet", { diameter: 0.1 }, this.scene),
                    position: this.camera.position.clone(),
                    direction: this.camera.getForwardRay().direction,
                    speed: 2.0,
                    lifeTime: 3.0,
                    age: 0,
                    isActive: true
                };
                
                bullet.mesh.position = bullet.position;
                
                const material = new BABYLON.StandardMaterial("bulletMat", this.scene);
                material.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
                bullet.mesh.material = material;
                
                this.bullets.push(bullet);
            }

            createMuzzleFlash() {
                // Create simple muzzle flash effect
                const flash = BABYLON.MeshBuilder.CreateSphere("muzzleFlash", { diameter: 0.3 }, this.scene);
                flash.position = this.camera.position.add(this.camera.getForwardRay().direction.scale(1));
                
                const material = new BABYLON.StandardMaterial("flashMat", this.scene);
                material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                material.alpha = 0.8;
                flash.material = material;
                
                // Remove after short time
                setTimeout(() => {
                    flash.dispose();
                }, 50);
            }

            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.age += deltaTime;
                    
                    if (bullet.age >= bullet.lifeTime) {
                        bullet.mesh.dispose();
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Move bullet
                    bullet.position.addInPlace(bullet.direction.scale(bullet.speed));
                    bullet.mesh.position = bullet.position;
                    
                    // Simple collision detection with enemies
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        if (enemy.mesh && BABYLON.Vector3.Distance(bullet.position, enemy.mesh.position) < 2) {
                            // Hit enemy
                            this.enemyTakeDamage(enemy, 25);
                            bullet.mesh.dispose();
                            this.bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            updateEnemies(deltaTime) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    if (enemy.health <= 0) {
                        this.destroyEnemy(i);
                        continue;
                    }
                    
                    // Simple AI: move toward player
                    if (this.player.isAlive) {
                        const direction = this.player.mesh.position.subtract(enemy.mesh.position);
                        direction.normalize();
                        direction.scaleInPlace(enemy.speed * deltaTime);
                        
                        enemy.mesh.moveWithCollisions(direction);
                        
                        // Rotate to face player
                        const targetRotation = Math.atan2(direction.x, direction.z);
                        enemy.mesh.rotation.y = targetRotation;
                    }
                }
            }

            updateParticles(deltaTime) {
                // Simple particle system would go here
            }

            updatePowerUps(deltaTime) {
                // Power-up system would go here
            }

            updateUI() {
                // Update health
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                document.getElementById('healthValue').textContent = Math.round(healthPercent) + '%';
                
                // Update score
                document.getElementById('scoreValue').textContent = this.score;
                
                // Update ammo
                document.getElementById('ammoValue').textContent = 
                    `${this.player.ammo}/${this.player.maxAmmo}`;
                
                // Update wave info
                document.getElementById('waveValue').textContent = this.currentWave;
                document.getElementById('enemiesValue').textContent = 
                    `دشمنان: ${this.enemies.length}`;
                
                // Update debug info
                document.getElementById('debugInfo').textContent = 
                    `FPS: ${Math.round(this.engine.getFps())} | زمان: ${Math.round(this.gameTime)}s`;
            }

            checkGameState() {
                // Check player death
                if (this.player.health <= 0 && this.player.isAlive) {
                    this.playerDie();
                }
                
                // Check wave completion
                if (this.enemies.length === 0 && this.isGameRunning) {
                    this.nextWave();
                }
            }

            playerDie() {
                this.player.isAlive = false;
                this.showNotification("شما مردید! بازی از نو شروع می‌شود");
                
                setTimeout(() => {
                    this.restartGame();
                }, 3000);
            }

            enemyTakeDamage(enemy, damage) {
                enemy.health -= damage;
                this.score += 10;
                
                // Visual feedback
                const originalColor = enemy.mesh.material.diffuseColor.clone();
                enemy.mesh.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                
                setTimeout(() => {
                    if (enemy.mesh) {
                        enemy.mesh.material.diffuseColor = originalColor;
                    }
                }, 100);
            }

            destroyEnemy(index) {
                const enemy = this.enemies[index];
                
                // Create explosion effect
                this.createExplosion(enemy.mesh.position);
                
                // Add score
                this.score += 100;
                
                // Remove enemy
                enemy.mesh.dispose();
                this.enemies.splice(index, 1);
                
                // Chance to spawn power-up
                if (Math.random() < 0.3) {
                    this.spawnPowerUp(enemy.mesh.position);
                }
            }

            createExplosion(position) {
                // Create simple explosion effect
                for (let i = 0; i < 5; i++) {
                    const particle = BABYLON.MeshBuilder.CreateSphere("explosionParticle", 
                        { diameter: 0.5 }, this.scene);
                    particle.position = position.clone();
                    
                    const material = new BABYLON.StandardMaterial("explosionMat", this.scene);
                    material.emissiveColor = new BABYLON.Color3(1, 0.3, 0);
                    material.alpha = 0.8;
                    particle.material = material;
                    
                    // Random velocity
                    const velocity = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    
                    // Animate particle
                    let age = 0;
                    const maxAge = 1.0;
                    
                    const particleUpdate = () => {
                        age += 0.016; // ~60fps
                        
                        if (age >= maxAge) {
                            particle.dispose();
                            return;
                        }
                        
                        particle.position.addInPlace(velocity.scale(0.016));
                        particle.scaling.scaleInPlace(0.95);
                        particle.material.alpha = 0.8 * (1 - age / maxAge);
                        
                        requestAnimationFrame(particleUpdate);
                    };
                    
                    particleUpdate();
                }
            }

            spawnPowerUp(position) {
                const powerUpTypes = ['health', 'ammo', 'speed'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                const powerUp = {
                    mesh: BABYLON.MeshBuilder.CreateSphere("powerUp", { diameter: 1 }, this.scene),
                    position: position.clone(),
                    type: type,
                    isActive: true
                };
                
                powerUp.mesh.position = powerUp.position;
                
                const material = new BABYLON.StandardMaterial("powerUpMat", this.scene);
                switch (type) {
                    case 'health':
                        material.diffuseColor = new BABYLON.Color3(0, 1, 0);
                        break;
                    case 'ammo':
                        material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                        break;
                    case 'speed':
                        material.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
                        break;
                }
                material.emissiveColor = material.diffuseColor;
                powerUp.mesh.material = material;
                
                // Add floating animation
                this.animatePowerUp(powerUp);
                
                this.powerUps.push(powerUp);
            }

            animatePowerUp(powerUp) {
                let time = 0;
                const originalY = powerUp.position.y;
                
                const animate = () => {
                    if (!powerUp.isActive) return;
                    
                    time += 0.016;
                    powerUp.mesh.position.y = originalY + Math.sin(time * 2) * 0.5;
                    powerUp.mesh.rotation.y += 0.02;
                    
                    // Check collision with player
                    if (this.player.isAlive && 
                        BABYLON.Vector3.Distance(powerUp.mesh.position, this.player.mesh.position) < 2) {
                        this.collectPowerUp(powerUp);
                        return;
                    }
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            collectPowerUp(powerUp) {
                powerUp.isActive = false;
                
                switch (powerUp.type) {
                    case 'health':
                        this.player.health = Math.min(this.player.health + 25, this.player.maxHealth);
                        this.showNotification("+25 سلامت");
                        break;
                    case 'ammo':
                        this.player.ammo = Math.min(this.player.ammo + 30, 30);
                        this.player.maxAmmo += 30;
                        this.showNotification("+30 فشنگ");
                        break;
                    case 'speed':
                        this.player.speed += 0.1;
                        this.showNotification("+سرعت");
                        break;
                }
                
                powerUp.mesh.dispose();
                this.powerUps = this.powerUps.filter(p => p !== powerUp);
            }

            showNotification(message) {
                const notification = document.getElementById('powerupNotification');
                notification.textContent = message;
                notification.style.opacity = '1';
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                }, 2000);
            }

            spawnEnemyWave(waveNumber) {
                const enemyCount = 5 + waveNumber * 2;
                
                for (let i = 0; i < enemyCount; i++) {
                    this.spawnEnemy(waveNumber);
                }
                
                this.showNotification(`موج ${waveNumber} شروع شد!`);
            }

            spawnEnemy(waveNumber) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 10;
                const position = new BABYLON.Vector3(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );
                
                const enemy = {
                    mesh: BABYLON.MeshBuilder.CreateCapsule("enemy", {
                        height: 2,
                        radius: 0.4
                    }, this.scene),
                    position: position,
                    health: 50 + waveNumber * 10,
                    maxHealth: 50 + waveNumber * 10,
                    speed: 0.05,
                    isAlive: true
                };
                
                enemy.mesh.position = enemy.position;
                
                const material = new BABYLON.StandardMaterial("enemyMat", this.scene);
                material.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
                enemy.mesh.material = material;
                
                enemy.mesh.checkCollisions = true;
                
                this.enemies.push(enemy);
            }

            nextWave() {
                this.currentWave++;
                this.spawnEnemyWave(this.currentWave);
            }

            startNewGame() {
                this.hideMainMenu();
                this.isGameRunning = true;
                this.isPaused = false;
                this.currentWave = 1;
                this.score = 0;
                
                // Reset player
                this.resetPlayer();
                
                // Start first wave
                this.spawnEnemyWave(this.currentWave);
                
                // Focus canvas for input
                this.engine.getRenderingCanvas().focus();
                
                console.log("بازی جدید شروع شد");
            }

            resetPlayer() {
                this.player.health = this.player.maxHealth;
                this.player.ammo = 30;
                this.player.maxAmmo = 150;
                this.player.isAlive = true;
                this.player.mesh.position = new BABYLON.Vector3(0, 2, 0);
                
                // Clear all enemies
                this.enemies.forEach(enemy => enemy.mesh.dispose());
                this.enemies = [];
                
                // Clear bullets
                this.bullets.forEach(bullet => bullet.mesh.dispose());
                this.bullets = [];
                
                // Clear power-ups
                this.powerUps.forEach(powerUp => powerUp.mesh.dispose());
                this.powerUps = [];
            }

            restartGame() {
                this.startNewGame();
            }

            showInstructions() {
                const instructions = `
                    راهنمای بازی QUANTUM STRIKE:
                    
                    حرکت: کلیدهای W, A, S, D
                    نگاه کردن: ماوس
                    شلیک: کلیک چپ ماوس
                    دویدن: کلید Shift
                    پرش: Space
                    Reload: کلید R
                    
                    هدف: نابود کردن تمام ربات‌های دشمن در هر موج!
                    مواظب سلامت و خشاب خود باشید.
                    
                    قدرت‌افزاها به صورت تصادفی ظاهر می‌شوند.
                `;
                alert(instructions);
            }

            showSettings() {
                const settings = `
                    تنظیمات بازی:
                    
                    - حساسیت ماوس: قابل تنظیم
                    - حجم صدا: قابل تنظیم
                    - کیفیت گرافیک: قابل تنظیم
                    - کنترل‌ها: قابل تنظیم
                    
                    (این تنظیمات در نسخه کامل پیاده‌سازی می‌شوند)
                `;
                alert(settings);
            }

            // Utility functions
            getRandomColor() {
                return new BABYLON.Color3(
                    Math.random(),
                    Math.random(), 
                    Math.random()
                );
            }

            createParticle(position, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    const particle = BABYLON.MeshBuilder.CreateSphere("particle", 
                        { diameter: 0.2 }, this.scene);
                    particle.position = position.clone();
                    
                    const material = new BABYLON.StandardMaterial("particleMat", this.scene);
                    material.emissiveColor = color;
                    material.alpha = 0.8;
                    particle.material = material;
                    
                    setTimeout(() => {
                        particle.dispose();
                    }, 1000);
                }
            }
        }

        // =====================================================
        // INITIALIZE THE GAME WHEN PAGE LOADS
        // =====================================================

        let game;

        window.addEventListener('DOMContentLoaded', function() {
            console.log("صفحه بارگذاری شد، در حال شروع بازی...");
            game = new QuantumStrikeGame();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (game && document.hidden) {
                game.isPaused = true;
            } else if (game) {
                game.isPaused = false;
            }
        });

        // Prevent scrolling with arrow keys
        window.addEventListener('keydown', function(e) {
            if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.code) > -1) {
                e.preventDefault();
            }
        }, false);

    </script>
</body>
                                                                                   </html>
