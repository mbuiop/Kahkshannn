<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic Warfare - Ù†Ø¨Ø±Ø¯ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸš€</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
        }
        
        body {
            background: #000000;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
            color: white;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* ØµÙØ­Ù‡ Ø´Ø±ÙˆØ¹ */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .stars-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                radial-gradient(2px 2px at 40px 70px, #fff, transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 1px at 130px 80px, #fff, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: starsMove 100s linear infinite;
        }

        @keyframes starsMove {
            from { transform: translateY(0); }
            to { transform: translateY(200px); }
        }

        .title-container {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
            z-index: 2;
        }

        .main-title {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff0080, #8000ff, #0080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px rgba(255, 0, 128, 0.7);
            margin-bottom: 15px;
        }

        .subtitle {
            font-size: 1rem;
            color: #aaccff;
            margin-bottom: 20px;
        }

        .stats-container {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(0, 204, 255, 0.5);
            border-radius: 12px;
            padding: 12px 18px;
            text-align: center;
            backdrop-filter: blur(10px);
            min-width: 100px;
        }

        .stat-value {
            font-size: 1.5rem;
            color: #00ccff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaccff;
        }

        .start-button {
            background: linear-gradient(45deg, #ff0080, #ff6600);
            border: none;
            padding: 16px 40px;
            font-size: 1.2rem;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 8px 25px rgba(255, 0, 128, 0.5);
            transition: all 0.3s;
            z-index: 2;
            margin-top: 15px;
        }

        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(255, 0, 128, 0.7);
        }

        /* ØµÙØ­Ù‡ Ø¨Ø§Ø²ÛŒ */
        #gameScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            display: none;
            overflow: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD Ø¨Ø§Ø²ÛŒ */
        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .hud-top {
            position: absolute;
            top: max(10px, env(safe-area-inset-top));
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15px;
        }

        .score-container, .level-container, .health-container {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            padding: 8px 12px;
            backdrop-filter: blur(10px);
            min-width: 60px;
        }

        .score-value, .level-value, .health-value {
            font-size: 1rem;
            color: #00ccff;
            font-weight: bold;
            text-align: center;
        }

        .score-label, .level-label, .health-label {
            font-size: 0.6rem;
            color: #aaccff;
            text-align: center;
        }

        /* Ù…ÛŒÙ†ÛŒ Ù…Ù¾ */
        .mini-map {
            position: absolute;
            bottom: max(25px, env(safe-area-inset-bottom));
            right: 15px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 250;
            overflow: hidden;
        }

        /* Ø¬ÙˆÛŒâ€ŒØ§Ø³ØªÛŒÚ© Ù¾Ø§ÛŒÛŒÙ† ØµÙØ­Ù‡ */
        .joystick-container {
            position: fixed;
            bottom: max(25px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 90px;
            height: 90px;
            z-index: 300;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 35px;
            height: 35px;
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.7);
            transition: transform 0.1s;
        }

        /* ØµÙØ­Ù‡ Ù„ÙˆØ¯ÛŒÙ†Ú¯ */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
        }

        .loading-text {
            font-size: 2rem;
            color: #00ccff;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Ø±Ø³Ù¾Ø§Ù†Ø³ÛŒÙˆ */
        @media (max-width: 768px) {
            .main-title {
                font-size: 2rem;
            }
            
            .stats-container {
                flex-direction: column;
                gap: 12px;
            }
            
            .hud-top {
                flex-direction: row;
                gap: 8px;
                align-items: flex-start;
            }
            
            .score-container, .level-container, .health-container {
                width: auto;
                text-align: center;
            }
            
            .start-button {
                padding: 14px 30px;
                font-size: 1rem;
            }
            
            .mini-map {
                width: 130px;
                height: 130px;
            }
        }

        @media (max-width: 480px) {
            .main-title {
                font-size: 1.6rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
            }
            
            .stat-item {
                padding: 10px 12px;
                min-width: 85px;
            }
            
            .stat-value {
                font-size: 1.3rem;
            }
            
            .stat-label {
                font-size: 0.7rem;
            }
            
            .mini-map {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- ØµÙØ­Ù‡ Ø´Ø±ÙˆØ¹ -->
    <div id="startScreen">
        <div class="stars-bg"></div>
        
        <div class="title-container">
            <h1 class="main-title">GALACTIC WARFARE</h1>
            <p class="subtitle">Ù†Ø¨Ø±Ø¯ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ Ø¯Ø± Ø¹Ù…Ù‚ ÙØ¶Ø§</p>
        </div>
        
        <div class="stats-container">
            <div class="stat-item">
                <div class="stat-value" id="highScore">0</div>
                <div class="stat-label">Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø§Ù…ØªÛŒØ§Ø²</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalCoins">0</div>
                <div class="stat-label">Ø³Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalKills">0</div>
                <div class="stat-label">Ø¯Ø´Ù…Ù†Ø§Ù† Ù†Ø§Ø¨ÙˆØ¯ Ø´Ø¯Ù‡</div>
            </div>
        </div>
        
        <button class="start-button" onclick="startGame()">ğŸš€ Ø´Ø±ÙˆØ¹ Ù†Ø¨Ø±Ø¯</button>
    </div>

    <!-- ØµÙØ­Ù‡ Ø¨Ø§Ø²ÛŒ -->
    <div id="gameScreen">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD Ø¨Ø§Ø²ÛŒ -->
        <div class="game-hud">
            <div class="hud-top">
                <div class="score-container">
                    <div class="score-value" id="scoreValue">0</div>
                    <div class="score-label">Ø§Ù…ØªÛŒØ§Ø²</div>
                </div>
                
                <div class="level-container">
                    <div class="level-value" id="levelValue">1</div>
                    <div class="level-label">Ù…Ø±Ø­Ù„Ù‡</div>
                </div>
                
                <div class="health-container">
                    <div class="health-value" id="healthValue">100</div>
                    <div class="health-label">Ø³Ø§Ù„Ù…Øª</div>
                </div>
            </div>
            
            <!-- Ù…ÛŒÙ†ÛŒ Ù…Ù¾ -->
            <div class="mini-map">
                <canvas id="miniMap"></canvas>
            </div>
        </div>
        
        <!-- Ø¬ÙˆÛŒâ€ŒØ§Ø³ØªÛŒÚ© -->
        <div class="joystick-container">
            <div class="joystick-base">
                <div class="joystick-handle" id="joystickHandle"></div>
            </div>
        </div>
        
        <!-- ØµÙØ­Ù‡ Ù„ÙˆØ¯ÛŒÙ†Ú¯ -->
        <div class="loading-screen" id="loadingScreen">
            <div class="loading-text">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¹Ø¯...</div>
        </div>
    </div>

    <script>
        // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø²ÛŒ
        const GAME_CONFIG = {
            WORLD_SIZE: 15000, // Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¬Ù‡Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù‚ Ø¨ÛŒØ´ØªØ±
            COINS_PER_LEVEL: 80, // Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§
            COIN_HITS_REQUIRED: 8, // Ú©Ø§Ù‡Ø´ ØªØ¹Ø¯Ø§Ø¯ Ø¶Ø±Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù… Ø¨Ø±Ø§ÛŒ Ø³Ú©Ù‡
            ENEMY_SPAWN_RATE: 200, // Ø§ÙØ²Ø§ÛŒØ´ Ø³Ø±Ø¹Øª ØªÙˆÙ„ÛŒØ¯ Ø¯Ø´Ù…Ù†
            PLAYER_SPEED: 10, // Ø§ÙØ²Ø§ÛŒØ´ Ø³Ø±Ø¹Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
            CAMERA_FOLLOW_SPEED: 0.08,
            PLAYER_SIZE: 80,
            BULLET_COUNT: 8, // Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§
            INITIAL_ENEMIES: 80, // Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø´Ù…Ù†Ø§Ù† Ø§ÙˆÙ„ÛŒÙ‡
            ZOOM_FACTOR: 0.4, // Ú©Ø§Ù‡Ø´ Ø²ÙˆÙ… Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù‚ Ø¨ÛŒØ´ØªØ±
            COIN_SIZE: 60,
            ENEMY_SIZE: 50,
            HEALTH_SPAWN_RATE: 60000,
            HEALTH_DURATION: 60000,
            AUTO_SHOOT_COINS: true,
            BULLET_RANGE: 1200, // Ø§ÙØ²Ø§ÛŒØ´ Ø¨Ø±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡
            ENEMY_SPAWN_INCREASE: 0.2 // Ø§ÙØ²Ø§ÛŒØ´ 20% Ø¯Ø´Ù…Ù†Ø§Ù† Ø¯Ø± Ù‡Ø± Ù…Ø±Ø­Ù„Ù‡
        };

        // ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ
        const gameState = {
            score: 0,
            highScore: parseInt(localStorage.getItem('galacticHighScore')) || 0,
            totalCoins: parseInt(localStorage.getItem('galacticTotalCoins')) || 0,
            totalKills: parseInt(localStorage.getItem('galacticTotalKills')) || 0,
            coins: 0,
            health: 100,
            level: parseInt(localStorage.getItem('galacticLevel')) || 1,
            enemiesDestroyed: 0,
            gameRunning: false,
            camera: { x: 0, y: 0 },
            lastHealthSpawn: 0,
            healthItems: []
        };

        // Ø§Ù„Ù…Ø§Ù†â€ŒÙ‡Ø§ÛŒ DOM
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const gameCanvas = document.getElementById('gameCanvas');
        const scoreValue = document.getElementById('scoreValue');
        const levelValue = document.getElementById('levelValue');
        const healthValue = document.getElementById('healthValue');
        const highScoreElement = document.getElementById('highScore');
        const totalCoinsElement = document.getElementById('totalCoins');
        const totalKillsElement = document.getElementById('totalKills');
        const joystickHandle = document.getElementById('joystickHandle');
        const miniMap = document.getElementById('miniMap');
        const loadingScreen = document.getElementById('loadingScreen');

        // ØªÙ†Ø¸ÛŒÙ… Canvas
        const ctx = gameCanvas.getContext('2d');
        const mapCtx = miniMap.getContext('2d');
        
        function setupCanvas() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            miniMap.width = miniMap.clientWidth;
            miniMap.height = miniMap.clientHeight;
        }
        
        setupCanvas();

        // ØµØ¯Ø§Ù‡Ø§
        const moveSound = new Audio('m1.mp3');
        const coinSound = new Audio('m2.mp3');
        
        // ØªÙ†Ø¸ÛŒÙ…Ø§Øª ØµØ¯Ø§
        moveSound.volume = 0.3;
        coinSound.volume = 0.5;
        moveSound.loop = true;
        let moveSoundPlaying = false;

        // Ø§Ø´ÛŒØ§Ø¡ Ø¨Ø§Ø²ÛŒ
        let player = {
            x: GAME_CONFIG.WORLD_SIZE / 2,
            y: GAME_CONFIG.WORLD_SIZE / 2,
            width: GAME_CONFIG.PLAYER_SIZE,
            height: GAME_CONFIG.PLAYER_SIZE * 0.8,
            speed: GAME_CONFIG.PLAYER_SPEED,
            color: '#00aaff',
            rotation: 0
        };

        let enemies = [];
        let bullets = [];
        let coins = [];
        let particles = [];
        let stars = [];

        // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§
        let controls = {
            moveX: 0,
            moveY: 0,
            joystickActive: false,
            joystickStartX: 0,
            joystickStartY: 0
        };

        // Ø§ÛŒØ¬Ø§Ø¯ Ø³ØªØ§Ø±Ù‡â€ŒÙ‡Ø§
        function createStars() {
            stars = [];
            for (let i = 0; i < 3000; i++) {
                stars.push({
                    x: Math.random() * GAME_CONFIG.WORLD_SIZE,
                    y: Math.random() * GAME_CONFIG.WORLD_SIZE,
                    size: Math.random() * 3 + 1,
                    brightness: Math.random() * 0.8 + 0.2,
                    speed: Math.random() * 0.5 + 0.1
                });
            }
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§
        function createCoins() {
            coins = [];
            const coinsCount = GAME_CONFIG.COINS_PER_LEVEL;
            
            // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ø¯Ø± Ù…Ù†Ø§Ø·Ù‚ Ù…Ø®ØªÙ„Ù Ø¬Ù‡Ø§Ù†
            for (let i = 0; i < coinsCount; i++) {
                // ØªÙˆØ²ÛŒØ¹ Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ø¯Ø± Ù…Ù†Ø§Ø·Ù‚ Ù…Ø®ØªÙ„Ù Ø¬Ù‡Ø§Ù†
                const region = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(region) {
                    case 0: // Ù…Ø±Ú©Ø²
                        x = GAME_CONFIG.WORLD_SIZE / 2 + (Math.random() - 0.5) * 2000;
                        y = GAME_CONFIG.WORLD_SIZE / 2 + (Math.random() - 0.5) * 2000;
                        break;
                    case 1: // Ú¯ÙˆØ´Ù‡ Ø¨Ø§Ù„Ø§ Ú†Ù¾
                        x = Math.random() * 4000 + 1000;
                        y = Math.random() * 4000 + 1000;
                        break;
                    case 2: // Ú¯ÙˆØ´Ù‡ Ù¾Ø§ÛŒÛŒÙ† Ø±Ø§Ø³Øª
                        x = GAME_CONFIG.WORLD_SIZE - Math.random() * 4000 - 1000;
                        y = GAME_CONFIG.WORLD_SIZE - Math.random() * 4000 - 1000;
                        break;
                    case 3: // Ú¯ÙˆØ´Ù‡ Ø¨Ø§Ù„Ø§ Ø±Ø§Ø³Øª
                        x = GAME_CONFIG.WORLD_SIZE - Math.random() * 4000 - 1000;
                        y = Math.random() * 4000 + 1000;
                        break;
                }
                
                coins.push({
                    x: x,
                    y: y,
                    size: GAME_CONFIG.COIN_SIZE,
                    value: 100,
                    hits: 0,
                    hitsRequired: GAME_CONFIG.COIN_HITS_REQUIRED,
                    type: Math.floor(Math.random() * 3),
                    rotation: 0,
                    collected: false
                });
            }
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù†
        function createEnemy() {
            // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù† Ø¯Ø± Ú©Ù„ ÙØ¶Ø§ÛŒ Ø¬Ù‡Ø§Ù†
            const region = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(region) {
                case 0: // Ù…Ø±Ú©Ø²
                    x = GAME_CONFIG.WORLD_SIZE / 2 + (Math.random() - 0.5) * 3000;
                    y = GAME_CONFIG.WORLD_SIZE / 2 + (Math.random() - 0.5) * 3000;
                    break;
                case 1: // Ú¯ÙˆØ´Ù‡ Ø¨Ø§Ù„Ø§ Ú†Ù¾
                    x = Math.random() * 5000 + 500;
                    y = Math.random() * 5000 + 500;
                    break;
                case 2: // Ú¯ÙˆØ´Ù‡ Ù¾Ø§ÛŒÛŒÙ† Ø±Ø§Ø³Øª
                    x = GAME_CONFIG.WORLD_SIZE - Math.random() * 5000 - 500;
                    y = GAME_CONFIG.WORLD_SIZE - Math.random() * 5000 - 500;
                    break;
                case 3: // Ú¯ÙˆØ´Ù‡ Ø¨Ø§Ù„Ø§ Ø±Ø§Ø³Øª
                    x = GAME_CONFIG.WORLD_SIZE - Math.random() * 5000 - 500;
                    y = Math.random() * 5000 + 500;
                    break;
            }
            
            const enemyTypes = [
                { health: 2, speed: 1.5, color: '#ff3333', size: GAME_CONFIG.ENEMY_SIZE },
                { health: 3, speed: 1.2, color: '#ff6600', size: GAME_CONFIG.ENEMY_SIZE * 1.1 },
                { health: 4, speed: 1, color: '#cc0000', size: GAME_CONFIG.ENEMY_SIZE * 1.2 },
                { health: 5, speed: 0.8, color: '#990000', size: GAME_CONFIG.ENEMY_SIZE * 1.3 }
            ];
            
            const typeIndex = Math.min(gameState.level - 1, 3);
            const type = enemyTypes[typeIndex];
            
            enemies.push({
                x: x,
                y: y,
                width: type.size,
                height: type.size,
                speed: type.speed,
                health: type.health,
                maxHealth: type.health,
                color: type.color,
                lastShot: Date.now(),
                shootDelay: 2000 - (gameState.level * 150),
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.05
            });
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ù„Ø§Ù…Øª
        function createHealthItem() {
            gameState.healthItems.push({
                x: Math.random() * (GAME_CONFIG.WORLD_SIZE - 200) + 100,
                y: Math.random() * (GAME_CONFIG.WORLD_SIZE - 200) + 100,
                size: 40,
                spawnTime: Date.now(),
                collected: false
            });
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ù„ÙˆÙ„Ù‡
        function createBullet(x, y, targetX, targetY, isPlayer = true) {
            const dx = targetX - x;
            const dy = targetY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Ø§ÙØ²Ø§ÛŒØ´ Ù‚Ø¯Ø±Øª Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†
            const speed = isPlayer ? 12 : 5;
            const damage = isPlayer ? (1 + gameState.level * 0.2) : 0.5;
            
            bullets.push({
                x: x,
                y: y,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                width: isPlayer ? 10 : 6,
                height: isPlayer ? 10 : 6,
                color: isPlayer ? '#00ffff' : '#ff3300',
                isPlayer: isPlayer,
                damage: damage,
                range: GAME_CONFIG.BULLET_RANGE,
                distanceTraveled: 0
            });
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ø°Ø±Ø§Øª
        function createParticles(x, y, count, color, sizeMultiplier = 1) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    maxLife: 1,
                    size: Math.random() * 3 + 2 * sizeMultiplier,
                    color: color
                });
            }
        }

        // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙÚ©Øª ØªØ®Ø±ÛŒØ¨ Ø³Ú©Ù‡
        function createCoinExplosion(x, y) {
            // Ø§ÙÚ©Øª Ø¨Ø²Ø±Ú¯ Ø¨Ø±Ø§ÛŒ ØªØ®Ø±ÛŒØ¨ Ø³Ú©Ù‡
            for (let i = 0; i < 40; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1,
                    maxLife: 1.5,
                    size: Math.random() * 5 + 3,
                    color: '#ffd700'
                });
            }
            
            // Ø§ÙÚ©Øª Ù†ÙˆØ±Ø§Ù†ÛŒ
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    maxLife: 2,
                    size: Math.random() * 8 + 5,
                    color: '#ffff00'
                });
            }
        }

        // Ø´Ù„ÛŒÚ© Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Ø¯Ø´Ù…Ù†Ø§Ù† Ùˆ Ø³Ú©Ù‡â€ŒÙ‡Ø§
        function autoShoot() {
            if (!gameState.gameRunning) return;
            
            let targets = [];
            
            // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ø³Ú©Ù‡â€ŒÙ‡Ø§ Ùˆ Ø¯Ø´Ù…Ù†Ø§Ù† Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡
            coins.forEach(coin => {
                if (coin.collected) return;
                
                const dx = coin.x - player.x;
                const dy = coin.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < GAME_CONFIG.BULLET_RANGE) {
                    targets.push({
                        x: coin.x,
                        y: coin.y,
                        isCoin: true,
                        distance: distance
                    });
                }
            });
            
            enemies.forEach(enemy => {
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < GAME_CONFIG.BULLET_RANGE) {
                    targets.push({
                        x: enemy.x,
                        y: enemy.y,
                        isCoin: false,
                        distance: distance
                    });
                }
            });
            
            // Ù…Ø±ØªØ¨ Ú©Ø±Ø¯Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†Ø²Ø¯ÛŒÚ©ÛŒ
            targets.sort((a, b) => a.distance - b.distance);
            
            // Ø´Ù„ÛŒÚ© Ø¨Ù‡ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ø§Ù‡Ø¯Ø§Ù
            const targetsToShoot = Math.min(GAME_CONFIG.BULLET_COUNT, targets.length);
            
            for (let i = 0; i < targetsToShoot; i++) {
                setTimeout(() => {
                    if (gameState.gameRunning) {
                        const target = targets[i];
                        const targetX = target.x + (Math.random() - 0.5) * 50;
                        const targetY = target.y + (Math.random() - 0.5) * 50;
                        createBullet(player.x, player.y, targetX, targetY, true);
                        createParticles(player.x, player.y, 2, '#00aaff');
                    }
                }, i * 80);
            }
        }

        // Ø´Ù„ÛŒÚ© Ø¯Ø´Ù…Ù†Ø§Ù†
        function enemyShoot() {
            const now = Date.now();
            
            enemies.forEach(enemy => {
                if (now - enemy.lastShot > enemy.shootDelay) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 1000) {
                        createBullet(enemy.x, enemy.y, player.x, player.y, false);
                        enemy.lastShot = now;
                        createParticles(enemy.x, enemy.y, 3, '#ff3300');
                    }
                }
            });
        }

        // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ HUD
        function updateHUD() {
            scoreValue.textContent = gameState.score.toLocaleString();
            levelValue.textContent = gameState.level;
            healthValue.textContent = Math.max(0, Math.floor(gameState.health));
        }

        // ØªØ´Ø®ÛŒØµ Ø¨Ø±Ø®ÙˆØ±Ø¯
        function checkCollisions() {
            // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ Ø¯Ø´Ù…Ù†
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                if (!bullet.isPlayer) continue;
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (Math.abs(bullet.x - enemy.x) < (bullet.width + enemy.width) / 2 &&
                        Math.abs(bullet.y - enemy.y) < (bullet.height + enemy.height) / 2) {
                        
                        enemy.health -= bullet.damage;
                        createParticles(enemy.x, enemy.y, 8, '#ff6600');
                        bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            createParticles(enemy.x, enemy.y, 15, '#ff3300');
                            enemies.splice(j, 1);
                            gameState.score += 100 * gameState.level;
                            gameState.enemiesDestroyed++;
                            gameState.totalKills++;
                        }
                        
                        break;
                    }
                }
            }
            
            // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ Ø³Ú©Ù‡
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                if (!bullet.isPlayer) continue;
                
                for (let j = coins.length - 1; j >= 0; j--) {
                    const coin = coins[j];
                    
                    if (coin.collected) continue;
                    
                    if (Math.abs(bullet.x - coin.x) < (bullet.width + coin.size) / 2 &&
                        Math.abs(bullet.y - coin.y) < (bullet.height + coin.size) / 2) {
                        
                        coin.hits += 1;
                        createParticles(coin.x, coin.y, 5, '#ffd700');
                        bullets.splice(i, 1);
                        
                        if (coin.hits >= coin.hitsRequired) {
                            coin.collected = true;
                            gameState.coins++;
                            gameState.totalCoins++;
                            gameState.score += coin.value;
                            
                            // Ø§ÙÚ©Øª ØªØ®Ø±ÛŒØ¨ Ø³Ú©Ù‡
                            createCoinExplosion(coin.x, coin.y);
                            coinSound.play();
                            coins.splice(j, 1);
                            
                            if (gameState.coins >= GAME_CONFIG.COINS_PER_LEVEL) {
                                showLevelComplete();
                            }
                        }
                        
                        updateHUD();
                        break;
                    }
                }
            }
            
            // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø¯Ø´Ù…Ù† Ø¨Ø§ Ø¨Ø§Ø²ÛŒÚ©Ù†
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                if (bullet.isPlayer) continue;
                
                if (Math.abs(bullet.x - player.x) < (bullet.width + player.width) / 2 &&
                    Math.abs(bullet.y - player.y) < (bullet.height + player.height) / 2) {
                    
                    gameState.health -= 8;
                    createParticles(player.x, player.y, 12, '#ff0000');
                    bullets.splice(i, 1);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                    
                    updateHUD();
                }
            }
            
            // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ Ø³Ù„Ø§Ù…Øª
            for (let i = gameState.healthItems.length - 1; i >= 0; i--) {
                const healthItem = gameState.healthItems[i];
                
                if (healthItem.collected) continue;
                
                if (Math.abs(player.x - healthItem.x) < (player.width + healthItem.size) / 2 &&
                    Math.abs(player.y - healthItem.y) < (player.height + healthItem.size) / 2) {
                    
                    healthItem.collected = true;
                    gameState.health = Math.min(100, gameState.health + 25);
                    createParticles(healthItem.x, healthItem.y, 15, '#ffff00', 1.2);
                    gameState.healthItems.splice(i, 1);
                    
                    updateHUD();
                }
            }
            
            // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¯Ø´Ù…Ù† Ø¨Ø§ Ø¨Ø§Ø²ÛŒÚ©Ù†
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                if (Math.abs(player.x - enemy.x) < (player.width + enemy.width) / 2 &&
                    Math.abs(player.y - enemy.y) < (player.height + enemy.height) / 2) {
                    
                    gameState.health -= 12;
                    createParticles(player.x, player.y, 15, '#ff0000');
                    enemies.splice(i, 1);
                    
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                    
                    updateHUD();
                }
            }
        }

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯ÙˆØ±Ø¨ÛŒÙ†
        function updateCamera() {
            // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ú©Ù„ Ù¾Ø³ Ø²Ù…ÛŒÙ†Ù‡ Ø±Ø§ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯ Ø¨Ø§ Ø²ÙˆÙ… Ú©Ù…ØªØ±
            const targetX = player.x - gameCanvas.width / (2 * GAME_CONFIG.ZOOM_FACTOR);
            const targetY = player.y - gameCanvas.height / (2 * GAME_CONFIG.ZOOM_FACTOR);
            
            gameState.camera.x += (targetX - gameState.camera.x) * GAME_CONFIG.CAMERA_FOLLOW_SPEED;
            gameState.camera.y += (targetY - gameState.camera.y) * GAME_CONFIG.CAMERA_FOLLOW_SPEED;
            
            // Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ù‡ Ù…Ø±Ø²Ù‡Ø§ÛŒ Ø¬Ù‡Ø§Ù†
            gameState.camera.x = Math.max(0, Math.min(GAME_CONFIG.WORLD_SIZE - gameCanvas.width / GAME_CONFIG.ZOOM_FACTOR, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(GAME_CONFIG.WORLD_SIZE - gameCanvas.height / GAME_CONFIG.ZOOM_FACTOR, gameState.camera.y));
        }

        // ØªØ¨Ø¯ÛŒÙ„ Ù…Ø®ØªØµØ§Øª Ø¬Ù‡Ø§Ù†ÛŒ Ø¨Ù‡ Ù…Ø®ØªØµØ§Øª ØµÙØ­Ù‡
        function worldToScreen(x, y) {
            return {
                x: (x - gameState.camera.x) * GAME_CONFIG.ZOOM_FACTOR,
                y: (y - gameState.camera.y) * GAME_CONFIG.ZOOM_FACTOR
            };
        }

        // Ø±Ø³Ù… Ù…ÛŒÙ†ÛŒ Ù…Ù¾
        function renderMiniMap() {
            mapCtx.fillStyle = '#000011';
            mapCtx.fillRect(0, 0, miniMap.width, miniMap.height);
            
            const scale = Math.min(miniMap.width, miniMap.height) / GAME_CONFIG.WORLD_SIZE;
            
            // Ø±Ø³Ù… Ú©Ù„ Ø¬Ù‡Ø§Ù† Ø¯Ø± Ù…ÛŒÙ†ÛŒ Ù…Ù¾
            const offsetX = (miniMap.width - GAME_CONFIG.WORLD_SIZE * scale) / 2;
            const offsetY = (miniMap.height - GAME_CONFIG.WORLD_SIZE * scale) / 2;
            
            // Ø±Ø³Ù… Ø³Ú©Ù‡â€ŒÙ‡Ø§ (Ø³Ø¨Ø²)
            coins.forEach(coin => {
                if (coin.collected) return;
                const x = coin.x * scale + offsetX;
                const y = coin.y * scale + offsetY;
                mapCtx.fillStyle = '#00ff00';
                mapCtx.beginPath();
                mapCtx.arc(x, y, 2, 0, Math.PI * 2);
                mapCtx.fill();
            });
            
            // Ø±Ø³Ù… Ø¯Ø´Ù…Ù†Ø§Ù† (Ù‚Ø±Ù…Ø²)
            enemies.forEach(enemy => {
                const x = enemy.x * scale + offsetX;
                const y = enemy.y * scale + offsetY;
                mapCtx.fillStyle = '#ff0000';
                mapCtx.beginPath();
                mapCtx.arc(x, y, 1.5, 0, Math.PI * 2);
                mapCtx.fill();
            });
            
            // Ø±Ø³Ù… Ø³Ù„Ø§Ù…Øª (Ø²Ø±Ø¯)
            gameState.healthItems.forEach(healthItem => {
                const x = healthItem.x * scale + offsetX;
                const y = healthItem.y * scale + offsetY;
                mapCtx.fillStyle = '#ffff00';
                mapCtx.beginPath();
                mapCtx.arc(x, y, 2, 0, Math.PI * 2);
                mapCtx.fill();
            });
            
            // Ø±Ø³Ù… Ø¨Ø§Ø²ÛŒÚ©Ù† (Ø¢Ø¨ÛŒ)
            const playerX = player.x * scale + offsetX;
            const playerY = player.y * scale + offsetY;
            mapCtx.fillStyle = '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(playerX, playerY, 3, 0, Math.PI * 2);
            mapCtx.fill();
            
            // Ø±Ø³Ù… Ù…Ø±Ø²Ù‡Ø§ÛŒ Ø¯ÛŒØ¯ ÙØ¹Ù„ÛŒ
            const cameraWidth = gameCanvas.width / GAME_CONFIG.ZOOM_FACTOR * scale;
            const cameraHeight = gameCanvas.height / GAME_CONFIG.ZOOM_FACTOR * scale;
            const cameraX = gameState.camera.x * scale + offsetX;
            const cameraY = gameState.camera.y * scale + offsetY;
            
            mapCtx.strokeStyle = '#ffffff';
            mapCtx.lineWidth = 1;
            mapCtx.strokeRect(cameraX, cameraY, cameraWidth, cameraHeight);
        }

        // Ø±Ù†Ø¯Ø± Ø¨Ø§Ø²ÛŒ
        function render() {
            // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Canvas
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
            
            // Ø±Ø³Ù… Ø³ØªØ§Ø±Ù‡â€ŒÙ‡Ø§
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                const screenPos = worldToScreen(star.x, star.y);
                if (screenPos.x >= -10 && screenPos.x <= gameCanvas.width + 10 &&
                    screenPos.y >= -10 && screenPos.y <= gameCanvas.height + 10) {
                    ctx.globalAlpha = star.brightness;
                    ctx.fillRect(screenPos.x, screenPos.y, star.size, star.size);
                }
            });
            ctx.globalAlpha = 1;
            
            // Ø±Ø³Ù… Ø³Ú©Ù‡â€ŒÙ‡Ø§
            coins.forEach(coin => {
                if (coin.collected) return;
                
                const screenPos = worldToScreen(coin.x, coin.y);
                if (screenPos.x < -100 || screenPos.x > gameCanvas.width + 100 ||
                    screenPos.y < -100 || screenPos.y > gameCanvas.height + 100) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(coin.rotation);
                
                let emoji, color;
                switch(coin.type) {
                    case 0: emoji = 'ğŸ›Ÿ'; color = '#4ecdc4'; break;
                    case 1: emoji = 'â„ï¸'; color = '#aaccff'; break;
                    case 2: emoji = 'â­'; color = '#ffd700'; break;
                }
                
                // Ø¯Ø§ÛŒØ±Ù‡ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
                ctx.fillStyle = color + '40';
                ctx.beginPath();
                ctx.arc(0, 0, coin.size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Ø­Ø§Ø´ÛŒÙ‡ Ø¯Ø±Ø®Ø´Ø§Ù†
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ø¨Ø²Ø±Ú¯
                ctx.font = `bold ${coin.size * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, 0, 0);
                
                // Ù†Ù…Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ø¶Ø±Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.fillText((coin.hitsRequired - coin.hits).toString(), 0, coin.size / 2 + 15);
                
                ctx.restore();
                
                coin.rotation += 0.02;
            });
            
            // Ø±Ø³Ù… Ø³Ù„Ø§Ù…Øª
            gameState.healthItems.forEach(healthItem => {
                const screenPos = worldToScreen(healthItem.x, healthItem.y);
                if (screenPos.x < -100 || screenPos.x > gameCanvas.width + 100 ||
                    screenPos.y < -100 || screenPos.y > gameCanvas.height + 100) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                
                // Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ø³Ù„Ø§Ù…Øª
                ctx.font = `bold ${healthItem.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš¡ï¸', 0, 0);
                
                ctx.restore();
            });
            
            // Ø±Ø³Ù… Ø¯Ø´Ù…Ù†Ø§Ù†
            enemies.forEach(enemy => {
                const screenPos = worldToScreen(enemy.x, enemy.y);
                if (screenPos.x < -100 || screenPos.x > gameCanvas.width + 100 ||
                    screenPos.y < -100 || screenPos.y > gameCanvas.height + 100) {
                    return;
                }
                
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(enemy.rotation);
                
                // Ø§ÛŒÙ…ÙˆØ¬ÛŒ Ø¢ØªØ´ÙØ´Ø§Ù†
                ctx.font = `bold ${enemy.width}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸŒ‹', 0, 0);
                
                // Ù†ÙˆØ§Ø± Ø³Ù„Ø§Ù…Øª
                const healthWidth = 40;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#333333';
                ctx.fillRect(-healthWidth / 2, -enemy.height / 2 - 12, healthWidth, 5);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.2 ? '#ffaa00' : '#ff3300';
                ctx.fillRect(-healthWidth / 2, -enemy.height / 2 - 12, healthWidth * healthPercent, 5);
                
                ctx.restore();
                
                enemy.rotation += enemy.rotationSpeed;
            });
            
            // Ø±Ø³Ù… Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§
            bullets.forEach(bullet => {
                const screenPos = worldToScreen(bullet.x, bullet.y);
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, bullet.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Ø¯Ù†Ø¨Ø§Ù„Ù‡
                ctx.strokeStyle = bullet.color + '80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenPos.x - bullet.vx * 0.3, screenPos.y - bullet.vy * 0.3);
                ctx.lineTo(screenPos.x, screenPos.y);
                ctx.stroke();
            });
            
            // Ø±Ø³Ù… Ø°Ø±Ø§Øª
            particles.forEach(particle => {
                const screenPos = worldToScreen(particle.x, particle.y);
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, particle.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Ø±Ø³Ù… Ø¨Ø§Ø²ÛŒÚ©Ù†
            const playerScreenPos = worldToScreen(player.x, player.y);
            ctx.save();
            ctx.translate(playerScreenPos.x, playerScreenPos.y);
            
            // Ú†Ø±Ø®Ø´ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø­Ø±Ú©Øª
            if (controls.moveX !== 0 || controls.moveY !== 0) {
                player.rotation = Math.atan2(controls.moveY, controls.moveX);
            }
            ctx.rotate(player.rotation);
            
            // Ø¨Ø¯Ù†Ù‡ Ø§ØµÙ„ÛŒ Ø³ÙÛŒÙ†Ù‡
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 0);
            ctx.lineTo(-player.width / 3, -player.height / 2);
            ctx.lineTo(-player.width / 2, 0);
            ctx.lineTo(-player.width / 3, player.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Ú©Ø§Ø¨ÛŒÙ† Ø®Ù„Ø¨Ø§Ù†
            ctx.fillStyle = '#aaffff';
            ctx.beginPath();
            ctx.arc(player.width / 4, 0, player.width / 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Ù…ÙˆØªÙˆØ±Ù‡Ø§
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(-player.width / 3, -player.height / 4, player.width / 8, 0, Math.PI * 2);
            ctx.arc(-player.width / 3, player.height / 4, player.width / 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Ø¬Ø²Ø¦ÛŒØ§Øª
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
            
            // Ø±Ø³Ù… Ù…ÛŒÙ†ÛŒ Ù…Ù¾
            renderMiniMap();
        }

        // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¨Ø§Ø²ÛŒ
        function update() {
            if (!gameState.gameRunning) return;
            
            // Ø­Ø±Ú©Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
            player.x += controls.moveX * player.speed;
            player.y += controls.moveY * player.speed;
            
            // Ú©Ù†ØªØ±Ù„ ØµØ¯Ø§
            if ((controls.moveX !== 0 || controls.moveY !== 0) && !moveSoundPlaying) {
                moveSound.play();
                moveSoundPlaying = true;
            } else if (controls.moveX === 0 && controls.moveY === 0 && moveSoundPlaying) {
                moveSound.pause();
                moveSound.currentTime = 0;
                moveSoundPlaying = false;
            }
            
            // Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ù‡ Ø¬Ù‡Ø§Ù†
            const margin = 50;
            player.x = Math.max(player.width / 2 + margin, Math.min(GAME_CONFIG.WORLD_SIZE - player.width / 2 - margin, player.x));
            player.y = Math.max(player.height / 2 + margin, Math.min(GAME_CONFIG.WORLD_SIZE - player.height / 2 - margin, player.y));
            
            // Ø­Ø±Ú©Øª Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.distanceTraveled += Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);
                
                // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù…Ø³Ø§ÙØª Ø²ÛŒØ§Ø¯ÛŒ Ø·ÛŒ Ú©Ø±Ø¯Ù‡â€ŒØ§Ù†Ø¯
                if (bullet.distanceTraveled > bullet.range) {
                    bullets.splice(i, 1);
                }
            }
            
            // Ø­Ø±Ú©Øª Ø¯Ø´Ù…Ù†Ø§Ù† Ø¨Ù‡ Ø³Ù…Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
            enemies.forEach(enemy => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
            });
            
            // ØªÙˆÙ„ÛŒØ¯ Ø³Ù„Ø§Ù…Øª
            const now = Date.now();
            if (now - gameState.lastHealthSpawn > GAME_CONFIG.HEALTH_SPAWN_RATE) {
                createHealthItem();
                gameState.lastHealthSpawn = now;
            }
            
            // Ø­Ø°Ù Ø³Ù„Ø§Ù…Øªâ€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
            gameState.healthItems = gameState.healthItems.filter(healthItem => 
                now - healthItem.spawnTime < GAME_CONFIG.HEALTH_DURATION && !healthItem.collected
            );
            
            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø°Ø±Ø§Øª
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ†
            updateCamera();
            
            // ØªØ´Ø®ÛŒØµ Ø¨Ø±Ø®ÙˆØ±Ø¯
            checkCollisions();
            
            // Ø±Ù†Ø¯Ø±
            render();
            
            requestAnimationFrame(update);
        }

        // Ù†Ù…Ø§ÛŒØ´ Ù¾Ø§ÛŒØ§Ù† Ù…Ø±Ø­Ù„Ù‡
        function showLevelComplete() {
            gameState.gameRunning = false;
            loadingScreen.style.display = 'flex';
            
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                levelComplete();
            }, 3000);
        }

        // ØªÚ©Ù…ÛŒÙ„ Ù…Ø±Ø­Ù„Ù‡
        function levelComplete() {
            gameState.level++;
            gameState.coins = 0;
            gameState.health = Math.min(100, gameState.health + 25);
            
            // Ø°Ø®ÛŒØ±Ù‡ Ù…Ø±Ø­Ù„Ù‡
            localStorage.setItem('galacticLevel', gameState.level);
            
            // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø¹Ø¯
            createCoins();
            
            // Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ø¯Ø´Ù…Ù†Ø§Ù†
            clearInterval(enemySpawnInterval);
            const newSpawnRate = Math.max(400, GAME_CONFIG.ENEMY_SPAWN_RATE - (gameState.level * 50));
            enemySpawnInterval = setInterval(createEnemy, newSpawnRate);
            
            updateHUD();
            
            // Ø§ÙÚ©Øª Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticles(
                        player.x + (Math.random() - 0.5) * 200,
                        player.y + (Math.random() - 0.5) * 200,
                        8,
                        '#00ff88'
                    );
                }, i * 100);
            }
            
            gameState.gameRunning = true;
            update();
        }

        // Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
        let enemySpawnInterval;
        let autoShootInterval;
        
        function startGame() {
            startScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            
            // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¢Ù…Ø§Ø±
            highScoreElement.textContent = gameState.highScore.toLocaleString();
            totalCoinsElement.textContent = gameState.totalCoins.toLocaleString();
            totalKillsElement.textContent = gameState.totalKills.toLocaleString();
            
            // ØªÙ†Ø¸ÛŒÙ… Ù…Ø¬Ø¯Ø¯ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ
            gameState.score = 0;
            gameState.coins = 0;
            gameState.health = 100;
            gameState.enemiesDestroyed = 0;
            gameState.gameRunning = true;
            gameState.lastHealthSpawn = Date.now();
            gameState.healthItems = [];
            
            // Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¢Ø±Ø§ÛŒÙ‡â€ŒÙ‡Ø§
            enemies = [];
            bullets = [];
            coins = [];
            particles = [];
            
            // ØªÙ†Ø¸ÛŒÙ… Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù† Ùˆ Ø¯ÙˆØ±Ø¨ÛŒÙ†
            player.x = GAME_CONFIG.WORLD_SIZE / 2;
            player.y = GAME_CONFIG.WORLD_SIZE / 2;
            gameState.camera.x = player.x - gameCanvas.width / (2 * GAME_CONFIG.ZOOM_FACTOR);
            gameState.camera.y = player.y - gameCanvas.height / (2 * GAME_CONFIG.ZOOM_FACTOR);
            
            // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ÛŒØ·
            createStars();
            createCoins();
            
            // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ HUD
            updateHUD();
            
            // Ø´Ø±ÙˆØ¹ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒ
            autoShootInterval = setInterval(autoShoot, 400);
            enemySpawnInterval = setInterval(createEnemy, GAME_CONFIG.ENEMY_SPAWN_RATE);
            setInterval(enemyShoot, 150);
            
            // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù†Ø§Ù† Ø§ÙˆÙ„ÛŒÙ‡ (80 Ø¯Ø´Ù…Ù†)
            for (let i = 0; i < GAME_CONFIG.INITIAL_ENEMIES; i++) {
                createEnemy();
            }
            
            // Ø´Ø±ÙˆØ¹ Ø­Ù„Ù‚Ù‡ Ø¨Ø§Ø²ÛŒ
            update();
        }

        // Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ
        function gameOver() {
            gameState.gameRunning = false;
            clearInterval(autoShootInterval);
            clearInterval(enemySpawnInterval);
            moveSound.pause();
            moveSound.currentTime = 0;
            moveSoundPlaying = false;
            
            // Ø°Ø®ÛŒØ±Ù‡ Ø¢Ù…Ø§Ø±
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('galacticHighScore', gameState.score);
            }
            localStorage.setItem('galacticTotalCoins', gameState.totalCoins);
            localStorage.setItem('galacticTotalKills', gameState.totalKills);
            localStorage.setItem('galacticLevel', gameState.level);
            
            // Ø§Ù†ÙØ¬Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ
            createParticles(player.x, player.y, 50, '#ff0000', 1.5);
            
            setTimeout(() => {
                alert(`Ù…Ø§Ù…ÙˆØ±ÛŒØª Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯!\nØ§Ù…ØªÛŒØ§Ø²: ${gameState.score.toLocaleString()}\nÙ…Ø±Ø­Ù„Ù‡: ${gameState.level}`);
                startScreen.style.display = 'flex';
                gameScreen.style.display = 'none';
                
                // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ø¯Ø± ØµÙØ­Ù‡ Ø´Ø±ÙˆØ¹
                highScoreElement.textContent = gameState.highScore.toLocaleString();
                totalCoinsElement.textContent = gameState.totalCoins.toLocaleString();
                totalKillsElement.textContent = gameState.totalKills.toLocaleString();
            }, 2000);
        }

        // Ú©Ù†ØªØ±Ù„ Ø¬ÙˆÛŒâ€ŒØ§Ø³ØªÛŒÚ©
        const joystickContainer = document.querySelector('.joystick-container');
        const joystickBase = document.querySelector('.joystick-base');
        
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            controls.joystickActive = true;
            
            const rect = joystickBase.getBoundingClientRect();
            controls.joystickStartX = rect.left + rect.width / 2;
            controls.joystickStartY = rect.top + rect.height / 2;
        });

        document.addEventListener('touchmove', (e) => {
            if (!controls.joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - controls.joystickStartX;
            const deltaY = touch.clientY - controls.joystickStartY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 35;
            const limitedDistance = Math.min(distance, maxDistance);
            
            if (distance > 5) {
                const angle = Math.atan2(deltaY, deltaX);
                const moveX = limitedDistance * Math.cos(angle) / maxDistance;
                const moveY = limitedDistance * Math.sin(angle) / maxDistance;
                
                controls.moveX = moveX;
                controls.moveY = moveY;
                
                // Ø­Ø±Ú©Øª Ø¯Ø³ØªÙ‡ Ø¬ÙˆÛŒâ€ŒØ§Ø³ØªÛŒÚ©
                joystickHandle.style.transform = `translate(${moveX * 25}px, ${moveY * 25}px)`;
            }
        });

        document.addEventListener('touchend', (e) => {
            controls.joystickActive = false;
            controls.moveX = 0;
            controls.moveY = 0;
            joystickHandle.style.transform = 'translate(0, 0)';
        });

        // ØªÙ†Ø¸ÛŒÙ… Ø§Ù†Ø¯Ø§Ø²Ù‡ Canvas
        window.addEventListener('resize', () => {
            setupCanvas();
        });

        // Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¢Ù…Ø§Ø±
        window.addEventListener('load', () => {
            highScoreElement.textContent = gameState.highScore.toLocaleString();
            totalCoinsElement.textContent = gameState.totalCoins.toLocaleString();
            totalKillsElement.textContent = gameState.totalKills.toLocaleString();
        });

        // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø²ÙˆÙ… ØµÙØ­Ù‡
        document.addEventListener('gesturestart', function (e) {
            e.preventDefault();
        });
        
        document.addEventListener('gesturechange', function (e) {
            e.preventDefault();
        });
        
        document.addEventListener('gestureend', function (e) {
            e.preventDefault();
        });
    </script>
</body>
</html>