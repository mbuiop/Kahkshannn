<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø±Ø¨Ø§Øª Ø¬Ù†Ú¯ÛŒ - WarBot Advanced</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }
        #renderCanvas { 
            width: 100%; 
            height: 100%; 
            display: block;
            touch-action: none;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            min-width: 250px;
        }
        .health-bar, .ammo-bar, .shield-bar {
            width: 200px;
            height: 12px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
        }
        .health-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            transition: width 0.3s; 
        }
        .ammo-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #ffaa00, #ffd700);
            transition: width 0.3s; 
        }
        .shield-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #00a8ff, #0097e6);
            transition: width 0.3s; 
        }
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff4444;
            text-align: center;
            color: white;
            display: none;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ccc;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="ui">
        <div class="hud">
            <h3 style="color:#00ff88; margin-bottom:15px;">ğŸ¤– Ø±Ø¨Ø§Øª Ø¬Ù†Ú¯ÛŒ</h3>
            <div class="stat">
                <span>Ø³Ù„Ø§Ù…Øª:</span>
                <span id="healthValue">100</span>%
            </div>
            <div class="health-bar"><div class="health-fill" id="healthFill" style="width:100%"></div></div>
            
            <div class="stat">
                <span>Ø³Ù„Ø§Ø­:</span>
                <span id="weaponValue">Ù¾Ù„Ø§Ø³Ù…Ø§</span>
            </div>
            <div class="ammo-bar"><div class="ammo-fill" id="ammoFill" style="width:100%"></div></div>
            
            <div class="stat">
                <span>Ù…Ø­Ø§ÙØ¸:</span>
                <span id="shieldValue">100</span>%
            </div>
            <div class="shield-bar"><div class="shield-fill" id="shieldFill" style="width:100%"></div></div>
            
            <div class="stat">
                <span>Ø§Ù…ØªÛŒØ§Ø²:</span>
                <span id="scoreValue">0</span>
            </div>
            <div class="stat">
                <span>Ø³Ú©Ù‡:</span>
                <span id="coinsValue">0</span>
            </div>
            <div class="stat">
                <span>Ø¯Ø´Ù…Ù†Ø§Ù†:</span>
                <span id="enemiesValue">0</span>
            </div>
        </div>
        
        <div class="controls-info">
            <div>ğŸ”„ <strong>WASD</strong> - Ø­Ø±Ú©Øª | <strong>Ù…Ø§ÙˆØ³</strong> - Ù‡Ø¯Ùâ€ŒÚ¯ÛŒØ±ÛŒ</div>
            <div>ğŸ”« <strong>Ú©Ù„ÛŒÚ© Ú†Ù¾</strong> - Ø´Ù„ÛŒÚ© | <strong>Space</strong> - ØªØ¹ÙˆÛŒØ¶ Ø³Ù„Ø§Ø­</div>
            <div>âš¡ <strong>E</strong> - Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡ | <strong>Shift</strong> - Ø¯ÙˆÛŒØ¯Ù†</div>
        </div>

        <div id="gameOver">
            <h2 style="color:#ff4444; margin-bottom:20px;">ğŸ’€ Ù…Ø§Ù…ÙˆØ±ÛŒØª Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯</h2>
            <div style="margin-bottom:20px;">
                <div>Ø§Ù…ØªÛŒØ§Ø² Ù†Ù‡Ø§ÛŒÛŒ: <span id="finalScore">0</span></div>
                <div>Ø³Ú©Ù‡ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ: <span id="finalCoins">0</span></div>
                <div>Ø¯Ø´Ù…Ù†Ø§Ù† Ù…Ù†Ù‡Ø¯Ù…: <span id="finalKills">0</span></div>
            </div>
            <button onclick="location.reload()" style="padding:12px 30px; background:linear-gradient(45deg,#ff4444,#ff6b6b); border:none; border-radius:10px; color:white; font-size:16px; cursor:pointer;">
                ğŸ”„ Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯
            </button>
        </div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <script>
        // ğŸ® Ù…ÙˆØªÙˆØ± Ø¨Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª Ø¬Ù†Ú¯ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
        class WarBotGame {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.engine = new BABYLON.Engine(this.canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                this.scene = new BABYLON.Scene(this.engine);
                
                this.setupAdvancedScene();
                this.createAdvancedRobot();
                this.createEnvironment();
                this.setupGameSystems();
                this.setupAdvancedControls();
                
                this.startGameLoop();
            }
            
            setupAdvancedScene() {
                // ØµØ­Ù†Ù‡ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ù†ÙˆØ±Ù¾Ø±Ø¯Ø§Ø²ÛŒ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ
                this.scene.clearColor = new BABYLON.Color4(0.05, 0.08, 0.15, 1.0);
                
                // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³ÙˆÙ… Ø´Ø®Øµ Ù¾ÛŒØ´Ø±ÙØªÙ‡
                this.camera = new BABYLON.ArcRotateCamera(
                    "camera", 
                    -Math.PI / 2, Math.PI / 3, 
                    15, 
                    BABYLON.Vector3.Zero(), 
                    this.scene
                );
                this.camera.attachControl(this.canvas, true);
                this.camera.lowerBetaLimit = 0.1;
                this.camera.upperBetaLimit = Math.PI / 2;
                
                // Ø³ÛŒØ³ØªÙ… Ù†ÙˆØ±Ù¾Ø±Ø¯Ø§Ø²ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
                this.setupAdvancedLighting();
                
                // Ø³Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
                this.setupShadows();
            }
            
            setupAdvancedLighting() {
                // Ù†ÙˆØ± Ø§ØµÙ„ÛŒ
                this.mainLight = new BABYLON.DirectionalLight(
                    "mainLight", 
                    new BABYLON.Vector3(-1, -2, -1), 
                    this.scene
                );
                this.mainLight.intensity = 0.8;
                this.mainLight.shadowEnabled = true;
                
                // Ù†ÙˆØ± Ù…Ø­ÛŒØ·ÛŒ
                const ambientLight = new BABYLON.HemisphericLight(
                    "ambientLight", 
                    new BABYLON.Vector3(0, 1, 0), 
                    this.scene
                );
                ambientLight.intensity = 0.3;
                
                // Ù†ÙˆØ± Ù†Ù‚Ø·Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÙÚ©Øªâ€ŒÙ‡Ø§
                this.spotLight = new BABYLON.SpotLight(
                    "spotLight",
                    new BABYLON.Vector3(0, 10, 0),
                    new BABYLON.Vector3(0, -1, 0),
                    Math.PI / 3,
                    2,
                    this.scene
                );
                this.spotLight.intensity = 0.5;
            }
            
            setupShadows() {
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, this.mainLight);
                shadowGenerator.useBlurExponentialShadowMap = true;
                shadowGenerator.blurScale = 2;
                this.shadowGenerator = shadowGenerator;
            }
            
            createAdvancedRobot() {
                // Ú¯Ø±ÙˆÙ‡ Ø§ØµÙ„ÛŒ Ø±Ø¨Ø§Øª
                this.robot = new BABYLON.TransformNode("robot", this.scene);
                this.robot.position = new BABYLON.Vector3(0, 1.5, 0);
                
                // Ø¨Ø¯Ù†Ù‡ Ø§ØµÙ„ÛŒ Ø±Ø¨Ø§Øª
                this.createRobotBody();
                this.createRobotHead();
                this.createRobotArms();
                this.createRobotLegs();
                this.createWeaponSystem();
                
                // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ø¨Ø§Øª
                this.robotData = {
                    health: 100,
                    shield: 100,
                    speed: 0.1,
                    runSpeed: 0.2,
                    coins: 0,
                    score: 0,
                    kills: 0,
                    currentWeapon: 'plasma',
                    ammo: 100
                };
            }
            
            createRobotBody() {
                // Ø¨Ø¯Ù†Ù‡ Ø§ØµÙ„ÛŒ
                const body = BABYLON.MeshBuilder.CreateCylinder("body", {
                    diameterTop: 1.2,
                    diameterBottom: 1.5,
                    height: 2,
                    tessellation: 16
                }, this.scene);
                body.parent = this.robot;
                body.position.y = 0;
                
                const bodyMat = new BABYLON.PBRMetallicRoughnessMaterial("bodyMat", this.scene);
                bodyMat.baseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
                bodyMat.metallic = 0.8;
                bodyMat.roughness = 0.2;
                body.material = bodyMat;
                
                this.shadowGenerator.addShadowCaster(body);
            }
            
            createRobotHead() {
                // Ø³Ø± Ø±Ø¨Ø§Øª
                const head = BABYLON.MeshBuilder.CreateSphere("head", {
                    diameter: 1.2,
                    segments: 16
                }, this.scene);
                head.parent = this.robot;
                head.position.y = 1.8;
                
                const headMat = new BABYLON.PBRMetallicRoughnessMaterial("headMat", this.scene);
                headMat.baseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
                headMat.metallic = 0.9;
                headMat.roughness = 0.1;
                head.material = headMat;
                
                // Ú†Ø´Ù…â€ŒÙ‡Ø§
                const leftEye = BABYLON.MeshBuilder.CreateSphere("leftEye", {
                    diameter: 0.2,
                    segments: 8
                }, this.scene);
                leftEye.parent = head;
                leftEye.position.set(-0.3, 0.2, 0.5);
                
                const rightEye = leftEye.clone("rightEye");
                rightEye.position.set(0.3, 0.2, 0.5);
                
                const eyeMat = new BABYLON.StandardMaterial("eyeMat", this.scene);
                eyeMat.emissiveColor = new BABYLON.Color3(0, 1, 1);
                eyeMat.specularColor = new BABYLON.Color3(1, 1, 1);
                leftEye.material = eyeMat;
                rightEye.material = eyeMat;
                
                this.shadowGenerator.addShadowCaster(head);
            }
            
            createRobotArms() {
                // Ø¨Ø§Ø²ÙˆÛŒ Ú†Ù¾
                const leftArm = BABYLON.MeshBuilder.CreateCylinder("leftArm", {
                    diameter: 0.4,
                    height: 1.5,
                    tessellation: 8
                }, this.scene);
                leftArm.parent = this.robot;
                leftArm.position.set(-1.2, 0.8, 0);
                leftArm.rotation.z = Math.PI / 6;
                
                // Ø¨Ø§Ø²ÙˆÛŒ Ø±Ø§Ø³Øª
                const rightArm = leftArm.clone("rightArm");
                rightArm.position.set(1.2, 0.8, 0);
                rightArm.rotation.z = -Math.PI / 6;
            }
            
            createRobotLegs() {
                // Ù¾Ø§ÛŒ Ú†Ù¾
                const leftLeg = BABYLON.MeshBuilder.CreateCylinder("leftLeg", {
                    diameter: 0.5,
                    height: 2,
                    tessellation: 8
                }, this.scene);
                leftLeg.parent = this.robot;
                leftLeg.position.set(-0.4, -1.5, 0);
                
                // Ù¾Ø§ÛŒ Ø±Ø§Ø³Øª
                const rightLeg = leftLeg.clone("rightLeg");
                rightLeg.position.set(0.4, -1.5, 0);
            }
            
            createWeaponSystem() {
                // Ø³Ù„Ø§Ø­ Ø§ØµÙ„ÛŒ
                this.weapon = BABYLON.MeshBuilder.CreateCylinder("weapon", {
                    diameterTop: 0.1,
                    diameterBottom: 0.3,
                    height: 2,
                    tessellation: 8
                }, this.scene);
                this.weapon.parent = this.robot;
                this.weapon.position.set(1.3, 0.8, 0);
                this.weapon.rotation.z = -Math.PI / 2;
                
                const weaponMat = new BABYLON.PBRMetallicRoughnessMaterial("weaponMat", this.scene);
                weaponMat.baseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                weaponMat.metallic = 0.7;
                weaponMat.roughness = 0.3;
                this.weapon.material = weaponMat;
            }
            
            createEnvironment() {
                // Ø²Ù…ÛŒÙ† Ø¨Ø§Ø²ÛŒ
                const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                    width: 100,
                    height: 100
                }, this.scene);
                
                const groundMat = new BABYLON.PBRMetallicRoughnessMaterial("groundMat", this.scene);
                groundMat.baseColor = new BABYLON.Color3(0.2, 0.3, 0.1);
                groundMat.metallic = 0.0;
                groundMat.roughness = 0.8;
                ground.material = groundMat;
                
                this.shadowGenerator.addShadowCaster(ground);
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù…ÙˆØ§Ù†Ø¹ Ùˆ Ø³Ø§Ø®ØªÙ…Ø§Ù†â€ŒÙ‡Ø§
                this.createObstacles();
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§
                this.createCoins();
                // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù†Ø§Ù†
                this.createEnemies();
            }
            
            createObstacles() {
                this.obstacles = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ú†Ù†Ø¯ÛŒÙ† Ù…Ø§Ù†Ø¹
                const obstaclePositions = [
                    new BABYLON.Vector3(10, 1, 10),
                    new BABYLON.Vector3(-8, 1, 12),
                    new BABYLON.Vector3(15, 1, -5),
                    new BABYLON.Vector3(-12, 1, -8)
                ];
                
                obstaclePositions.forEach((pos, index) => {
                    const obstacle = BABYLON.MeshBuilder.CreateBox("obstacle" + index, {
                        width: 3,
                        height: 2,
                        depth: 3
                    }, this.scene);
                    obstacle.position = pos;
                    
                    const obstacleMat = new BABYLON.StandardMaterial("obstacleMat" + index, this.scene);
                    obstacleMat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                    obstacle.material = obstacleMat;
                    
                    this.obstacles.push(obstacle);
                    this.shadowGenerator.addShadowCaster(obstacle);
                });
            }
            
            createCoins() {
                this.coins = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø·Ù„Ø§ÛŒÛŒ
                for (let i = 0; i < 10; i++) {
                    const coin = BABYLON.MeshBuilder.CreateCylinder("coin" + i, {
                        diameter: 1,
                        height: 0.2,
                        tessellation: 16
                    }, this.scene);
                    
                    coin.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 40,
                        1,
                        (Math.random() - 0.5) * 40
                    );
                    
                    const coinMat = new BABYLON.PBRMetallicRoughnessMaterial("coinMat" + i, this.scene);
                    coinMat.baseColor = new BABYLON.Color3(1, 0.8, 0);
                    coinMat.metallic = 1.0;
                    coinMat.roughness = 0.1;
                    coin.material = coinMat;
                    
                    // Ù†ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø³Ú©Ù‡
                    const coinLight = new BABYLON.PointLight("coinLight" + i, coin.position, this.scene);
                    coinLight.diffuse = new BABYLON.Color3(1, 0.8, 0);
                    coinLight.intensity = 0.5;
                    coinLight.parent = coin;
                    
                    this.coins.push({
                        mesh: coin,
                        light: coinLight,
                        collected: false
                    });
                }
            }
            
            createEnemies() {
                this.enemies = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù†Ø§Ù† Ù…Ø®ØªÙ„Ù
                for (let i = 0; i < 5; i++) {
                    const enemy = BABYLON.MeshBuilder.CreateCylinder("enemy" + i, {
                        diameterTop: 0.8,
                        diameterBottom: 1,
                        height: 2,
                        tessellation: 12
                    }, this.scene);
                    
                    enemy.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 30,
                        1,
                        (Math.random() - 0.5) * 30
                    );
                    
                    const enemyMat = new BABYLON.PBRMetallicRoughnessMaterial("enemyMat" + i, this.scene);
                    enemyMat.baseColor = new BABYLON.Color3(1, 0.2, 0.2);
                    enemyMat.metallic = 0.6;
                    enemyMat.roughness = 0.3;
                    enemy.material = enemyMat;
                    
                    // Ù†ÙˆØ± Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ Ø¯Ø´Ù…Ù†
                    const enemyLight = new BABYLON.PointLight("enemyLight" + i, enemy.position, this.scene);
                    enemyLight.diffuse = new BABYLON.Color3(1, 0, 0);
                    enemyLight.intensity = 0.3;
                    enemyLight.parent = enemy;
                    
                    this.enemies.push({
                        mesh: enemy,
                        light: enemyLight,
                        health: 50,
                        speed: 0.03,
                        lastShot: 0
                    });
                    
                    this.shadowGenerator.addShadowCaster(enemy);
                }
            }
            
            setupGameSystems() {
                this.keys = {};
                this.bullets = [];
                this.gameTime = 0;
                this.isRunning = false;
            }
            
            setupAdvancedControls() {
                // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ú©ÛŒØ¨ÙˆØ±Ø¯
                this.scene.onKeyboardObservable.add((kbInfo) => {
                    this.keys[kbInfo.event.key.toLowerCase()] = 
                        kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;
                    
                    if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
                        this.handleSpecialKeys(kbInfo.event.key);
                    }
                });
                
                // Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ù…Ø§ÙˆØ³
                this.scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                        if (pointerInfo.event.button === 0) { // Ú©Ù„ÛŒÚ© Ú†Ù¾
                            this.shoot();
                        }
                    }
                });
            }
            
            handleSpecialKeys(key) {
                switch(key.toLowerCase()) {
                    case ' ':
                        this.switchWeapon();
                        break;
                    case 'e':
                        this.collectCoins();
                        break;
                    case 'shift':
                        this.isRunning = true;
                        break;
                }
            }
            
            updateGame(deltaTime) {
                this.gameTime += deltaTime;
                
                this.updateRobotMovement(deltaTime);
                this.updateCameraFollow();
                this.updateEnemies(deltaTime);
                this.updateCoins(deltaTime);
                this.updateBullets(deltaTime);
                this.checkCollisions();
                this.updateHUD();
            }
            
            updateRobotMovement(deltaTime) {
                let moveX = 0, moveZ = 0;
                
                // Ø­Ø±Ú©Øª Ø¨Ø§ WASD
                if (this.keys['w'] || this.keys['arrowup']) moveZ -= 1;
                if (this.keys['s'] || this.keys['arrowdown']) moveZ += 1;
                if (this.keys['a'] || this.keys['arrowleft']) moveX -= 1;
                if (this.keys['d'] || this.keys['arrowright']) moveX += 1;
                
                // Ø§Ø¹Ù…Ø§Ù„ Ø³Ø±Ø¹Øª
                const speed = this.isRunning ? this.robotData.runSpeed : this.robotData.speed;
                this.robot.position.x += moveX * speed * 60 * deltaTime;
                this.robot.position.z += moveZ * speed * 60 * deltaTime;
                
                // Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø­Ø±Ú©Øª
                const bounds = 45;
                this.robot.position.x = Math.max(-bounds, Math.min(bounds, this.robot.position.x));
                this.robot.position.z = Math.max(-bounds, Math.min(bounds, this.robot.position.z));
                
                // Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø­Ø±Ú©Øª
                if (moveX !== 0 || moveZ !== 0) {
                    this.robot.rotation.y = Math.atan2(moveX, moveZ);
                }
                
                // Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ø¯ÙˆÛŒØ¯Ù†
                if (!this.keys['shift']) {
                    this.isRunning = false;
                }
            }
            
            updateCameraFollow() {
                // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¯Ù†Ø¨Ø§Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø±Ø¨Ø§Øª
                const targetPosition = this.robot.position.clone();
                targetPosition.y += 8;
                targetPosition.z += 10;
                
                this.camera.position = BABYLON.Vector3.Lerp(
                    this.camera.position,
                    targetPosition,
                    0.1
                );
                
                this.camera.setTarget(this.robot.position);
            }
            
            updateEnemies(deltaTime) {
                this.enemies.forEach((enemy, index) => {
                    if (!enemy.mesh) return;
                    
                    // Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³Ù…Øª Ø±Ø¨Ø§Øª
                    const direction = this.robot.position.subtract(enemy.mesh.position);
                    direction.normalize();
                    direction.scaleInPlace(enemy.speed * 60 * deltaTime);
                    
                    enemy.mesh.position.addInPlace(direction);
                    enemy.mesh.lookAt(this.robot.position);
                    
                    // Ø´Ù„ÛŒÚ© Ø¯Ø´Ù…Ù†
                    const now = Date.now();
                    if (now - enemy.lastShot > 2000) { // Ù‡Ø± 2 Ø«Ø§Ù†ÛŒÙ‡
                        this.enemyShoot(enemy);
                        enemy.lastShot = now;
                    }
                });
            }
            
            updateCoins(deltaTime) {
                this.coins.forEach(coin => {
                    if (!coin.collected) {
                        // Ú†Ø±Ø®Ø´ Ø³Ú©Ù‡
                        coin.mesh.rotation.y += 2 * deltaTime;
                        coin.mesh.position.y = 1 + Math.sin(this.gameTime * 2) * 0.2;
                    }
                });
            }
            
            shoot() {
                if (this.robotData.ammo <= 0) return;
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±ØªØ§Ø¨Ù‡
                const bullet = BABYLON.MeshBuilder.CreateSphere("bullet", {
                    diameter: 0.2,
                    segments: 8
                }, this.scene);
                
                const startPos = this.robot.position.clone();
                startPos.y += 1;
                bullet.position = startPos;
                
                const direction = new BABYLON.Vector3(0, 0, -1);
                direction.applyRotationQuaternion(this.robot.rotationQuaternion);
                
                const bulletMat = new BABYLON.StandardMaterial("bulletMat", this.scene);
                bulletMat.emissiveColor = new BABYLON.Color3(0, 1, 1);
                bullet.material = bulletMat;
                
                this.bullets.push({
                    mesh: bullet,
                    velocity: direction.scale(0.5),
                    damage: 10,
                    lifetime: 3000,
                    born: Date.now()
                });
                
                this.robotData.ammo -= 1;
            }
            
            enemyShoot(enemy) {
                const bullet = BABYLON.MeshBuilder.CreateSphere("enemyBullet", {
                    diameter: 0.3,
                    segments: 8
                }, this.scene);
                
                bullet.position = enemy.mesh.position.clone();
                
                const direction = this.robot.position.subtract(enemy.mesh.position);
                direction.normalize();
                
                const bulletMat = new BABYLON.StandardMaterial("enemyBulletMat", this.scene);
                bulletMat.emissiveColor = new BABYLON.Color3(1, 0, 0);
                bullet.material = bulletMat;
                
                this.bullets.push({
                    mesh: bullet,
                    velocity: direction.scale(0.3),
                    damage: 5,
                    lifetime: 4000,
                    born: Date.now(),
                    isEnemy: true
                });
            }
            
            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    bullet.mesh.position.addInPlace(
                        bullet.velocity.scale(60 * deltaTime)
                    );
                    
                    if (Date.now() - bullet.born > bullet.lifetime) {
                        bullet.mesh.dispose();
                        this.bullets.splice(i, 1);
                    }
                }
            }
            
            checkCollisions() {
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§
                this.bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.isEnemy) {
                        // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø±Ø¨Ø§Øª
                        if (bullet.mesh.intersectsMesh(this.robot, false)) {
                            this.robotData.health -= bullet.damage;
                            bullet.mesh.dispose();
                            this.bullets.splice(bulletIndex, 1);
                            this.createHitEffect(bullet.mesh.position);
                        }
                    } else {
                        // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¯Ø´Ù…Ù†Ø§Ù†
                        this.enemies.forEach((enemy, enemyIndex) => {
                            if (bullet.mesh.intersectsMesh(enemy.mesh, false)) {
                                enemy.health -= bullet.damage;
                                bullet.mesh.dispose();
                                this.bullets.splice(bulletIndex, 1);
                                this.createHitEffect(bullet.mesh.position);
                                
                                if (enemy.health <= 0) {
                                    this.destroyEnemy(enemy, enemyIndex);
                                }
                            }
                        });
                    }
                });
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡
                this.coins.forEach((coin, index) => {
                    if (!coin.collected && this.robot.intersectsMesh(coin.mesh, false)) {
                        this.collectCoin(coin, index);
                    }
                });
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ
                if (this.robotData.health <= 0) {
                    this.gameOver();
                }
            }
            
            collectCoin(coin, index) {
                coin.collected = true;
                this.robotData.coins += 1;
                this.robotData.score += 100;
                
                // Ø§ÙÚ©Øª Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ
                this.createCollectionEffect(coin.mesh.position);
                
                // Ø­Ø°Ù Ø³Ú©Ù‡
                coin.mesh.dispose();
                coin.light.dispose();
                this.coins.splice(index, 1);
            }
            
            collectCoins() {
                // Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø·Ø±Ø§Ù
                this.coins.forEach((coin, index) => {
                    const distance = BABYLON.Vector3.Distance(
                        this.robot.position,
                        coin.mesh.position
                    );
                    
                    if (distance < 5 && !coin.collected) {
                        this.collectCoin(coin, index);
                    }
                });
            }
            
            destroyEnemy(enemy, index) {
                this.robotData.kills += 1;
                this.robotData.score += 200;
                
                // Ø§ÙÚ©Øª Ø§Ù†ÙØ¬Ø§Ø±
                this.createExplosionEffect(enemy.mesh.position);
                
                // Ø­Ø°Ù Ø¯Ø´Ù…Ù†
                enemy.mesh.dispose();
                enemy.light.dispose();
                this.enemies.splice(index, 1);
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡ Ø¬Ø¯ÛŒØ¯
                setTimeout(() => {
                    this.createCoins();
                }, 1000);
            }
            
            createHitEffect(position) {
                // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙÚ©Øª Ø¨Ø±Ø®ÙˆØ±Ø¯
                const hitParticles = new BABYLON.ParticleSystem("hitParticles", 20, this.scene);
                hitParticles.particleTexture = new BABYLON.Texture("https://www.babylonjs.com/assets/Flare.png", this.scene);
                
                hitParticles.emitter = position;
                hitParticles.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                hitParticles.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                
                hitParticles.color1 = new BABYLON.Color4(1, 1, 0, 1);
                hitParticles.color2 = new BABYLON.Color4(1, 0.5, 0, 1);
                hitParticles.minSize = 0.1;
                hitParticles.maxSize = 0.3;
                hitParticles.minLifeTime = 0.2;
                hitParticles.maxLifeTime = 0.5;
                hitParticles.emitRate = 100;
                
                hitParticles.start();
                setTimeout(() => {
                    hitParticles.stop();
                    hitParticles.dispose();
                }, 200);
            }
            
            createCollectionEffect(position) {
                // Ø§ÙÚ©Øª Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡
                const ring = BABYLON.MeshBuilder.CreateTorus("collectionRing", {
                    diameter: 2,
                    thickness: 0.1,
                    tessellation: 16
                }, this.scene);
                
                ring.position = position.clone();
                ring.rotation.x = Math.PI / 2;
                
                const ringMat = new BABYLON.StandardMaterial("ringMat", this.scene);
                ringMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
                ringMat.alpha = 0.8;
                ring.material = ringMat;
                
                // Ø§Ù†ÛŒÙ…ÛŒØ´Ù†
                setTimeout(() => {
                    ring.dispose();
                }, 500);
            }
            
            createExplosionEffect(position) {
                // Ø§ÙÚ©Øª Ø§Ù†ÙØ¬Ø§Ø± Ù¾ÛŒØ´Ø±ÙØªÙ‡
                const explosionLight = new BABYLON.PointLight("explosionLight", position, this.scene);
                explosionLight.diffuse = new BABYLON.Color3(1, 0.5, 0);
                explosionLight.intensity = 5;
                explosionLight.radius = 10;
                
                // Ù…Ø­Ùˆ Ø´Ø¯Ù† Ù†ÙˆØ±
                let intensity = 5;
                const lightInterval = setInterval(() => {
                    intensity *= 0.7;
                    explosionLight.intensity = intensity;
                    
                    if (intensity < 0.1) {
                        clearInterval(lightInterval);
                        explosionLight.dispose();
                    }
                }, 50);
            }
            
            switchWeapon() {
                // ØªØ¹ÙˆÛŒØ¶ Ø³Ù„Ø§Ø­
                const weapons = ['Ù¾Ù„Ø§Ø³Ù…Ø§', 'Ù„ÛŒØ²Ø±', 'Ø±Ø§Ú©Øª'];
                const currentIndex = weapons.indexOf(this.robotData.currentWeapon);
                const nextIndex = (currentIndex + 1) % weapons.length;
                
                this.robotData.currentWeapon = weapons[nextIndex];
                this.robotData.ammo = 100;
            }
            
            gameOver() {
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = this.robotData.score;
                document.getElementById('finalCoins').textContent = this.robotData.coins;
                document.getElementById('finalKills').textContent = this.robotData.kills;
            }
            
            updateHUD() {
                document.getElementById('healthValue').textContent = Math.max(0, this.robotData.health);
                document.getElementById('healthFill').style.width = this.robotData.health + '%';
                
                document.getElementById('shieldValue').textContent = Math.max(0, this.robotData.shield);
                document.getElementById('shieldFill').style.width = this.robotData.shield + '%';
                
                document.getElementById('ammoFill').style.width = this.robotData.ammo + '%';
                
                document.getElementById('scoreValue').textContent = this.robotData.score;
                document.getElementById('coinsValue').textContent = this.robotData.coins;
                document.getElementById('enemiesValue').textContent = this.enemies.length;
                
                document.getElementById('weaponValue').textContent = this.robotData.currentWeapon;
            }
            
            startGameLoop() {
                this.engine.runRenderLoop(() => {
                    const deltaTime = this.engine.getDeltaTime() / 1000;
                    this.updateGame(deltaTime);
                    this.scene.render();
                });
                
                window.addEventListener("resize", () => {
                    this.engine.resize();
                });
            }
        }
        
        // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Ø²ÛŒ
        window.addEventListener('load', () => {
            new WarBotGame();
            console.log('ğŸ® Ø¨Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª Ø¬Ù†Ú¯ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!');
        });
    </script>
</body>
  </html>
