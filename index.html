<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨Ø§Ø²ÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ Ø­Ø±ÙÙ‡â€ŒØ§ÛŒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #uiContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 25px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            box-shadow: 0 0 40px rgba(0, 200, 255, 0.4);
            pointer-events: all;
        }
        
        #topPanel {
            top: 25px;
            left: 25px;
            right: 25px;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 18px 25px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 15px;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ccff;
            text-shadow: 0 0 12px #00ccff;
        }
        
        #fuelBar {
            width: 140px;
            height: 18px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 9px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        #fuelFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 9px;
            transition: width 0.3s;
            box-shadow: 0 0 12px #00ff88;
        }
        
        #centerPanel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s;
            pointer-events: all;
            min-width: 320px;
        }
        
        #gameTitle {
            font-size: 3rem;
            color: #00ccff;
            text-shadow: 0 0 25px #00ccff;
            margin-bottom: 30px;
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 25px #00ccff; }
            to { text-shadow: 0 0 35px #00ccff, 0 0 50px #0066ff; }
        }
        
        .menu-btn {
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border: none;
            padding: 16px 32px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0, 204, 255, 0.6);
            transition: all 0.3s;
            margin: 12px;
            width: 240px;
            position: relative;
            overflow: hidden;
        }
        
        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .menu-btn:hover::before {
            left: 100%;
        }
        
        .menu-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 7px 25px rgba(0, 204, 255, 0.8);
        }
        
        .menu-btn:active {
            transform: scale(0.98);
        }
        
        .menu-btn.start {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.6);
            font-size: 1.5rem;
            padding: 20px 32px;
        }
        
        .menu-btn.management {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.6);
            animation: redPulse 2s infinite;
        }
        
        @keyframes redPulse {
            0%, 100% { box-shadow: 0 5px 20px rgba(255, 68, 68, 0.6); }
            50% { box-shadow: 0 5px 30px rgba(255, 68, 68, 0.9), 0 0 40px rgba(255, 68, 68, 0.5); }
        }
        
        #gameControls {
            position: fixed;
            bottom: 25px;
            left: 25px;
            right: 25px;
            display: none;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }
        
        #joystickContainer {
            width: 130px;
            height: 130px;
            pointer-events: none;
        }
        
        #joystickBase {
            position: absolute;
            width: 110px;
            height: 110px;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.25);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(12px);
            box-shadow: 0 0 25px rgba(0, 200, 255, 0.4);
        }
        
        #joystickHandle {
            position: absolute;
            width: 55px;
            height: 55px;
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border-radius: 50%;
            box-shadow: 0 0 18px rgba(0, 204, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }
        
        #bombButton {
            width: 75px;
            height: 75px;
            background: radial-gradient(circle, #ff4444, #cc0000);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(255, 0, 0, 0.6);
            transition: all 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: all;
            position: relative;
            overflow: hidden;
        }
        
        #bombButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        #bombButton:hover::before {
            left: 100%;
        }
        
        #bombButton:hover {
            transform: scale(1.1);
            box-shadow: 0 7px 25px rgba(255, 0, 0, 0.8);
        }
        
        #bombButton:active {
            transform: scale(0.95);
        }
        
        #bombButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.92);
            color: white;
            padding: 25px 35px;
            border-radius: 18px;
            border: 2px solid #00ccff;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 40px rgba(0, 200, 255, 0.5);
        }
        
        .notification.show {
            opacity: 1;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.96);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            padding: 25px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .modal.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
            background: rgba(0, 0, 0, 0.92);
            padding: 35px;
            border-radius: 25px;
            max-width: 550px;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.1);
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.3);
        }
        
        .modal h2 {
            font-size: 2.2rem;
            margin-bottom: 25px;
            color: #00ccff;
            text-shadow: 0 0 15px #00ccff;
        }
        
        .modal-close {
            margin-top: 25px;
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border: none;
            padding: 14px 28px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.5);
            transition: all 0.3s;
        }
        
        .modal-close:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.7);
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: white;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 6px solid rgba(255, 255, 255, 0.1);
            border-top: 6px solid #00ccff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 25px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.3rem;
            color: #00ccff;
            text-shadow: 0 0 10px #00ccff;
        }
        
        @media (max-width: 768px) {
            #gameControls {
                display: flex;
            }
            
            #gameTitle {
                font-size: 2.3rem;
            }
            
            .menu-btn {
                padding: 14px 28px;
                font-size: 1.1rem;
                width: 220px;
            }
            
            .menu-btn.start {
                font-size: 1.3rem;
                padding: 16px 28px;
            }
            
            .stat-value {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="uiContainer">
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨Ø§Ø²ÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ...</div>
        </div>
        
        <div id="topPanel" class="ui-panel">
            <div class="stat-item">
                <div class="stat-label">Ø§Ù…ØªÛŒØ§Ø²</div>
                <div class="stat-value" id="scoreValue">0</div>
            </div>
            
            <div class="stat-item">
                <div class="stat-label">Ø³ÙˆØ®Øª</div>
                <div class="stat-value" id="fuelValue">100%</div>
                <div id="fuelBar">
                    <div id="fuelFill" style="width: 100%;"></div>
                </div>
            </div>
            
            <div class="stat-item">
                <div class="stat-label">Ù…Ø±Ø­Ù„Ù‡</div>
                <div class="stat-value" id="levelValue">1</div>
            </div>
        </div>
        
        <div id="centerPanel" class="ui-panel">
            <h1 id="gameTitle">ğŸš€ Ø¨Ø§Ø²ÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ</h1>
            <button class="menu-btn start" id="startBtn">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</button>
            <button class="menu-btn" id="instructionsBtn">ğŸ“– Ø±Ø§Ù‡Ù†Ù…Ø§</button>
            <button class="menu-btn management" id="managementBtn">ğŸ”” Ø§Ø·Ù„Ø§Ø¹ÛŒÙ‡ Ù…Ø¯ÛŒØ±ÛŒØª</button>
        </div>
        
        <div id="gameControls">
            <div id="joystickContainer">
                <div id="joystickBase"></div>
                <div id="joystickHandle"></div>
            </div>
            
            <button id="bombButton">ğŸ’£</button>
        </div>
        
        <div id="notification" class="notification">
            <div id="notificationText"></div>
        </div>
        
        <!-- Ù…ÙˆØ¯Ø§Ù„ Ø±Ø§Ù‡Ù†Ù…Ø§ -->
        <div id="instructionsModal" class="modal">
            <div class="modal-content">
                <h2>ğŸ“– Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ</h2>
                <div style="text-align: right; line-height: 1.8; margin: 20px 0;">
                    <p>ğŸ¯ <strong>Ù‡Ø¯Ù Ø¨Ø§Ø²ÛŒ:</strong> Ù†Ø§Ø¨ÙˆØ¯ÛŒ Ø¯Ø´Ù…Ù†Ø§Ù† Ùˆ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø§Ù…ØªÛŒØ§Ø²</p>
                    <p>ğŸ›¸ <strong>Ú©Ù†ØªØ±Ù„ Ø³ÙÛŒÙ†Ù‡:</strong> Ø¨Ø§ Ø¬ÙˆÛŒØ³ØªÛŒÚ© Ø³Ù…Øª Ø±Ø§Ø³Øª Ø­Ø±Ú©Øª Ú©Ù†ÛŒØ¯</p>
                    <p>ğŸ’£ <strong>Ø¨Ù…Ø¨:</strong> Ø¨Ø§ Ø¯Ú©Ù…Ù‡ Ø³Ù…Øª Ú†Ù¾ ØªÙ…Ø§Ù… Ø¯Ø´Ù…Ù†Ø§Ù† Ø±Ø§ Ù†Ø§Ø¨ÙˆØ¯ Ú©Ù†ÛŒØ¯</p>
                    <p>ğŸŒ‹ <strong>Ø¯Ø´Ù…Ù†Ø§Ù†:</strong> Ø§Ø² Ù¾Ø§ÛŒÛŒÙ† ØµÙØ­Ù‡ Ø¸Ø§Ù‡Ø± Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯</p>
                    <p>â›½ <strong>Ø³ÙˆØ®Øª:</strong> Ø¨Ø§ Ø²Ù…Ø§Ù† Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯</p>
                </div>
                <button class="modal-close" id="closeInstructions">Ø¨Ø³ØªÙ† Ø±Ø§Ù‡Ù†Ù…Ø§</button>
            </div>
        </div>
        
        <!-- Ù…ÙˆØ¯Ø§Ù„ Ø§Ø·Ù„Ø§Ø¹ÛŒÙ‡ Ù…Ø¯ÛŒØ±ÛŒØª -->
        <div id="managementModal" class="modal">
            <div class="modal-content">
                <h2>ğŸ”” Ø§Ø·Ù„Ø§Ø¹ÛŒÙ‡ Ù…Ø¯ÛŒØ±ÛŒØª</h2>
                <div style="text-align: right; line-height: 1.8; margin: 20px 0; padding: 20px; background: rgba(255, 68, 68, 0.1); border-radius: 10px; border: 1px solid rgba(255, 68, 68, 0.3);">
                    <p>ğŸ® <strong>Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!</strong></p>
                    <p>âœ¨ Ø¨Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„Ø§Ù‹ Ø¨Ù‡ÛŒÙ†Ù‡ Ø´Ø¯Ù‡ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø±Ø§Ø¦Ù‡ ØªØ¬Ø±Ø¨Ù‡â€ŒØ§ÛŒ ÙÙˆÙ‚â€ŒØ§Ù„Ø¹Ø§Ø¯Ù‡ Ø§Ø³Øª.</p>
                    <p>ğŸš€ <strong>ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ ÙÙ†ÛŒ Ø³ÛŒØ³ØªÙ…:</strong></p>
                    <p>â€¢ Ù…ÙˆØªÙˆØ± Ú¯Ø±Ø§ÙÛŒÚ©ÛŒ Babylon.js Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø³Ø®Øªâ€ŒØ§ÙØ²Ø§Ø±ÛŒ<br>
                       â€¢ Ø±Ù†Ø¯Ø± Ø³Ù‡ Ø¨Ø¹Ø¯ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ<br>
                       â€¢ Ø³ÛŒØ³ØªÙ… ÙÛŒØ²ÛŒÚ©ÛŒ Ø¯Ù‚ÛŒÙ‚<br>
                       â€¢ Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§ÙØ¸Ù‡ Ù¾ÛŒØ´Ø±ÙØªÙ‡</p>
                    <p>â­ Ø§Ø² Ø¨Ø§Ø²ÛŒ Ù„Ø°Øª Ø¨Ø¨Ø±ÛŒØ¯ Ùˆ Ø¨Ù‡ Ú©Ù‡Ú©Ø´Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ø¯ÙˆØ± Ø³ÙØ± Ú©Ù†ÛŒØ¯!</p>
                </div>
                <button class="modal-close" id="closeManagement">Ø¨Ø³ØªÙ† Ø§Ø·Ù„Ø§Ø¹ÛŒÙ‡</button>
            </div>
        </div>
    </div>

    <!-- Babylon.js Libraries -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    
    <script>
        // Ø³ÛŒØ³ØªÙ… Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ - Ù†Ø³Ø®Ù‡ Ø³Ø§Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§
        console.log("ğŸš€ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨Ø§Ø²ÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ...");

        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
        let canvas, engine, scene, camera;
        let playerShip, enemyShips = [], bullets = [];
        let gameState = {
            score: 0,
            fuel: 100,
            level: 1,
            gameRunning: false,
            paused: false
        };

        // Ø³ÛŒØ³ØªÙ… Ú©Ù†ØªØ±Ù„ Ù„Ù…Ø³ÛŒ
        class TouchControlSystem {
            constructor() {
                this.isActive = false;
                this.joystickPosition = { x: 0, y: 0 };
                this.basePosition = { x: 0, y: 0 };
                this.init();
            }

            init() {
                const joystickContainer = document.getElementById('joystickContainer');
                const joystickHandle = document.getElementById('joystickHandle');
                
                if (!joystickContainer || !joystickHandle) return;

                const updateBasePosition = () => {
                    const rect = joystickContainer.getBoundingClientRect();
                    this.basePosition.x = rect.left + rect.width / 2;
                    this.basePosition.y = rect.top + rect.height / 2;
                };

                const handleTouchStart = (e) => {
                    e.preventDefault();
                    this.isActive = true;
                    updateBasePosition();
                };

                const handleTouchMove = (e) => {
                    e.preventDefault();
                    if (!this.isActive) return;

                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.basePosition.x;
                    const deltaY = touch.clientY - this.basePosition.y;

                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = 35;

                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        this.joystickPosition.x = Math.cos(angle);
                        this.joystickPosition.y = Math.sin(angle);
                        joystickHandle.style.transform = `translate(${Math.cos(angle) * maxDistance}px, ${Math.sin(angle) * maxDistance}px)`;
                    } else {
                        this.joystickPosition.x = deltaX / maxDistance;
                        this.joystickPosition.y = deltaY / maxDistance;
                        joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    }
                };

                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    this.isActive = false;
                    this.joystickPosition.x = 0;
                    this.joystickPosition.y = 0;
                    joystickHandle.style.transform = 'translate(0, 0)';
                };

                joystickContainer.addEventListener('touchstart', handleTouchStart);
                document.addEventListener('touchmove', handleTouchMove);
                document.addEventListener('touchend', handleTouchEnd);
                document.addEventListener('touchcancel', handleTouchEnd);
                window.addEventListener('resize', updateBasePosition);
            }

            getMovement() {
                return {
                    x: this.joystickPosition.x * 0.4,
                    y: this.joystickPosition.y * 0.4
                };
            }
        }

        // Ø³ÛŒØ³ØªÙ… Ø¨Ø§Ø²ÛŒ Ø§ØµÙ„ÛŒ
        class GameSystem {
            constructor() {
                this.touchControls = new TouchControlSystem();
                this.gameTimers = [];
                this.init();
            }

            async init() {
                try {
                    // Ø§ÛŒØ¬Ø§Ø¯ Ù…ÙˆØªÙˆØ± Ùˆ ØµØ­Ù†Ù‡
                    canvas = document.getElementById('renderCanvas');
                    engine = new BABYLON.Engine(canvas, true);
                    scene = new BABYLON.Scene(engine);
                    scene.clearColor = new BABYLON.Color4(0, 0, 0.1, 1);

                    // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ùˆ Ù†ÙˆØ±
                    this.setupCamera();
                    this.setupLighting();
                    
                    // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ÛŒØ· Ø¨Ø§Ø²ÛŒ
                    this.createGameEnvironment();

                    // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ
                    this.setupUI();

                    // Ø´Ø±ÙˆØ¹ Ø­Ù„Ù‚Ù‡ Ø±Ù†Ø¯Ø±
                    engine.runRenderLoop(() => {
                        if (gameState.gameRunning && !gameState.paused) {
                            this.update();
                        }
                        scene.render();
                    });

                    // Ù…Ø¯ÛŒØ±ÛŒØª ØªØºÛŒÛŒØ± Ø§Ù†Ø¯Ø§Ø²Ù‡
                    window.addEventListener('resize', () => {
                        engine.resize();
                    });

                    console.log("âœ… Ø¨Ø§Ø²ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯");
                    
                    // Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØµÙØ­Ù‡ Ù„ÙˆØ¯ÛŒÙ†Ú¯
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                    }, 1000);

                } catch (error) {
                    console.error("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Ø²ÛŒ:", error);
                    this.showError("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨Ø§Ø²ÛŒ");
                }
            }

            setupCamera() {
                camera = new BABYLON.ArcRotateCamera(
                    "camera",
                    -Math.PI / 2,
                    Math.PI / 2.2,
                    45,
                    new BABYLON.Vector3(0, 25, 0),
                    scene
                );
                camera.lowerBetaLimit = Math.PI / 3;
                camera.upperBetaLimit = Math.PI / 2;
                camera.lowerRadiusLimit = 30;
                camera.upperRadiusLimit = 80;
                camera.attachControl(canvas, true);
            }

            setupLighting() {
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.7;
            }

            createGameEnvironment() {
                // Ø²Ù…ÛŒÙ† Ø¨Ø§Ø²ÛŒ
                const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 80, height: 50 }, scene);
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                ground.material = groundMaterial;

                // Ø¯ÛŒÙˆØ§Ø±Ù‡Ø§
                this.createWalls();
                
                // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø³ØªØ§Ø±Ù‡â€ŒØ§ÛŒ
                this.createStarfield();
            }

            createWalls() {
                const wallMaterial = new BABYLON.StandardMaterial("wallMat", scene);
                wallMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);

                // Ø¯ÛŒÙˆØ§Ø± Ø´Ù…Ø§Ù„ÛŒ
                const northWall = BABYLON.MeshBuilder.CreateBox("northWall", { width: 80, height: 8, depth: 2 }, scene);
                northWall.position.z = -25;
                northWall.position.y = 4;
                northWall.material = wallMaterial;

                // Ø¯ÛŒÙˆØ§Ø± Ø¬Ù†ÙˆØ¨ÛŒ
                const southWall = BABYLON.MeshBuilder.CreateBox("southWall", { width: 80, height: 8, depth: 2 }, scene);
                southWall.position.z = 25;
                southWall.position.y = 4;
                southWall.material = wallMaterial;

                // Ø¯ÛŒÙˆØ§Ø± Ø´Ø±Ù‚ÛŒ
                const eastWall = BABYLON.MeshBuilder.CreateBox("eastWall", { width: 2, height: 8, depth: 50 }, scene);
                eastWall.position.x = -40;
                eastWall.position.y = 4;
                eastWall.material = wallMaterial;

                // Ø¯ÛŒÙˆØ§Ø± ØºØ±Ø¨ÛŒ
                const westWall = BABYLON.MeshBuilder.CreateBox("westWall", { width: 2, height: 8, depth: 50 }, scene);
                westWall.position.x = 40;
                westWall.position.y = 4;
                westWall.material = wallMaterial;
            }

            createStarfield() {
                for (let i = 0; i < 200; i++) {
                    const star = BABYLON.MeshBuilder.CreateSphere("star", { diameter: 0.1 }, scene);
                    star.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200
                    );
                    const material = new BABYLON.StandardMaterial("starMat", scene);
                    material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                    material.disableLighting = true;
                    star.material = material;
                }
            }

            setupUI() {
                // Ø¯Ú©Ù…Ù‡ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startGame();
                });

                // Ø¯Ú©Ù…Ù‡ Ø¨Ù…Ø¨
                document.getElementById('bombButton').addEventListener('click', () => {
                    if (gameState.gameRunning && !gameState.paused) {
                        this.useBomb();
                    }
                });

                // Ø¯Ú©Ù…Ù‡ Ø±Ø§Ù‡Ù†Ù…Ø§
                document.getElementById('instructionsBtn').addEventListener('click', () => {
                    document.getElementById('instructionsModal').classList.add('show');
                });

                // Ø¯Ú©Ù…Ù‡ Ø§Ø·Ù„Ø§Ø¹ÛŒÙ‡
                document.getElementById('managementBtn').addEventListener('click', () => {
                    document.getElementById('managementModal').classList.add('show');
                });

                // Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø³ØªÙ†
                document.getElementById('closeInstructions').addEventListener('click', () => {
                    document.getElementById('instructionsModal').classList.remove('show');
                });

                document.getElementById('closeManagement').addEventListener('click', () => {
                    document.getElementById('managementModal').classList.remove('show');
                });

                // Ø¨Ø³ØªÙ† Ø¨Ø§ Ú©Ù„ÛŒÚ© Ø®Ø§Ø±Ø¬
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.classList.remove('show');
                        }
                    });
                });
            }

            startGame() {
                // Ù¾Ù†Ù‡Ø§Ù† Ú©Ø±Ø¯Ù† Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ
                document.getElementById('centerPanel').style.opacity = '0';
                document.getElementById('topPanel').style.display = 'flex';
                document.getElementById('gameControls').style.display = 'flex';

                // Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø­Ø§Ù„Øª Ø¨Ø§Ø²ÛŒ
                gameState.gameRunning = true;
                gameState.paused = false;
                gameState.score = 0;
                gameState.fuel = 100;
                gameState.level = 1;

                // Ø§ÛŒØ¬Ø§Ø¯ Ø³ÙÛŒÙ†Ù‡ Ú©Ø§Ø±Ø¨Ø±
                this.createPlayerShip();

                // Ø´Ø±ÙˆØ¹ ØªØ§ÛŒÙ…Ø±Ù‡Ø§
                this.startGameTimers();

                this.showNotification("Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ! ğŸš€");
            }

            createPlayerShip() {
                playerShip = BABYLON.MeshBuilder.CreateBox("playerShip", { 
                    width: 2, 
                    height: 0.5, 
                    depth: 2 
                }, scene);

                const shipMaterial = new BABYLON.StandardMaterial("playerMat", scene);
                shipMaterial.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
                shipMaterial.emissiveColor = new BABYLON.Color3(0, 0.2, 0.4);
                playerShip.material = shipMaterial;

                playerShip.position = new BABYLON.Vector3(0, 1, 0);
            }

            startGameTimers() {
                // ØªØ§ÛŒÙ…Ø± Ù…ØµØ±Ù Ø³ÙˆØ®Øª
                const fuelTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused) {
                        gameState.fuel -= 0.1;
                        this.updateUI();
                        
                        if (gameState.fuel <= 0) {
                            this.gameOver();
                        }
                    }
                }, 100);
                this.gameTimers.push(fuelTimer);

                // ØªØ§ÛŒÙ…Ø± ØªÙˆÙ„ÛŒØ¯ Ø¯Ø´Ù…Ù†
                const enemyTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused && enemyShips.length < 8) {
                        this.spawnEnemy();
                    }
                }, 2000);
                this.gameTimers.push(enemyTimer);

                // ØªØ§ÛŒÙ…Ø± Ø´Ù„ÛŒÚ© Ø®ÙˆØ¯Ú©Ø§Ø±
                const shootTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused && playerShip) {
                        this.playerShoot();
                    }
                }, 500);
                this.gameTimers.push(shootTimer);
            }

            spawnEnemy() {
                const enemy = BABYLON.MeshBuilder.CreateBox("enemy", { 
                    width: 1.5, 
                    height: 0.8, 
                    depth: 1.5 
                }, scene);

                const x = (Math.random() - 0.5) * 60;
                enemy.position = new BABYLON.Vector3(x, 1, 22);

                const material = new BABYLON.StandardMaterial("enemyMat", scene);
                material.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
                material.emissiveColor = new BABYLON.Color3(0.4, 0, 0);
                enemy.material = material;

                enemyShips.push(enemy);
            }

            playerShoot() {
                if (!playerShip) return;

                const bullet = BABYLON.MeshBuilder.CreateSphere("bullet", { diameter: 0.3 }, scene);
                bullet.position = playerShip.position.clone();
                bullet.position.y = 1;

                const material = new BABYLON.StandardMaterial("bulletMat", scene);
                material.emissiveColor = new BABYLON.Color3(1, 1, 0.3);
                material.disableLighting = true;
                bullet.material = material;

                bullets.push({
                    mesh: bullet,
                    direction: new BABYLON.Vector3(0, 0, 1),
                    speed: 1.2,
                    isPlayer: true
                });
            }

            useBomb() {
                if (!playerShip) return;

                // Ù†Ø§Ø¨ÙˆØ¯ÛŒ ØªÙ…Ø§Ù… Ø¯Ø´Ù…Ù†Ø§Ù†
                enemyShips.forEach(enemy => {
                    this.createExplosion(enemy.position);
                    enemy.dispose();
                });
                enemyShips = [];

                // Ù†Ø§Ø¨ÙˆØ¯ÛŒ Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø´Ù…Ù†
                bullets.forEach(bullet => {
                    if (!bullet.isPlayer) {
                        bullet.mesh.dispose();
                    }
                });
                bullets = bullets.filter(bullet => bullet.isPlayer);

                this.showNotification("Ø¨Ù…Ø¨ Ù‡Ø³ØªÙ‡â€ŒØ§ÛŒ! ğŸ’£");
                this.createExplosion(playerShip.position, 2.0);
            }

            createExplosion(position, size = 1.0) {
                const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: 2 * size }, scene);
                explosion.position = position.clone();

                const material = new BABYLON.StandardMaterial("explosionMat", scene);
                material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                material.disableLighting = true;
                explosion.material = material;

                // Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø§Ù†ÙØ¬Ø§Ø±
                const frames = 30;
                const animation = new BABYLON.Animation(
                    "explosionAnim",
                    "scaling",
                    frames,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );

                const keys = [
                    { frame: 0, value: new BABYLON.Vector3(0.1, 0.1, 0.1) },
                    { frame: 15, value: new BABYLON.Vector3(2, 2, 2).scale(size) },
                    { frame: 30, value: new BABYLON.Vector3(0.1, 0.1, 0.1) }
                ];

                animation.setKeys(keys);
                explosion.animations = [animation];
                scene.beginAnimation(explosion, 0, 30, false, 2, () => {
                    explosion.dispose();
                });
            }

            update() {
                const deltaTime = engine.getDeltaTime() / 1000;

                // Ø­Ø±Ú©Øª Ú©Ø§Ø±Ø¨Ø±
                if (playerShip) {
                    const movement = this.touchControls.getMovement();
                    playerShip.position.x += movement.x;
                    playerShip.position.z += movement.y;

                    // Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø­Ø±Ú©Øª
                    playerShip.position.x = Math.max(-35, Math.min(35, playerShip.position.x));
                    playerShip.position.z = Math.max(-20, Math.min(20, playerShip.position.z));

                    // Ú†Ø±Ø®Ø´
                    if (movement.x !== 0 || movement.y !== 0) {
                        const targetRotation = Math.atan2(movement.x, -movement.y);
                        playerShip.rotation.y = BABYLON.Scalar.Lerp(playerShip.rotation.y, targetRotation, 0.2);
                    }
                }

                // Ø­Ø±Ú©Øª Ø¯Ø´Ù…Ù†Ø§Ù†
                enemyShips.forEach((enemy, index) => {
                    enemy.position.z -= 0.2;
                    enemy.lookAt(new BABYLON.Vector3(enemy.position.x, enemy.position.y, -100));

                    if (enemy.position.z < -30) {
                        enemy.dispose();
                        enemyShips.splice(index, 1);
                    }
                });

                // Ø­Ø±Ú©Øª Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§
                bullets.forEach((bullet, index) => {
                    bullet.mesh.position.addInPlace(bullet.direction.scale(bullet.speed));

                    // Ø­Ø°Ù Ø§Ú¯Ø± Ø®Ø§Ø±Ø¬ Ø´Ø¯
                    if (Math.abs(bullet.mesh.position.x) > 45 || Math.abs(bullet.mesh.position.z) > 35) {
                        bullet.mesh.dispose();
                        bullets.splice(index, 1);
                    }
                });

                // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯Ù‡Ø§
                this.checkCollisions();

                // Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ UI
                this.updateUI();
            }

            checkCollisions() {
                // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø¨Ø§ Ø¯Ø´Ù…Ù†
                bullets.forEach((bullet, bulletIndex) => {
                    if (!bullet.isPlayer) return;

                    enemyShips.forEach((enemy, enemyIndex) => {
                        const distance = BABYLON.Vector3.Distance(bullet.mesh.position, enemy.position);
                        if (distance < 1.5) {
                            // Ù†Ø§Ø¨ÙˆØ¯ÛŒ Ø¯Ø´Ù…Ù†
                            this.createExplosion(enemy.position);
                            enemy.dispose();
                            enemyShips.splice(enemyIndex, 1);

                            // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡
                            bullet.mesh.dispose();
                            bullets.splice(bulletIndex, 1);

                            // Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù…ØªÛŒØ§Ø² Ùˆ Ø³ÙˆØ®Øª
                            gameState.score += 100;
                            gameState.fuel = Math.min(100, gameState.fuel + 5);

                            this.showNotification("+100 Ø§Ù…ØªÛŒØ§Ø²! â­");
                        }
                    });
                });
            }

            updateUI() {
                document.getElementById('scoreValue').textContent = gameState.score;
                document.getElementById('fuelValue').textContent = Math.round(gameState.fuel) + '%';
                document.getElementById('levelValue').textContent = gameState.level;

                const fuelFill = document.getElementById('fuelFill');
                fuelFill.style.width = gameState.fuel + '%';

                if (gameState.fuel < 20) {
                    fuelFill.style.background = 'linear-gradient(90deg, #ff4444, #cc0000)';
                } else if (gameState.fuel < 50) {
                    fuelFill.style.background = 'linear-gradient(90deg, #ffaa00, #ff5500)';
                }
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notificationText');
                
                notificationText.textContent = message;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            showError(message) {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notificationText');
                
                notificationText.textContent = message;
                notification.classList.add('show');
                
                document.getElementById('loadingScreen').style.display = 'none';
            }

            gameOver() {
                gameState.gameRunning = false;

                // ØªÙˆÙ‚Ù ØªØ§ÛŒÙ…Ø±Ù‡Ø§
                this.gameTimers.forEach(timer => clearInterval(timer));
                this.gameTimers = [];

                // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ
                enemyShips.forEach(enemy => enemy.dispose());
                enemyShips = [];
                bullets.forEach(bullet => bullet.mesh.dispose());
                bullets = [];

                if (playerShip) {
                    playerShip.dispose();
                    playerShip = null;
                }

                this.showNotification(`Ø¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯! Ø§Ù…ØªÛŒØ§Ø²: ${gameState.score}`);

                // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ
                setTimeout(() => {
                    document.getElementById('centerPanel').style.opacity = '1';
                    document.getElementById('topPanel').style.display = 'none';
                    document.getElementById('gameControls').style.display = 'none';
                }, 3000);
            }
        }

        // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Ø²ÛŒ
        window.addEventListener('DOMContentLoaded', () => {
            console.log("ğŸ® Ø´Ø±ÙˆØ¹ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Ø²ÛŒ...");
            new GameSystem();
        });
    </script>
</body>
                                                                                     </html>
