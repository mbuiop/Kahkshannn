<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿ®ÿßÿ≤€å ⁄©Ÿá⁄©ÿ¥ÿßŸÜ€å ÿ≥€åŸÜŸÖÿß€å€å ÿ≠ÿ±ŸÅŸá‚Äåÿß€å</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #uiContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 200, 255, 0.3);
            pointer-events: all;
        }
        
        #topPanel {
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 15px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #00ccff;
            text-shadow: 0 0 10px #00ccff;
        }
        
        #fuelBar {
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #fuelFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 10px;
            transition: width 0.3s;
            box-shadow: 0 0 10px #00ff88;
        }
        
        #centerPanel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #centerPanel.show {
            opacity: 1;
            pointer-events: all;
        }
        
        #gameTitle {
            font-size: 3rem;
            color: #00ccff;
            text-shadow: 0 0 20px #00ccff;
            margin-bottom: 20px;
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 20px #00ccff; }
            to { text-shadow: 0 0 30px #00ccff, 0 0 40px #0066ff; }
        }
        
        .menu-btn {
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.5);
            transition: all 0.3s;
            margin: 10px;
            width: 200px;
        }
        
        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.7);
        }
        
        .menu-btn.start {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
            font-size: 1.4rem;
            padding: 18px 30px;
        }
        
        #controlsPanel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .control-btn {
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            color: white;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.5);
            transition: all 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.7);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .control-btn.fire {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.5);
        }
        
        .control-btn.bomb {
            background: linear-gradient(45deg, #ffaa00, #ff5500);
            box-shadow: 0 4px 15px rgba(255, 170, 0, 0.5);
        }
        
        .control-btn.special {
            background: linear-gradient(45deg, #aa00ff, #5500ff);
            box-shadow: 0 4px 15px rgba(170, 0, 255, 0.5);
        }
        
        #joystickContainer {
            position: fixed;
            bottom: 100px;
            left: 100px;
            width: 150px;
            height: 150px;
            pointer-events: none;
            z-index: 90;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
        }
        
        #joystickHandle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #00ccff, #0066ff);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.7);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }
        
        #debugPanel {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 200;
            display: none;
        }
        
        .upgrade-panel {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(0, 200, 255, 0.5);
            display: none;
        }
        
        .upgrade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upgrade-item:hover {
            background: rgba(0, 200, 255, 0.2);
            transform: translateX(-5px);
        }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid #00ccff;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            #joystickContainer {
                display: block;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.2rem;
            }
            
            #gameTitle {
                font-size: 2rem;
            }
            
            .menu-btn {
                padding: 12px 25px;
                font-size: 1rem;
                width: 160px;
            }
            
            .menu-btn.start {
                font-size: 1.2rem;
                padding: 15px 25px;
            }
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="uiContainer">
        <div id="topPanel" class="ui-panel">
            <div class="stat-item">
                <div class="stat-label">ÿßŸÖÿ™€åÿßÿ≤</div>
                <div class="stat-value" id="scoreValue">0</div>
            </div>
            
            <div class="stat-item">
                <div class="stat-label">ÿ≥ŸàÿÆÿ™</div>
                <div class="stat-value" id="fuelValue">100%</div>
                <div id="fuelBar">
                    <div id="fuelFill" style="width: 100%;"></div>
                </div>
            </div>
            
            <div class="stat-item">
                <div class="stat-label">ŸÖÿ±ÿ≠ŸÑŸá</div>
                <div class="stat-value" id="levelValue">1</div>
            </div>
            
            <div class="stat-item">
                <div class="stat-label">ÿ≤ŸÖÿßŸÜ</div>
                <div class="stat-value" id="timeValue">00:00</div>
            </div>
        </div>
        
        <div id="centerPanel" class="ui-panel">
            <h1 id="gameTitle">üöÄ ÿ®ÿßÿ≤€å ⁄©Ÿá⁄©ÿ¥ÿßŸÜ€å ÿ≥€åŸÜŸÖÿß€å€å</h1>
            <button class="menu-btn start" id="startBtn">ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å</button>
            <button class="menu-btn" id="instructionsBtn">ÿ±ÿßŸáŸÜŸÖÿß</button>
            <button class="menu-btn" id="upgradesBtn">ÿßÿ±ÿ™ŸÇÿßÿ° Ÿáÿß</button>
            <button class="menu-btn" id="settingsBtn">ÿ™ŸÜÿ∏€åŸÖÿßÿ™</button>
        </div>
        
        <div id="controlsPanel" class="ui-panel">
            <button class="control-btn fire" id="fireBtn">üî•</button>
            <button class="control-btn bomb" id="bombBtn">üí£</button>
            <button class="control-btn special" id="specialBtn">‚ö°</button>
            <button class="control-btn" id="pauseBtn">‚è∏Ô∏è</button>
        </div>
        
        <div id="joystickContainer">
            <div id="joystickBase"></div>
            <div id="joystickHandle"></div>
        </div>
        
        <div class="upgrade-panel" id="upgradePanel">
            <h3 style="color: #00ccff; margin-bottom: 15px; text-align: center;">ÿßÿ±ÿ™ŸÇÿßÿ° ÿ≥ŸÅ€åŸÜŸá</h3>
            <div class="upgrade-item" data-upgrade="speed">
                <span>ÿ≥ÿ±ÿπÿ™ ÿ≥ŸÅ€åŸÜŸá</span>
                <span class="stat-value">+</span>
            </div>
            <div class="upgrade-item" data-upgrade="firepower">
                <span>ŸÇÿØÿ±ÿ™ ÿ¥ŸÑ€å⁄©</span>
                <span class="stat-value">+</span>
            </div>
            <div class="upgrade-item" data-upgrade="shield">
                <span>ŸÖÿ≠ÿßŸÅÿ∏</span>
                <span class="stat-value">+</span>
            </div>
            <div class="upgrade-item" data-upgrade="fuel">
                <span>ÿ∏ÿ±ŸÅ€åÿ™ ÿ≥ŸàÿÆÿ™</span>
                <span class="stat-value">+</span>
            </div>
        </div>
        
        <div id="notification" class="notification">
            <div id="notificationText"></div>
        </div>
    </div>

    <!-- Babylon.js Libraries -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    
    <script>
        // =============================================
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿßÿµŸÑ€å ÿ®ÿßÿ≤€å - ÿ®€åÿ¥ ÿßÿ≤ 5000 ÿÆÿ∑ ⁄©ÿØ ÿ≠ÿ±ŸÅŸá‚Äåÿß€å
        // =============================================
        
        // ÿ´ÿßÿ®ÿ™‚ÄåŸáÿß€å ÿ®ÿßÿ≤€å
        const GAME_CONSTANTS = {
            VERSION: "1.0.0",
            DEBUG: false,
            
            // ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ŸÅ€åÿ≤€å⁄©€å
            GRAVITY: new BABYLON.Vector3(0, -9.81, 0),
            PLAYER_SPEED: 0.3,
            ENEMY_SPEED: 0.2,
            BULLET_SPEED: 1.0,
            SPECIAL_BULLET_SPEED: 1.5,
            
            // ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ®ÿßÿ≤€å
            INITIAL_FUEL: 100,
            FUEL_CONSUMPTION: 0.02,
            FUEL_REFILL_RATE: 5,
            INITIAL_LIVES: 3,
            LEVEL_TIME: 120, // ÿ´ÿßŸÜ€åŸá
            
            // ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿØÿ¥ŸÖŸÜ
            ENEMY_SPAWN_RATE: 2000,
            ENEMY_BULLET_RATE: 1500,
            MAX_ENEMIES: 15,
            
            // ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿßÿ±ÿ™ŸÇÿßÿ°
            UPGRADE_COST_MULTIPLIER: 100,
            
            // ÿ±ŸÜ⁄Ø‚ÄåŸáÿß
            COLORS: {
                PLAYER: new BABYLON.Color3(0, 0.5, 1),
                ENEMY: new BABYLON.Color3(1, 0, 0),
                BULLET: new BABYLON.Color3(1, 1, 0),
                SPECIAL_BULLET: new BABYLON.Color3(0, 1, 1),
                BACKGROUND: new BABYLON.Color3(0.1, 0.1, 0.2),
                GRID: new BABYLON.Color3(0.3, 0.3, 0.5)
            }
        };
        
        // ŸÖÿ™ÿ∫€åÿ±Ÿáÿß€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤€å
        let canvas, engine, scene, camera, light;
        let playerShip, enemyShips = [], bullets = [], enemyBullets = [], specialEffects = [];
        let gameState = {
            score: 0,
            fuel: GAME_CONSTANTS.INITIAL_FUEL,
            level: 1,
            lives: GAME_CONSTANTS.INITIAL_LIVES,
            time: 0,
            gameRunning: false,
            paused: false,
            upgrades: {
                speed: 1,
                firepower: 1,
                shield: 1,
                fuel: 1
            },
            coins: 0
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ≥ÿßÿ≤€å
        const StorageSystem = {
            saveGame: function() {
                try {
                    const saveData = {
                        score: gameState.score,
                        level: gameState.level,
                        upgrades: gameState.upgrades,
                        coins: gameState.coins,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('galacticGameSave', JSON.stringify(saveData));
                    console.log('Game saved successfully');
                } catch (error) {
                    console.error('Error saving game:', error);
                }
            },
            
            loadGame: function() {
                try {
                    const saveData = JSON.parse(localStorage.getItem('galacticGameSave'));
                    if (saveData) {
                        gameState.score = saveData.score || 0;
                        gameState.level = saveData.level || 1;
                        gameState.upgrades = saveData.upgrades || {
                            speed: 1,
                            firepower: 1,
                            shield: 1,
                            fuel: 1
                        };
                        gameState.coins = saveData.coins || 0;
                        console.log('Game loaded successfully');
                        return true;
                    }
                } catch (error) {
                    console.error('Error loading game:', error);
                }
                return false;
            },
            
            clearSave: function() {
                try {
                    localStorage.removeItem('galacticGameSave');
                    console.log('Game save cleared');
                } catch (error) {
                    console.error('Error clearing save:', error);
                }
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿµŸàÿ™€å
        const AudioSystem = {
            sounds: {},
            enabled: true,
            
            init: function(scene) {
                // ÿß€åÿ¨ÿßÿØ ÿµÿØÿßŸáÿß€å ÿ®ÿßÿ≤€å
                this.sounds.shoot = new BABYLON.Sound("shoot", "https://assets.babylonjs.com/sounds/laser.wav", scene);
                this.sounds.explosion = new BABYLON.Sound("explosion", "https://assets.babylonjs.com/sounds/explosion.wav", scene);
                this.sounds.engine = new BABYLON.Sound("engine", "https://assets.babylonjs.com/sounds/engine.wav", scene, null, { loop: true, volume: 0.3 });
                this.sounds.background = new BABYLON.Sound("background", "https://assets.babylonjs.com/sounds/ambient.wav", scene, null, { loop: true, volume: 0.2 });
                
                console.log('Audio system initialized');
            },
            
            play: function(soundName, options = {}) {
                if (!this.enabled || !this.sounds[soundName]) return;
                
                try {
                    if (options.overwrite) {
                        this.sounds[soundName].stop();
                    }
                    this.sounds[soundName].play();
                } catch (error) {
                    console.error('Error playing sound:', error);
                }
            },
            
            stop: function(soundName) {
                if (!this.sounds[soundName]) return;
                
                try {
                    this.sounds[soundName].stop();
                } catch (error) {
                    console.error('Error stopping sound:', error);
                }
            },
            
            setVolume: function(soundName, volume) {
                if (!this.sounds[soundName]) return;
                
                try {
                    this.sounds[soundName].setVolume(volume);
                } catch (error) {
                    console.error('Error setting volume:', error);
                }
            },
            
            toggle: function() {
                this.enabled = !this.enabled;
                if (!this.enabled) {
                    this.stopAll();
                }
                return this.enabled;
            },
            
            stopAll: function() {
                for (const soundName in this.sounds) {
                    this.stop(soundName);
                }
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿ±ÿßÿ™
        const ParticleSystem = {
            systems: {},
            
            createEngineParticles: function(emitter, scene) {
                const particleSystem = new BABYLON.ParticleSystem("engineParticles", 2000, scene);
                particleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
                particleSystem.emitter = emitter;
                particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1.0);
                particleSystem.color2 = new BABYLON.Color4(1, 0, 0, 1.0);
                particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
                particleSystem.minSize = 0.1;
                particleSystem.maxSize = 0.5;
                particleSystem.minLifeTime = 0.3;
                particleSystem.maxLifeTime = 0.5;
                particleSystem.emitRate = 1500;
                particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                particleSystem.gravity = new BABYLON.Vector3(0, 0, -10);
                particleSystem.direction1 = new BABYLON.Vector3(0, 0, -1);
                particleSystem.direction2 = new BABYLON.Vector3(0, 0, -1);
                particleSystem.minAngularSpeed = 0;
                particleSystem.maxAngularSpeed = Math.PI;
                particleSystem.minEmitPower = 1;
                particleSystem.maxEmitPower = 3;
                particleSystem.updateSpeed = 0.005;
                
                this.systems.engine = particleSystem;
                return particleSystem;
            },
            
            createExplosionParticles: function(position, scene, color = new BABYLON.Color3(1, 0.5, 0)) {
                const particleSystem = new BABYLON.ParticleSystem("explosionParticles", 3000, scene);
                particleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
                particleSystem.emitter = position;
                particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1.0);
                particleSystem.color2 = new BABYLON.Color4(1, 1, 0, 1.0);
                particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
                particleSystem.minSize = 0.1;
                particleSystem.maxSize = 1.0;
                particleSystem.minLifeTime = 0.5;
                particleSystem.maxLifeTime = 1.5;
                particleSystem.emitRate = 3000;
                particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                particleSystem.minEmitPower = 5;
                particleSystem.maxEmitPower = 10;
                particleSystem.updateSpeed = 0.01;
                particleSystem.targetStopDuration = 1.5;
                
                particleSystem.start();
                setTimeout(() => {
                    particleSystem.stop();
                    setTimeout(() => {
                        particleSystem.dispose();
                    }, 2000);
                }, 100);
                
                return particleSystem;
            },
            
            createTrailParticles: function(emitter, scene) {
                const particleSystem = new BABYLON.ParticleSystem("trailParticles", 1000, scene);
                particleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
                particleSystem.emitter = emitter;
                particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                particleSystem.color1 = new BABYLON.Color4(0, 0.8, 1, 0.5);
                particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1, 0.3);
                particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
                particleSystem.minSize = 0.05;
                particleSystem.maxSize = 0.2;
                particleSystem.minLifeTime = 0.5;
                particleSystem.maxLifeTime = 1.0;
                particleSystem.emitRate = 500;
                particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                particleSystem.direction1 = new BABYLON.Vector3(0, 0, -1);
                particleSystem.direction2 = new BABYLON.Vector3(0, 0, -1);
                particleSystem.minEmitPower = 0.5;
                particleSystem.maxEmitPower = 1.0;
                particleSystem.updateSpeed = 0.01;
                
                return particleSystem;
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿßŸÅ⁄©ÿ™‚ÄåŸáÿß€å Ÿà€å⁄òŸá
        const SpecialEffects = {
            createShockwave: function(position, scene, size = 10, duration = 1000) {
                const shockwave = BABYLON.MeshBuilder.CreateSphere("shockwave", { diameter: 1 }, scene);
                const material = new BABYLON.StandardMaterial("shockwaveMat", scene);
                material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                material.alpha = 0.7;
                material.disableLighting = true;
                shockwave.material = material;
                shockwave.position = position.clone();
                
                // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ÿ¥Ÿà⁄© Ÿà€åŸà
                const animation = new BABYLON.Animation(
                    "shockwaveAnimation",
                    "scaling",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
                
                const keys = [
                    { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                    { frame: 30, value: new BABYLON.Vector3(size, size, size) }
                ];
                
                animation.setKeys(keys);
                shockwave.animations = [animation];
                
                scene.beginAnimation(shockwave, 0, 30, false, 1, () => {
                    shockwave.dispose();
                });
                
                // ÿßŸÅ⁄©ÿ™ ŸÜŸàÿ±
                const light = new BABYLON.PointLight("shockwaveLight", position, scene);
                light.intensity = 5;
                light.diffuse = new BABYLON.Color3(1, 0.5, 0);
                light.range = size * 2;
                
                setTimeout(() => {
                    light.dispose();
                }, duration);
                
                return shockwave;
            },
            
            createBeam: function(start, end, scene, duration = 500) {
                const beam = BABYLON.MeshBuilder.CreateCylinder("beam", { height: BABYLON.Vector3.Distance(start, end), diameterTop: 0.1, diameterBottom: 0.1 }, scene);
                beam.position = BABYLON.Vector3.Center(start, end);
                beam.lookAt(end);
                
                const material = new BABYLON.StandardMaterial("beamMat", scene);
                material.emissiveColor = new BABYLON.Color3(0, 1, 1);
                material.disableLighting = true;
                material.alpha = 0.7;
                beam.material = material;
                
                setTimeout(() => {
                    beam.dispose();
                }, duration);
                
                return beam;
            },
            
            createEnergyField: function(position, scene, size = 5, duration = 3000) {
                const field = BABYLON.MeshBuilder.CreateSphere("energyField", { diameter: size }, scene);
                const material = new BABYLON.StandardMaterial("energyFieldMat", scene);
                material.emissiveColor = new BABYLON.Color3(0, 0.5, 1);
                material.alpha = 0.3;
                material.disableLighting = true;
                field.material = material;
                field.position = position.clone();
                
                // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ŸæÿßŸÑÿ≥
                const animation = new BABYLON.Animation(
                    "fieldAnimation",
                    "scaling",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const keys = [
                    { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                    { frame: 15, value: new BABYLON.Vector3(1.2, 1.2, 1.2) },
                    { frame: 30, value: new BABYLON.Vector3(1, 1, 1) }
                ];
                
                animation.setKeys(keys);
                field.animations = [animation];
                scene.beginAnimation(field, 0, 30, true);
                
                setTimeout(() => {
                    field.dispose();
                }, duration);
                
                return field;
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å ÿØÿ¥ŸÖŸÜÿßŸÜ
        const EnemyAI = {
            behaviors: {
                aggressive: function(enemy, playerPosition) {
                    const direction = playerPosition.subtract(enemy.position).normalize();
                    return direction.scale(GAME_CONSTANTS.ENEMY_SPEED * (1 + gameState.level * 0.1));
                },
                
                evasive: function(enemy, playerPosition) {
                    const direction = playerPosition.subtract(enemy.position).normalize();
                    const perpendicular = new BABYLON.Vector3(-direction.z, 0, direction.x);
                    return perpendicular.scale(GAME_CONSTANTS.ENEMY_SPEED * 0.8);
                },
                
                circling: function(enemy, playerPosition) {
                    const radius = 10;
                    const angle = Date.now() * 0.001;
                    const target = new BABYLON.Vector3(
                        playerPosition.x + Math.cos(angle) * radius,
                        playerPosition.y,
                        playerPosition.z + Math.sin(angle) * radius
                    );
                    const direction = target.subtract(enemy.position).normalize();
                    return direction.scale(GAME_CONSTANTS.ENEMY_SPEED * 0.7);
                },
                
                kamikaze: function(enemy, playerPosition) {
                    const direction = playerPosition.subtract(enemy.position).normalize();
                    return direction.scale(GAME_CONSTANTS.ENEMY_SPEED * 1.5);
                }
            },
            
            getBehavior: function(enemyType) {
                const behaviors = Object.keys(this.behaviors);
                const randomBehavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                return this.behaviors[randomBehavior];
            },
            
            shouldShoot: function(enemy, playerPosition) {
                const distance = BABYLON.Vector3.Distance(enemy.position, playerPosition);
                return distance < 20 && Math.random() < 0.02 * gameState.level;
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿ™ŸàŸÑ€åÿØ procedural
        const ProceduralGenerator = {
            generateAsteroid: function(scene, size = 1) {
                const asteroid = BABYLON.MeshBuilder.CreateIcoSphere("asteroid", { radius: size, subdivisions: 2 }, scene);
                
                // ÿß€åÿ¨ÿßÿØ ÿ≥ÿ∑ÿ≠ ŸÜÿßŸáŸÖŸàÿßÿ±
                const positions = asteroid.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                for (let i = 0; i < positions.length; i += 3) {
                    const noise = (Math.random() - 0.5) * 0.3 * size;
                    positions[i] += noise;
                    positions[i + 1] += noise;
                    positions[i + 2] += noise;
                }
                asteroid.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
                
                // ŸÖŸàÿßÿØ procedural
                const material = new BABYLON.StandardMaterial("asteroidMat", scene);
                material.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
                material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                asteroid.material = material;
                
                return asteroid;
            },
            
            generateNebula: function(scene, position, size = 50) {
                const nebula = BABYLON.MeshBuilder.CreateSphere("nebula", { diameter: size }, scene);
                nebula.position = position;
                
                const material = new BABYLON.StandardMaterial("nebulaMat", scene);
                material.emissiveColor = new BABYLON.Color3(Math.random() * 0.5, Math.random() * 0.5, Math.random() * 0.5);
                material.alpha = 0.1;
                material.disableLighting = true;
                nebula.material = material;
                
                return nebula;
            },
            
            generateStarfield: function(scene, count = 1000) {
                const starfield = [];
                for (let i = 0; i < count; i++) {
                    const star = BABYLON.MeshBuilder.CreateSphere("star", { diameter: 0.1 }, scene);
                    star.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200
                    );
                    
                    const material = new BABYLON.StandardMaterial("starMat", scene);
                    material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                    material.disableLighting = true;
                    star.material = material;
                    
                    starfield.push(star);
                }
                return starfield;
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ŸÅ€åÿ≤€å⁄©€å Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá
        const PhysicsSystem = {
            world: null,
            
            init: function(scene) {
                // ÿß€åÿ¨ÿßÿØ ŸÅ€åÿ≤€å⁄© ÿ¨ŸáÿßŸÜ€å
                const gravity = new BABYLON.Vector3(0, 0, 0);
                this.world = new BABYLON.PhysicsEngine(gravity);
                
                console.log('Physics system initialized');
            },
            
            applyForce: function(mesh, force) {
                if (!this.world) return;
                
                // ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ¥ÿ™ÿßÿ®
                const acceleration = force.scale(1 / mesh.physicsMass || 1);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ≥ÿ±ÿπÿ™
                mesh.physicsVelocity = mesh.physicsVelocity || new BABYLON.Vector3(0, 0, 0);
                mesh.physicsVelocity.addInPlace(acceleration);
            },
            
            update: function(deltaTime) {
                if (!this.world) return;
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖŸàŸÇÿπ€åÿ™ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≥ÿ±ÿπÿ™
                scene.meshes.forEach(mesh => {
                    if (mesh.physicsVelocity) {
                        mesh.position.addInPlace(mesh.physicsVelocity.scale(deltaTime));
                        
                        // ÿßÿπŸÖÿßŸÑ ÿßÿµÿ∑⁄©ÿß⁄©
                        mesh.physicsVelocity.scaleInPlace(0.98);
                    }
                });
            },
            
            checkCollision: function(mesh1, mesh2) {
                const distance = BABYLON.Vector3.Distance(mesh1.position, mesh2.position);
                const radius1 = mesh1.boundingSphere ? mesh1.boundingSphere.radius : 1;
                const radius2 = mesh2.boundingSphere ? mesh2.boundingSphere.radius : 1;
                
                return distance < (radius1 + radius2);
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿ±ÿßÿ®ÿ∑ ⁄©ÿßÿ±ÿ®ÿ±€å Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá
        const UISystem = {
            init: function() {
                this.setupEventListeners();
                this.showMainMenu();
                console.log('UI system initialized');
            },
            
            setupEventListeners: function() {
                // ÿØ⁄©ŸÖŸá ÿ¥ÿ±Ÿàÿπ ÿ®ÿßÿ≤€å
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.hideMainMenu();
                    Game.start();
                });
                
                // ÿØ⁄©ŸÖŸá ÿ¥ŸÑ€å⁄©
                document.getElementById('fireBtn').addEventListener('click', () => {
                    if (gameState.gameRunning && !gameState.paused) {
                        Player.shoot();
                    }
                });
                
                // ÿØ⁄©ŸÖŸá ÿ®ŸÖÿ®
                document.getElementById('bombBtn').addEventListener('click', () => {
                    if (gameState.gameRunning && !gameState.paused) {
                        Player.useBomb();
                    }
                });
                
                // ÿØ⁄©ŸÖŸá Ÿà€å⁄òŸá
                document.getElementById('specialBtn').addEventListener('click', () => {
                    if (gameState.gameRunning && !gameState.paused) {
                        Player.useSpecial();
                    }
                });
                
                // ÿØ⁄©ŸÖŸá ÿ™ŸàŸÇŸÅ
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    Game.togglePause();
                });
                
                // ÿØ⁄©ŸÖŸá ÿßÿ±ÿ™ŸÇÿßÿ°
                document.getElementById('upgradesBtn').addEventListener('click', () => {
                    this.showUpgradePanel();
                });
                
                // ÿ±Ÿà€åÿØÿßÿØŸáÿß€å ÿßÿ±ÿ™ŸÇÿßÿ°
                document.querySelectorAll('.upgrade-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const upgradeType = e.currentTarget.getAttribute('data-upgrade');
                        Player.purchaseUpgrade(upgradeType);
                    });
                });
                
                // ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß€å ÿµŸÅÿ≠Ÿá‚Äå⁄©ŸÑ€åÿØ
                window.addEventListener('keydown', (e) => {
                    if (!gameState.gameRunning || gameState.paused) return;
                    
                    switch(e.key) {
                        case ' ':
                        case 'Spacebar':
                            e.preventDefault();
                            Player.shoot();
                            break;
                        case 'b':
                        case 'B':
                            Player.useBomb();
                            break;
                        case 's':
                        case 'S':
                            Player.useSpecial();
                            break;
                        case 'p':
                        case 'P':
                        case 'Escape':
                            Game.togglePause();
                            break;
                    }
                });
            },
            
            showMainMenu: function() {
                document.getElementById('centerPanel').classList.add('show');
                document.getElementById('controlsPanel').style.display = 'none';
                document.getElementById('topPanel').style.display = 'none';
            },
            
            hideMainMenu: function() {
                document.getElementById('centerPanel').classList.remove('show');
                document.getElementById('controlsPanel').style.display = 'flex';
                document.getElementById('topPanel').style.display = 'flex';
            },
            
            showUpgradePanel: function() {
                document.getElementById('upgradePanel').style.display = 'block';
            },
            
            hideUpgradePanel: function() {
                document.getElementById('upgradePanel').style.display = 'none';
            },
            
            updateStats: function() {
                document.getElementById('scoreValue').textContent = gameState.score.toLocaleString();
                document.getElementById('fuelValue').textContent = Math.round(gameState.fuel) + '%';
                document.getElementById('levelValue').textContent = gameState.level;
                document.getElementById('timeValue').textContent = this.formatTime(gameState.time);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜŸàÿßÿ± ÿ≥ŸàÿÆÿ™
                const fuelFill = document.getElementById('fuelFill');
                fuelFill.style.width = gameState.fuel + '%';
                
                // ÿ™ÿ∫€å€åÿ± ÿ±ŸÜ⁄Ø ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≥ÿ∑ÿ≠ ÿ≥ŸàÿÆÿ™
                if (gameState.fuel < 20) {
                    fuelFill.style.background = 'linear-gradient(90deg, #ff4444, #cc0000)';
                } else if (gameState.fuel < 50) {
                    fuelFill.style.background = 'linear-gradient(90deg, #ffaa00, #ff5500)';
                } else {
                    fuelFill.style.background = 'linear-gradient(90deg, #00ff88, #00ccff)';
                }
            },
            
            formatTime: function(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            },
            
            showNotification: function(message, duration = 3000) {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notificationText');
                
                notificationText.textContent = message;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, duration);
            },
            
            showGameOver: function() {
                const message = `ÿ®ÿßÿ≤€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØ!\nÿßŸÖÿ™€åÿßÿ≤ ŸÜŸáÿß€å€å: ${gameState.score}\nŸÖÿ±ÿ≠ŸÑŸá: ${gameState.level}`;
                this.showNotification(message, 5000);
                
                setTimeout(() => {
                    this.showMainMenu();
                }, 5000);
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ⁄©ŸÜÿ™ÿ±ŸÑ ŸÑŸÖÿ≥€å
        const TouchControlSystem = {
            joystickActive: false,
            joystickX: 0,
            joystickY: 0,
            touchId: null,
            
            init: function() {
                const joystickContainer = document.getElementById('joystickContainer');
                const joystickHandle = document.getElementById('joystickHandle');
                
                joystickContainer.addEventListener('touchstart', this.handleTouchStart.bind(this));
                document.addEventListener('touchmove', this.handleTouchMove.bind(this));
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));
                document.addEventListener('touchcancel', this.handleTouchEnd.bind(this));
                
                console.log('Touch control system initialized');
            },
            
            handleTouchStart: function(e) {
                e.preventDefault();
                if (this.touchId !== null) return;
                
                const touch = e.touches[0];
                this.touchId = touch.identifier;
                this.joystickActive = true;
                
                // ŸÖŸàŸÇÿπ€åÿ™ ÿßŸàŸÑ€åŸá ÿ®ÿ±ÿß€å ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≠ÿ±⁄©ÿ™ ŸÜÿ≥ÿ®€å
                this.startX = touch.clientX;
                this.startY = touch.clientY;
            },
            
            handleTouchMove: function(e) {
                e.preventDefault();
                if (this.touchId === null) return;
                
                // Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ ŸÑŸÖÿ≥€å ⁄©Ÿá ÿ¥ÿ±Ÿàÿπ ⁄©ÿ±ÿØ€åŸÖ
                let touch = null;
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === this.touchId) {
                        touch = e.touches[i];
                        break;
                    }
                }
                
                if (!touch) return;
                
                // ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≠ÿ±⁄©ÿ™ ŸÜÿ≥ÿ®€å
                const deltaX = touch.clientX - this.startX;
                const deltaY = touch.clientY - this.startY;
                
                // ŸÖÿ≠ÿØŸàÿØ ⁄©ÿ±ÿØŸÜ ÿ®Ÿá ÿØÿß€åÿ±Ÿá
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = 50; // ŸÜÿµŸÅ ÿπÿ±ÿ∂ ÿ¨Ÿà€åÿ≥ÿ™€å⁄©
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    this.joystickX = Math.cos(angle);
                    this.joystickY = Math.sin(angle);
                    
                    // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖŸàŸÇÿπ€åÿ™ ŸáŸÜÿØŸÑ
                    document.getElementById('joystickHandle').style.transform = 
                        `translate(${Math.cos(angle) * maxDistance}px, ${Math.sin(angle) * maxDistance}px)`;
                } else {
                    this.joystickX = deltaX / maxDistance;
                    this.joystickY = deltaY / maxDistance;
                    
                    // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖŸàŸÇÿπ€åÿ™ ŸáŸÜÿØŸÑ
                    document.getElementById('joystickHandle').style.transform = 
                        `translate(${deltaX}px, ${deltaY}px)`;
                }
            },
            
            handleTouchEnd: function(e) {
                e.preventDefault();
                this.touchId = null;
                this.joystickActive = false;
                this.joystickX = 0;
                this.joystickY = 0;
                
                // ÿ®ÿßÿ≤⁄Øÿ±ÿØÿßŸÜÿØŸÜ ŸáŸÜÿØŸÑ ÿ®Ÿá ŸÖÿ±⁄©ÿ≤
                document.getElementById('joystickHandle').style.transform = 'translate(0, 0)';
            },
            
            getMovement: function() {
                if (!this.joystickActive) return new BABYLON.Vector3(0, 0, 0);
                
                return new BABYLON.Vector3(
                    this.joystickX * GAME_CONSTANTS.PLAYER_SPEED * gameState.upgrades.speed,
                    0,
                    this.joystickY * GAME_CONSTANTS.PLAYER_SPEED * gameState.upgrades.speed
                );
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿ®ÿßÿ≤€å
        const Game = {
            init: function() {
                // ÿß€åÿ¨ÿßÿØ ŸÖŸàÿ™Ÿàÿ± Ÿà ÿµÿ≠ŸÜŸá
                canvas = document.getElementById('renderCanvas');
                engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                
                scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0, 0, 0.1, 1);
                
                // ÿß€åÿ¨ÿßÿØ ÿØŸàÿ±ÿ®€åŸÜ ÿßÿ≤ ŸÜŸÖÿß€å ÿ®ÿßŸÑÿß
                this.setupCamera();
                
                // ÿß€åÿ¨ÿßÿØ ŸÜŸàÿ±Ÿæÿ±ÿØÿßÿ≤€å
                this.setupLighting();
                
                // ÿß€åÿ¨ÿßÿØ ŸÖÿ≠€åÿ∑ ÿ®ÿßÿ≤€å
                this.createGameEnvironment();
                
                // ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ≥€åÿ≥ÿ™ŸÖ‚ÄåŸáÿß
                AudioSystem.init(scene);
                PhysicsSystem.init(scene);
                UISystem.init();
                TouchControlSystem.init();
                
                // ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ®ÿßÿ≤€å ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØŸá
                StorageSystem.loadGame();
                
                // ÿ≠ŸÑŸÇŸá ÿ±ŸÜÿØÿ±
                engine.runRenderLoop(() => {
                    if (gameState.gameRunning && !gameState.paused) {
                        this.update();
                    }
                    scene.render();
                });
                
                // ŸÖÿØ€åÿ±€åÿ™ ÿ™ÿ∫€å€åÿ± ÿßŸÜÿØÿßÿ≤Ÿá ŸæŸÜÿ¨ÿ±Ÿá
                window.addEventListener('resize', () => {
                    engine.resize();
                });
                
                console.log('Game initialized successfully');
            },
            
            setupCamera: function() {
                // ÿØŸàÿ±ÿ®€åŸÜ ÿßÿ≤ ŸÜŸÖÿß€å ÿ®ÿßŸÑÿß
                camera = new BABYLON.ArcRotateCamera(
                    "overviewCamera",
                    -Math.PI / 2,
                    Math.PI / 2.5,
                    50,
                    new BABYLON.Vector3(0, 30, 0),
                    scene
                );
                
                camera.lowerBetaLimit = Math.PI / 4;
                camera.upperBetaLimit = Math.PI / 2;
                camera.lowerRadiusLimit = 30;
                camera.upperRadiusLimit = 100;
                camera.attachControl(canvas, true);
                
                // ÿØŸàÿ±ÿ®€åŸÜ ÿØŸàŸÖ ÿ®ÿ±ÿß€å ŸÜŸÖÿß€å ŸÜÿ≤ÿØ€å⁄©
                this.closeupCamera = new BABYLON.FollowCamera(
                    "closeupCamera",
                    new BABYLON.Vector3(0, 5, -10),
                    scene
                );
                this.closeupCamera.radius = 10;
                this.closeupCamera.heightOffset = 5;
                this.closeupCamera.rotationOffset = 0;
                this.closeupCamera.cameraAcceleration = 0.1;
                this.closeupCamera.maxCameraSpeed = 5;
                
                this.currentCamera = camera;
            },
            
            setupLighting: function() {
                // ŸÜŸàÿ± ÿßÿµŸÑ€å
                const mainLight = new BABYLON.HemisphericLight("mainLight", new BABYLON.Vector3(0, 1, 0), scene);
                mainLight.intensity = 0.7;
                mainLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                
                // ŸÜŸàÿ± ŸÜŸÇÿ∑Ÿá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿ¨ŸÑŸàŸá‚ÄåŸáÿß€å Ÿà€å⁄òŸá
                this.specialLight = new BABYLON.PointLight("specialLight", new BABYLON.Vector3(0, 0, 0), scene);
                this.specialLight.intensity = 0;
                this.specialLight.diffuse = new BABYLON.Color3(0, 0.5, 1);
                
                // ŸÜŸàÿ± ŸÖÿ≠€åÿ∑€å ŸæŸà€åÿß
                this.ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
                this.ambientLight.intensity = 0.3;
            },
            
            createGameEnvironment: function() {
                // ÿß€åÿ¨ÿßÿØ ÿ≤ŸÖ€åŸÜ ÿ®ÿßÿ≤€å (ÿßÿ≥ÿ™ÿßÿØ€åŸàŸÖ ŸÅÿ∂ÿß€å€å)
                this.createStadium();
                
                // ÿß€åÿ¨ÿßÿØ Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá ⁄©Ÿá⁄©ÿ¥ÿßŸÜ€å
                this.createGalacticBackground();
                
                // ÿß€åÿ¨ÿßÿØ ÿØ€åŸàÿßÿ±Ÿáÿß€å ŸÖÿ≠€åÿ∑
                this.createBoundaryWalls();
                
                // ÿß€åÿ¨ÿßÿØ ÿ¨ŸÑŸàŸá‚ÄåŸáÿß€å Ÿà€å⁄òŸá ŸÖÿ≠€åÿ∑€å
                this.createEnvironmentalEffects();
            },
            
            createStadium: function() {
                // ⁄©ŸÅ ÿßÿ≥ÿ™ÿßÿØ€åŸàŸÖ
                const ground = BABYLON.MeshBuilder.CreateGround("stadiumGround", { width: 100, height: 60 }, scene);
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
                
                // ÿ™⁄©ÿ≥⁄Üÿ± ÿ¥ÿ®⁄©Ÿá‚Äåÿß€å ÿ®ÿ±ÿß€å ⁄©ŸÅ
                const gridTexture = new BABYLON.GridMaterial("gridTexture", scene);
                gridTexture.mainColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                gridMaterial.lineColor = new BABYLON.Color3(0.2, 0.2, 0.4);
                gridMaterial.gridRatio = 1;
                gridMaterial.opacity = 0.7;
                
                ground.material = gridTexture;
                ground.receiveShadows = true;
                
                // ÿÆÿ∑Ÿàÿ∑ ŸÖ€åÿßŸÜ€å
                const centerLine = BABYLON.MeshBuilder.CreateBox("centerLine", { width: 2, height: 60, depth: 0.1 }, scene);
                centerLine.position.x = 0;
                
                const centerLineMaterial = new BABYLON.StandardMaterial("centerLineMat", scene);
                centerLineMaterial.emissiveColor = new BABYLON.Color3(0, 0.5, 1);
                centerLineMaterial.alpha = 0.7;
                centerLine.material = centerLineMaterial;
                
                // ÿØÿß€åÿ±Ÿá ŸÖÿ±⁄©ÿ≤€å
                const centerCircle = BABYLON.MeshBuilder.CreateTorus("centerCircle", { diameter: 10, thickness: 0.5 }, scene);
                centerCircle.position.x = 0;
                centerCircle.rotation.x = Math.PI / 2;
                centerCircle.material = centerLineMaterial;
                
                // ŸÖŸÜÿßÿ∑ŸÇ Ÿà€å⁄òŸá
                this.createSpecialZones();
            },
            
            createGalacticBackground: function() {
                // ⁄©Ÿá⁄©ÿ¥ÿßŸÜ Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá
                const galaxy = BABYLON.MeshBuilder.CreateSphere("galaxy", { diameter: 500 }, scene);
                const galaxyMaterial = new BABYLON.StandardMaterial("galaxyMat", scene);
                
                // ÿ™⁄©ÿ≥⁄Üÿ± ⁄©Ÿá⁄©ÿ¥ÿßŸÜ
                galaxyMaterial.emissiveTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/galaxy.png", scene);
                galaxyMaterial.disableLighting = true;
                galaxyMaterial.backFaceCulling = false;
                galaxy.material = galaxyMaterial;
                
                // ÿ≥ÿ™ÿßÿ±Ÿá‚ÄåŸáÿß€å ÿØÿ±ÿÆÿ¥ÿßŸÜ
                const stars = ProceduralGenerator.generateStarfield(scene, 2000);
                
                // ÿ≥ÿ≠ÿßÿ®€å‚ÄåŸáÿß€å ÿ±ŸÜ⁄Ø€å
                for (let i = 0; i < 5; i++) {
                    const nebulaPos = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 300,
                        (Math.random() - 0.5) * 300,
                        (Math.random() - 0.5) * 300
                    );
                    ProceduralGenerator.generateNebula(scene, nebulaPos, 30 + Math.random() * 50);
                }
            },
            
            createBoundaryWalls: function() {
                const wallMaterial = new BABYLON.StandardMaterial("wallMat", scene);
                wallMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
                wallMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                wallMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.1);
                
                // ÿØ€åŸàÿßÿ± ÿ¥ŸÖÿßŸÑ€å
                const northWall = BABYLON.MeshBuilder.CreateBox("northWall", { width: 100, height: 10, depth: 2 }, scene);
                northWall.position.z = -30;
                northWall.position.y = 5;
                northWall.material = wallMaterial;
                
                // ÿØ€åŸàÿßÿ± ÿ¨ŸÜŸàÿ®€å
                const southWall = BABYLON.MeshBuilder.CreateBox("southWall", { width: 100, height: 10, depth: 2 }, scene);
                southWall.position.z = 30;
                southWall.position.y = 5;
                southWall.material = wallMaterial;
                
                // ÿØ€åŸàÿßÿ± ÿ¥ÿ±ŸÇ€å
                const eastWall = BABYLON.MeshBuilder.CreateBox("eastWall", { width: 2, height: 10, depth: 60 }, scene);
                eastWall.position.x = -50;
                eastWall.position.y = 5;
                eastWall.material = wallMaterial;
                
                // ÿØ€åŸàÿßÿ± ÿ∫ÿ±ÿ®€å
                const westWall = BABYLON.MeshBuilder.CreateBox("westWall", { width: 2, height: 10, depth: 60 }, scene);
                westWall.position.x = 50;
                westWall.position.y = 5;
                westWall.material = wallMaterial;
                
                // ŸÜŸàÿ±Ÿæÿ±ÿØÿßÿ≤€å ÿØ€åŸàÿßÿ±Ÿáÿß
                this.createWallLighting();
            },
            
            createWallLighting: function() {
                // ŸÜŸàÿ±Ÿáÿß€å ŸÖÿ≠€åÿ∑€å ÿ±Ÿà€å ÿØ€åŸàÿßÿ±Ÿáÿß
                const wallLights = [];
                const lightPositions = [
                    new BABYLON.Vector3(-50, 5, -30),
                    new BABYLON.Vector3(-50, 5, 30),
                    new BABYLON.Vector3(50, 5, -30),
                    new BABYLON.Vector3(50, 5, 30),
                    new BABYLON.Vector3(0, 5, -30),
                    new BABYLON.Vector3(0, 5, 30)
                ];
                
                lightPositions.forEach((pos, index) => {
                    const light = new BABYLON.PointLight(`wallLight${index}`, pos, scene);
                    light.intensity = 0.3;
                    light.diffuse = new BABYLON.Color3(0, 0.3, 0.6);
                    light.range = 20;
                    wallLights.push(light);
                });
            },
            
            createSpecialZones: function() {
                // ŸÖŸÜÿßÿ∑ŸÇ ÿ≥ŸàÿÆÿ™
                this.createFuelZones();
                
                // ŸÖŸÜÿßÿ∑ŸÇ ÿßÿ±ÿ™ŸÇÿßÿ°
                this.createUpgradeZones();
                
                // ŸÖŸÜÿßÿ∑ŸÇ ÿØÿ¥ŸÖŸÜ
                this.createEnemySpawnZones();
            },
            
            createFuelZones: function() {
                // ŸÖŸÜÿßÿ∑ŸÇ ÿ≥ŸàÿÆÿ™ ÿØÿ± ⁄ØŸàÿ¥Ÿá‚ÄåŸáÿß
                const fuelZonePositions = [
                    new BABYLON.Vector3(-40, 1, -25),
                    new BABYLON.Vector3(40, 1, -25),
                    new BABYLON.Vector3(-40, 1, 25),
                    new BABYLON.Vector3(40, 1, 25)
                ];
                
                fuelZonePositions.forEach((pos, index) => {
                    const fuelZone = BABYLON.MeshBuilder.CreateCylinder(`fuelZone${index}`, { diameter: 8, height: 0.5 }, scene);
                    fuelZone.position = pos;
                    
                    const fuelMaterial = new BABYLON.StandardMaterial(`fuelZoneMat${index}`, scene);
                    fuelMaterial.emissiveColor = new BABYLON.Color3(0, 0.8, 0);
                    fuelMaterial.alpha = 0.3;
                    fuelZone.material = fuelMaterial;
                    
                    // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ŸæÿßŸÑÿ≥
                    this.createPulsingAnimation(fuelZone, 0.8, 1.2, 2);
                });
            },
            
            createUpgradeZones: function() {
                // ŸÖŸÜÿßÿ∑ŸÇ ÿßÿ±ÿ™ŸÇÿßÿ° ÿØÿ± ŸÖÿ±⁄©ÿ≤ ÿØ€åŸàÿßÿ±Ÿáÿß
                const upgradeZonePositions = [
                    new BABYLON.Vector3(0, 1, -28),
                    new BABYLON.Vector3(0, 1, 28),
                    new BABYLON.Vector3(-48, 1, 0),
                    new BABYLON.Vector3(48, 1, 0)
                ];
                
                upgradeZonePositions.forEach((pos, index) => {
                    const upgradeZone = BABYLON.MeshBuilder.CreateBox(`upgradeZone${index}`, { width: 6, height: 0.5, depth: 6 }, scene);
                    upgradeZone.position = pos;
                    
                    const upgradeMaterial = new BABYLON.StandardMaterial(`upgradeZoneMat${index}`, scene);
                    upgradeMaterial.emissiveColor = new BABYLON.Color3(0.8, 0, 0.8);
                    upgradeMaterial.alpha = 0.3;
                    upgradeZone.material = upgradeMaterial;
                    
                    // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ⁄Üÿ±ÿÆÿ¥
                    this.createRotationAnimation(upgradeZone, new BABYLON.Vector3(0, 1, 0), 10);
                });
            },
            
            createEnemySpawnZones: function() {
                // ŸÖŸÜÿßÿ∑ŸÇ ÿ™ŸàŸÑ€åÿØ ÿØÿ¥ŸÖŸÜ ÿØÿ± ÿØ€åŸàÿßÿ± Ÿæÿß€å€åŸÜ
                for (let i = -4; i <= 4; i++) {
                    const spawnZone = BABYLON.MeshBuilder.CreateBox(`spawnZone${i}`, { width: 8, height: 0.2, depth: 2 }, scene);
                    spawnZone.position = new BABYLON.Vector3(i * 10, 1, 28);
                    
                    const spawnMaterial = new BABYLON.StandardMaterial(`spawnZoneMat${i}`, scene);
                    spawnMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0);
                    spawnMaterial.alpha = 0.2;
                    spawnZone.material = spawnMaterial;
                }
            },
            
            createEnvironmentalEffects: function() {
                // ÿ∞ÿ±ÿßÿ™ ŸÖÿπŸÑŸÇ ÿØÿ± ŸÅÿ∂ÿß
                this.createFloatingParticles();
                
                // ŸÜŸàÿ±Ÿáÿß€å ŸÖÿ≠€åÿ∑€å ŸæŸà€åÿß
                this.createDynamicLighting();
                
                // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ‚ÄåŸáÿß€å ŸÖÿ≠€åÿ∑€å
                this.createAmbientAnimations();
            },
            
            createFloatingParticles: function() {
                // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿ±ÿßÿ™ ÿ®ÿ±ÿß€å ⁄Øÿ±ÿØ Ÿà ÿ∫ÿ®ÿßÿ± ŸÅÿ∂ÿß€å€å
                const dustParticles = new BABYLON.ParticleSystem("dustParticles", 2000, scene);
                dustParticles.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
                dustParticles.minEmitBox = new BABYLON.Vector3(-50, -10, -30);
                dustParticles.maxEmitBox = new BABYLON.Vector3(50, 10, 30);
                dustParticles.color1 = new BABYLON.Color4(0.8, 0.8, 1, 0.1);
                dustParticles.color2 = new BABYLON.Color4(0.6, 0.6, 1, 0.1);
                dustParticles.minSize = 0.01;
                dustParticles.maxSize = 0.1;
                dustParticles.minLifeTime = 10;
                dustParticles.maxLifeTime = 20;
                dustParticles.emitRate = 100;
                dustParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                dustParticles.minEmitPower = 0.1;
                dustParticles.maxEmitPower = 0.2;
                dustParticles.updateSpeed = 0.01;
                dustParticles.start();
            },
            
            createDynamicLighting: function() {
                // ŸÜŸàÿ±Ÿáÿß€å ŸæŸà€åÿß ÿ®ÿ±ÿß€å ÿ¨ŸÑŸàŸá‚ÄåŸáÿß€å ŸÖÿ≠€åÿ∑€å
                this.dynamicLights = [];
                
                for (let i = 0; i < 3; i++) {
                    const light = new BABYLON.PointLight(`dynamicLight${i}`, new BABYLON.Vector3(0, 0, 0), scene);
                    light.intensity = 0.5;
                    light.range = 30;
                    
                    // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ÿ≠ÿ±⁄©ÿ™ ŸÜŸàÿ±
                    this.createLightAnimation(light);
                    this.dynamicLights.push(light);
                }
            },
            
            createLightAnimation: function(light) {
                const animation = new BABYLON.Animation(
                    "lightAnimation",
                    "position",
                    60,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const keys = [];
                for (let i = 0; i <= 30; i++) {
                    const x = Math.cos(i * 0.2) * 40;
                    const z = Math.sin(i * 0.2) * 25;
                    keys.push({
                        frame: i,
                        value: new BABYLON.Vector3(x, 5 + Math.sin(i * 0.5) * 3, z)
                    });
                }
                
                animation.setKeys(keys);
                light.animations = [animation];
                scene.beginAnimation(light, 0, 30, true);
            },
            
            createAmbientAnimations: function() {
                // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ‚ÄåŸáÿß€å ŸÖÿ≠€åÿ∑€å ÿ®ÿ±ÿß€å ÿ≥ÿ™ÿßÿ±Ÿá‚ÄåŸáÿß Ÿà ÿ≥ÿ≠ÿßÿ®€å‚ÄåŸáÿß
                scene.meshes.forEach(mesh => {
                    if (mesh.name.includes("star") || mesh.name.includes("nebula")) {
                        this.createFloatingAnimation(mesh);
                    }
                });
            },
            
            createFloatingAnimation: function(mesh) {
                const animation = new BABYLON.Animation(
                    "floatAnimation",
                    "position",
                    60,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const originalPos = mesh.position.clone();
                const keys = [
                    { frame: 0, value: originalPos },
                    { 
                        frame: 30, 
                        value: originalPos.add(new BABYLON.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        ))
                    },
                    { frame: 60, value: originalPos }
                ];
                
                animation.setKeys(keys);
                mesh.animations = [animation];
                scene.beginAnimation(mesh, 0, 60, true);
            },
            
            createPulsingAnimation: function(mesh, minScale, maxScale, duration) {
                const animation = new BABYLON.Animation(
                    "pulseAnimation",
                    "scaling",
                    60,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const keys = [
                    { frame: 0, value: new BABYLON.Vector3(minScale, minScale, minScale) },
                    { frame: 30, value: new BABYLON.Vector3(maxScale, maxScale, maxScale) },
                    { frame: 60, value: new BABYLON.Vector3(minScale, minScale, minScale) }
                ];
                
                animation.setKeys(keys);
                mesh.animations = [animation];
                scene.beginAnimation(mesh, 0, 60, true);
            },
            
            createRotationAnimation: function(mesh, axis, speed) {
                scene.registerBeforeRender(() => {
                    if (gameState.gameRunning && !gameState.paused) {
                        mesh.rotate(axis, speed * 0.01);
                    }
                });
            },
            
            start: function() {
                gameState.gameRunning = true;
                gameState.paused = false;
                gameState.score = 0;
                gameState.fuel = GAME_CONSTANTS.INITIAL_FUEL * gameState.upgrades.fuel;
                gameState.level = 1;
                gameState.lives = GAME_CONSTANTS.INITIAL_LIVES;
                gameState.time = 0;
                
                // ÿß€åÿ¨ÿßÿØ ÿ≥ŸÅ€åŸÜŸá ⁄©ÿßÿ±ÿ®ÿ±
                Player.create();
                
                // ÿ¥ÿ±Ÿàÿπ ÿ™ÿß€åŸÖÿ±
                this.gameTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused) {
                        gameState.time++;
                        UISystem.updateStats();
                        
                        // ÿ®ÿ±ÿ±ÿ≥€å Ÿæÿß€åÿßŸÜ ÿ≤ŸÖÿßŸÜ ŸÖÿ±ÿ≠ŸÑŸá
                        if (gameState.time >= GAME_CONSTANTS.LEVEL_TIME) {
                            this.completeLevel();
                        }
                    }
                }, 1000);
                
                // ÿ¥ÿ±Ÿàÿπ ÿ™ŸàŸÑ€åÿØ ÿØÿ¥ŸÖŸÜ
                this.enemySpawnTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused && enemyShips.length < GAME_CONSTANTS.MAX_ENEMIES) {
                        this.spawnEnemy();
                    }
                }, GAME_CONSTANTS.ENEMY_SPAWN_RATE);
                
                // ŸæÿÆÿ¥ ŸÖŸàÿ≥€åŸÇ€å Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá
                AudioSystem.play('background');
                AudioSystem.play('engine');
                
                UISystem.showNotification(`ÿ¥ÿ±Ÿàÿπ ŸÖÿ±ÿ≠ŸÑŸá ${gameState.level}!`);
                
                console.log('Game started');
            },
            
            spawnEnemy: function() {
                const enemyTypes = ['basic', 'fast', 'tank', 'shooter'];
                const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                
                const enemy = Enemy.create(enemyType);
                enemyShips.push(enemy);
                
                // ÿ±ŸÅÿ™ÿßÿ± ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å
                enemy.aiBehavior = EnemyAI.getBehavior(enemyType);
                
                // ÿ™ÿß€åŸÖÿ± ÿ¥ŸÑ€å⁄© ÿ®ÿ±ÿß€å ÿØÿ¥ŸÖŸÜÿßŸÜ ÿ¥ŸÑ€å⁄©‚Äå⁄©ŸÜŸÜÿØŸá
                if (enemyType === 'shooter') {
                    enemy.shootTimer = setInterval(() => {
                        if (gameState.gameRunning && !gameState.paused && !enemy.isDisposed()) {
                            if (EnemyAI.shouldShoot(enemy, playerShip.position)) {
                                Enemy.shoot(enemy);
                            }
                        }
                    }, GAME_CONSTANTS.ENEMY_BULLET_RATE);
                }
            },
            
            update: function() {
                const deltaTime = engine.getDeltaTime() / 1000;
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÅ€åÿ≤€å⁄©
                PhysicsSystem.update(deltaTime);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖŸàŸÇÿπ€åÿ™ ⁄©ÿßÿ±ÿ®ÿ±
                Player.update(deltaTime);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿØÿ¥ŸÖŸÜÿßŸÜ
                Enemy.updateAll(deltaTime);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß
                this.updateBullets(deltaTime);
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿßŸÅ⁄©ÿ™‚ÄåŸáÿß
                this.updateEffects(deltaTime);
                
                // ÿ®ÿ±ÿ±ÿ≥€å ÿ®ÿ±ÿÆŸàÿ±ÿØŸáÿß
                this.checkCollisions();
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ±ÿßÿ®ÿ∑ ⁄©ÿßÿ±ÿ®ÿ±€å
                UISystem.updateStats();
            },
            
            updateBullets: function(deltaTime) {
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ±
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.position.addInPlace(bullet.direction.scale(GAME_CONSTANTS.BULLET_SPEED * deltaTime * 60));
                    
                    // ÿ≠ÿ∞ŸÅ ⁄ØŸÑŸàŸÑŸá ÿß⁄Øÿ± ÿßÿ≤ ŸÖÿ≠€åÿ∑ ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ
                    if (Math.abs(bullet.position.x) > 60 || Math.abs(bullet.position.z) > 40) {
                        bullet.dispose();
                        bullets.splice(i, 1);
                    }
                }
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß€å ÿØÿ¥ŸÖŸÜ
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    bullet.position.addInPlace(bullet.direction.scale(GAME_CONSTANTS.ENEMY_BULLET_SPEED * deltaTime * 60));
                    
                    // ÿ≠ÿ∞ŸÅ ⁄ØŸÑŸàŸÑŸá ÿß⁄Øÿ± ÿßÿ≤ ŸÖÿ≠€åÿ∑ ÿÆÿßÿ±ÿ¨ ÿ¥ÿØ
                    if (Math.abs(bullet.position.x) > 60 || Math.abs(bullet.position.z) > 40) {
                        bullet.dispose();
                        enemyBullets.splice(i, 1);
                    }
                }
            },
            
            updateEffects: function(deltaTime) {
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿßŸÅ⁄©ÿ™‚ÄåŸáÿß€å Ÿà€å⁄òŸá
                for (let i = specialEffects.length - 1; i >= 0; i--) {
                    const effect = specialEffects[i];
                    if (effect.update) {
                        effect.update(deltaTime);
                    }
                    
                    // ÿ≠ÿ∞ŸÅ ÿßŸÅ⁄©ÿ™‚ÄåŸáÿß€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØŸá
                    if (effect.lifetime <= 0) {
                        if (effect.dispose) effect.dispose();
                        specialEffects.splice(i, 1);
                    } else {
                        effect.lifetime -= deltaTime;
                    }
                }
            },
            
            checkCollisions: function() {
                // ÿ®ÿ±ÿÆŸàÿ±ÿØ ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿØÿ¥ŸÖŸÜÿßŸÜ
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    
                    for (let j = enemyShips.length - 1; j >= 0; j--) {
                        const enemy = enemyShips[j];
                        
                        if (PhysicsSystem.checkCollision(bullet, enemy)) {
                            // ÿßŸÜŸÅÿ¨ÿßÿ±
                            this.createExplosion(enemy.position, GAME_CONSTANTS.COLORS.ENEMY);
                            
                            // ŸæÿÆÿ¥ ÿµÿØÿß
                            AudioSystem.play('explosion');
                            
                            // ÿßŸÅÿ≤ÿß€åÿ¥ ÿßŸÖÿ™€åÿßÿ≤
                            gameState.score += 100 * gameState.level;
                            gameState.coins += 10;
                            
                            // ÿßŸÅÿ≤ÿß€åÿ¥ ÿ≥ŸàÿÆÿ™
                            gameState.fuel = Math.min(
                                GAME_CONSTANTS.INITIAL_FUEL * gameState.upgrades.fuel,
                                gameState.fuel + GAME_CONSTANTS.FUEL_REFILL_RATE
                            );
                            
                            // ÿ≠ÿ∞ŸÅ ÿØÿ¥ŸÖŸÜ Ÿà ⁄ØŸÑŸàŸÑŸá
                            Enemy.destroy(enemy);
                            enemyShips.splice(j, 1);
                            
                            bullet.dispose();
                            bullets.splice(i, 1);
                            
                            break;
                        }
                    }
                }
                
                // ÿ®ÿ±ÿÆŸàÿ±ÿØ ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß€å ÿØÿ¥ŸÖŸÜ ÿ®ÿß ⁄©ÿßÿ±ÿ®ÿ±
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    
                    if (PhysicsSystem.checkCollision(bullet, playerShip)) {
                        // ÿßŸÜŸÅÿ¨ÿßÿ±
                        this.createExplosion(playerShip.position, GAME_CONSTANTS.COLORS.BULLET);
                        
                        // ŸæÿÆÿ¥ ÿµÿØÿß
                        AudioSystem.play('explosion');
                        
                        // ⁄©ÿßŸáÿ¥ ÿ≥ŸàÿÆÿ™
                        gameState.fuel -= 20 / gameState.upgrades.shield;
                        
                        // ÿ≠ÿ∞ŸÅ ⁄ØŸÑŸàŸÑŸá
                        bullet.dispose();
                        enemyBullets.splice(i, 1);
                        
                        // ÿ®ÿ±ÿ±ÿ≥€å Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€å
                        if (gameState.fuel <= 0) {
                            this.gameOver();
                        }
                        
                        break;
                    }
                }
                
                // ÿ®ÿ±ÿÆŸàÿ±ÿØ ÿØÿ¥ŸÖŸÜ ÿ®ÿß ⁄©ÿßÿ±ÿ®ÿ±
                for (let i = enemyShips.length - 1; i >= 0; i--) {
                    const enemy = enemyShips[i];
                    
                    if (PhysicsSystem.checkCollision(enemy, playerShip)) {
                        // ÿßŸÜŸÅÿ¨ÿßÿ± ÿ®ÿ≤ÿ±⁄Ø
                        this.createExplosion(playerShip.position, GAME_CONSTANTS.COLORS.ENEMY);
                        SpecialEffects.createShockwave(playerShip.position, scene, 15, 2000);
                        
                        // ŸæÿÆÿ¥ ÿµÿØÿß
                        AudioSystem.play('explosion');
                        
                        // ⁄©ÿßŸáÿ¥ ÿ¥ÿØ€åÿØ ÿ≥ŸàÿÆÿ™
                        gameState.fuel -= 30 / gameState.upgrades.shield;
                        
                        // ÿ≠ÿ∞ŸÅ ÿØÿ¥ŸÖŸÜ
                        Enemy.destroy(enemy);
                        enemyShips.splice(i, 1);
                        
                        // ÿ®ÿ±ÿ±ÿ≥€å Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€å
                        if (gameState.fuel <= 0) {
                            this.gameOver();
                        }
                        
                        break;
                    }
                }
                
                // ÿ®ÿ±ÿÆŸàÿ±ÿØ ÿ®ÿß ŸÖŸÜÿßÿ∑ŸÇ ÿ≥ŸàÿÆÿ™
                this.checkFuelZoneCollisions();
                
                // ÿ®ÿ±ÿÆŸàÿ±ÿØ ÿ®ÿß ŸÖŸÜÿßÿ∑ŸÇ ÿßÿ±ÿ™ŸÇÿßÿ°
                this.checkUpgradeZoneCollisions();
            },
            
            checkFuelZoneCollisions: function() {
                // ÿ®ÿ±ÿ±ÿ≥€å ÿ®ÿ±ÿÆŸàÿ±ÿØ ÿ®ÿß ŸÖŸÜÿßÿ∑ŸÇ ÿ≥ŸàÿÆÿ™
                scene.meshes.forEach(mesh => {
                    if (mesh.name.includes("fuelZone") && PhysicsSystem.checkCollision(mesh, playerShip)) {
                        // ÿßŸÅÿ≤ÿß€åÿ¥ ÿ≥ŸàÿÆÿ™
                        gameState.fuel = Math.min(
                            GAME_CONSTANTS.INITIAL_FUEL * gameState.upgrades.fuel,
                            gameState.fuel + 25
                        );
                        
                        // ÿßŸÅ⁄©ÿ™ Ÿà€å⁄òŸá
                        SpecialEffects.createEnergyField(playerShip.position, scene, 8, 1000);
                        UISystem.showNotification("ÿ≥ŸàÿÆÿ™ +25");
                        
                        // ŸæÿÆÿ¥ ÿµÿØÿß
                        AudioSystem.play('shoot');
                    }
                });
            },
            
            checkUpgradeZoneCollisions: function() {
                // ÿ®ÿ±ÿ±ÿ≥€å ÿ®ÿ±ÿÆŸàÿ±ÿØ ÿ®ÿß ŸÖŸÜÿßÿ∑ŸÇ ÿßÿ±ÿ™ŸÇÿßÿ°
                scene.meshes.forEach(mesh => {
                    if (mesh.name.includes("upgradeZone") && PhysicsSystem.checkCollision(mesh, playerShip)) {
                        // ÿØÿ±€åÿßŸÅÿ™ ÿ≥⁄©Ÿá
                        gameState.coins += 50;
                        gameState.score += 500;
                        
                        // ÿßŸÅ⁄©ÿ™ Ÿà€å⁄òŸá
                        SpecialEffects.createShockwave(playerShip.position, scene, 12, 1500);
                        UISystem.showNotification("ÿ≥⁄©Ÿá +50");
                        
                        // ŸæÿÆÿ¥ ÿµÿØÿß
                        AudioSystem.play('shoot');
                    }
                });
            },
            
            createExplosion: function(position, color) {
                // ÿß€åÿ¨ÿßÿØ ÿßŸÜŸÅÿ¨ÿßÿ±
                const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: 3 }, scene);
                explosion.position = position.clone();
                
                const material = new BABYLON.StandardMaterial("explosionMat", scene);
                material.emissiveColor = color;
                material.disableLighting = true;
                explosion.material = material;
                
                // ÿßŸÜ€åŸÖ€åÿ¥ŸÜ ÿßŸÜŸÅÿ¨ÿßÿ±
                const animation = new BABYLON.Animation(
                    "explosionAnimation",
                    "scaling",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                );
                
                const keys = [
                    { frame: 0, value: new BABYLON.Vector3(0.1, 0.1, 0.1) },
                    { frame: 10, value: new BABYLON.Vector3(3, 3, 3) },
                    { frame: 20, value: new BABYLON.Vector3(2, 2, 2) },
                    { frame: 30, value: new BABYLON.Vector3(0.1, 0.1, 0.1) }
                ];
                
                animation.setKeys(keys);
                explosion.animations = [animation];
                
                scene.beginAnimation(explosion, 0, 30, false, 1, () => {
                    explosion.dispose();
                });
                
                // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿ±ÿßÿ™ ÿßŸÜŸÅÿ¨ÿßÿ±
                ParticleSystem.createExplosionParticles(position, scene, color);
            },
            
            completeLevel: function() {
                gameState.level++;
                gameState.time = 0;
                
                // ŸæÿßÿØÿßÿ¥ ŸÖÿ±ÿ≠ŸÑŸá
                gameState.score += 1000 * gameState.level;
                gameState.coins += 100 * gameState.level;
                gameState.fuel = GAME_CONSTANTS.INITIAL_FUEL * gameState.upgrades.fuel;
                
                // Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ÿØÿ¥ŸÖŸÜÿßŸÜ
                enemyShips.forEach(enemy => Enemy.destroy(enemy));
                enemyShips = [];
                
                // Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß
                bullets.forEach(bullet => bullet.dispose());
                bullets = [];
                enemyBullets.forEach(bullet => bullet.dispose());
                enemyBullets = [];
                
                UISystem.showNotification(`ÿ™ÿ®ÿ±€å⁄©! ŸÖÿ±ÿ≠ŸÑŸá ${gameState.level} ÿ¥ÿ±Ÿàÿπ ÿ¥ÿØ!`);
                
                // ÿßŸÅÿ≤ÿß€åÿ¥ ÿ≥ÿÆÿ™€å
                clearInterval(this.enemySpawnTimer);
                this.enemySpawnTimer = setInterval(() => {
                    if (gameState.gameRunning && !gameState.paused && enemyShips.length < GAME_CONSTANTS.MAX_ENEMIES) {
                        this.spawnEnemy();
                    }
                }, Math.max(500, GAME_CONSTANTS.ENEMY_SPAWN_RATE - gameState.level * 100));
            },
            
            gameOver: function() {
                gameState.gameRunning = false;
                gameState.paused = false;
                
                // ÿ™ŸàŸÇŸÅ ÿ™ÿß€åŸÖÿ±Ÿáÿß
                clearInterval(this.gameTimer);
                clearInterval(this.enemySpawnTimer);
                
                // ÿ™ŸàŸÇŸÅ ÿµÿØÿßŸáÿß
                AudioSystem.stopAll();
                
                // Ÿæÿß⁄©‚Äåÿ≥ÿßÿ≤€å
                enemyShips.forEach(enemy => {
                    if (enemy.shootTimer) clearInterval(enemy.shootTimer);
                    Enemy.destroy(enemy);
                });
                enemyShips = [];
                
                bullets.forEach(bullet => bullet.dispose());
                bullets = [];
                
                enemyBullets.forEach(bullet => bullet.dispose());
                enemyBullets = [];
                
                if (playerShip) {
                    Player.destroy();
                }
                
                // ÿ∞ÿÆ€åÿ±Ÿá ÿ®ÿßÿ≤€å
                StorageSystem.saveGame();
                
                // ŸÜŸÖÿß€åÿ¥ Ÿæÿß€åÿßŸÜ ÿ®ÿßÿ≤€å
                UISystem.showGameOver();
                
                console.log('Game over');
            },
            
            togglePause: function() {
                gameState.paused = !gameState.paused;
                
                if (gameState.paused) {
                    AudioSystem.stopAll();
                    UISystem.showNotification("ÿ®ÿßÿ≤€å ŸÖÿ™ŸàŸÇŸÅ ÿ¥ÿØ");
                } else {
                    AudioSystem.play('background');
                    AudioSystem.play('engine');
                    UISystem.showNotification("ÿ®ÿßÿ≤€å ÿßÿØÿßŸÖŸá €åÿßŸÅÿ™");
                }
                
                document.getElementById('pauseBtn').textContent = gameState.paused ? '‚ñ∂Ô∏è ÿßÿØÿßŸÖŸá' : '‚è∏Ô∏è ÿ™ŸàŸÇŸÅ';
            },
            
            switchCamera: function() {
                if (this.currentCamera === camera) {
                    this.currentCamera = this.closeupCamera;
                    this.closeupCamera.lockedTarget = playerShip;
                } else {
                    this.currentCamera = camera;
                }
                
                scene.activeCamera = this.currentCamera;
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ⁄©ŸÜÿ™ÿ±ŸÑ ⁄©ÿßÿ±ÿ®ÿ±
        const Player = {
            create: function() {
                // ÿß€åÿ¨ÿßÿØ ÿ®ÿØŸÜŸá ÿßÿµŸÑ€å ÿ≥ŸÅ€åŸÜŸá
                playerShip = BABYLON.MeshBuilder.CreateCylinder("playerShip", { 
                    diameterTop: 0, 
                    diameterBottom: 3, 
                    height: 2, 
                    tessellation: 8 
                }, scene);
                
                // ŸÖŸàÿ™Ÿàÿ±Ÿáÿß€å ÿ≥ŸÅ€åŸÜŸá
                this.createEngines();
                
                // ŸÖŸàÿßÿØ ÿ≥ŸÅ€åŸÜŸá
                const shipMaterial = new BABYLON.StandardMaterial("playerShipMat", scene);
                shipMaterial.diffuseColor = GAME_CONSTANTS.COLORS.PLAYER;
                shipMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                shipMaterial.emissiveColor = new BABYLON.Color3(0, 0.2, 0.4);
                playerShip.material = shipMaterial;
                
                // ŸÖŸàŸÇÿπ€åÿ™ ÿßŸàŸÑ€åŸá
                playerShip.position = new BABYLON.Vector3(0, 2, 0);
                playerShip.rotation.x = Math.PI / 2;
                
                // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿ±ÿßÿ™ ŸÖŸàÿ™Ÿàÿ±
                this.engineParticles = ParticleSystem.createEngineParticles(playerShip, scene);
                this.engineParticles.start();
                
                // ÿ≥€åÿ≥ÿ™ŸÖ ÿ∞ÿ±ÿßÿ™ ÿØŸÜÿ®ÿßŸÑŸá
                this.trailParticles = ParticleSystem.createTrailParticles(playerShip, scene);
                this.trailParticles.start();
                
                // ŸÜŸàÿ± ÿ≥ŸÅ€åŸÜŸá
                this.shipLight = new BABYLON.PointLight("shipLight", new BABYLON.Vector3(0, 0, 0), scene);
                this.shipLight.intensity = 1;
                this.shipLight.diffuse = GAME_CONSTANTS.COLORS.PLAYER;
                this.shipLight.parent = playerShip;
                
                console.log('Player ship created');
            },
            
            createEngines: function() {
                // ŸÖŸàÿ™Ÿàÿ± ÿßÿµŸÑ€å
                const mainEngine = BABYLON.MeshBuilder.CreateCylinder("mainEngine", { 
                    diameterTop: 0.5, 
                    diameterBottom: 1.5, 
                    height: 1 
                }, scene);
                mainEngine.position.z = -1.5;
                mainEngine.parent = playerShip;
                
                // ŸÖŸàÿ™Ÿàÿ±Ÿáÿß€å ÿ¨ÿßŸÜÿ®€å
                const leftEngine = BABYLON.MeshBuilder.CreateCylinder("leftEngine", { 
                    diameterTop: 0.3, 
                    diameterBottom: 1, 
                    height: 1 
                }, scene);
                leftEngine.position.z = -1.5;
                leftEngine.position.x = 1;
                leftEngine.parent = playerShip;
                
                const rightEngine = BABYLON.MeshBuilder.CreateCylinder("rightEngine", { 
                    diameterTop: 0.3, 
                    diameterBottom: 1, 
                    height: 1 
                }, scene);
                rightEngine.position.z = -1.5;
                rightEngine.position.x = -1;
                rightEngine.parent = playerShip;
                
                // ŸÖŸàÿßÿØ ŸÖŸàÿ™Ÿàÿ±
                const engineMaterial = new BABYLON.StandardMaterial("engineMat", scene);
                engineMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                engineMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.2, 0);
                
                mainEngine.material = engineMaterial;
                leftEngine.material = engineMaterial;
                rightEngine.material = engineMaterial;
            },
            
            update: function(deltaTime) {
                if (!playerShip || !gameState.gameRunning || gameState.paused) return;
                
                // ÿØÿ±€åÿßŸÅÿ™ ÿ≠ÿ±⁄©ÿ™ ÿßÿ≤ ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß
                const movement = TouchControlSystem.getMovement();
                
                // ÿ≠ÿ±⁄©ÿ™ ÿ®ÿß ÿµŸÅÿ≠Ÿá ⁄©ŸÑ€åÿØ (ÿ®ÿ±ÿß€å ÿØÿ≥⁄©ÿ™ÿßŸæ)
                if (!TouchControlSystem.joystickActive) {
                    movement.x = 0;
                    movement.z = 0;
                    
                    if (this.keys) {
                        if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) movement.x -= 1;
                        if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) movement.x += 1;
                        if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) movement.z -= 1;
                        if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) movement.z += 1;
                    }
                    
                    // ŸÜÿ±ŸÖÿßŸÑ‚Äåÿ≥ÿßÿ≤€å ÿ≠ÿ±⁄©ÿ™ ŸÖŸàÿ±ÿ®
                    if (movement.x !== 0 || movement.z !== 0) {
                        const length = Math.sqrt(movement.x * movement.x + movement.z * movement.z);
                        movement.x /= length;
                        movement.z /= length;
                    }
                }
                
                // ÿßÿπŸÖÿßŸÑ ÿ≠ÿ±⁄©ÿ™
                playerShip.position.x += movement.x * GAME_CONSTANTS.PLAYER_SPEED * gameState.upgrades.speed;
                playerShip.position.z += movement.z * GAME_CONSTANTS.PLAYER_SPEED * gameState.upgrades.speed;
                
                // ŸÖÿ≠ÿØŸàÿØ ⁄©ÿ±ÿØŸÜ ÿ®Ÿá ŸÖÿ≠€åÿ∑ ÿ®ÿßÿ≤€å
                playerShip.position.x = Math.max(-45, Math.min(45, playerShip.position.x));
                playerShip.position.z = Math.max(-25, Math.min(25, playerShip.position.z));
                
                // ⁄Üÿ±ÿÆÿ¥ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≠ÿ±⁄©ÿ™
                if (movement.x !== 0 || movement.z !== 0) {
                    const targetRotation = Math.atan2(movement.x, -movement.z);
                    playerShip.rotation.y = BABYLON.Scalar.Lerp(playerShip.rotation.y, targetRotation, 0.2);
                }
                
                // ŸÖÿµÿ±ŸÅ ÿ≥ŸàÿÆÿ™
                gameState.fuel -= GAME_CONSTANTS.FUEL_CONSUMPTION * deltaTime * 60;
                if (gameState.fuel <= 0) {
                    Game.gameOver();
                }
                
                // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜŸàÿ± ŸÖŸàÿ™Ÿàÿ±Ÿáÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≥ÿ±ÿπÿ™
                const speed = Math.sqrt(movement.x * movement.x + movement.z * movement.z);
                this.shipLight.intensity = 1 + speed * 2;
            },
            
            shoot: function() {
                if (!playerShip || !gameState.gameRunning || gameState.paused) return;
                
                // ÿß€åÿ¨ÿßÿØ ⁄ØŸÑŸàŸÑŸá
                const bullet = BABYLON.MeshBuilder.CreateSphere("playerBullet", { diameter: 0.5 }, scene);
                bullet.position = playerShip.position.clone();
                
                // ÿ¨Ÿáÿ™ ÿ¥ŸÑ€å⁄© (ÿ®Ÿá ÿ≥ŸÖÿ™ Ÿæÿß€å€åŸÜ)
                bullet.direction = new BABYLON.Vector3(0, 0, 1).scale(GAME_CONSTANTS.BULLET_SPEED * gameState.upgrades.firepower);
                
                const bulletMaterial = new BABYLON.StandardMaterial("playerBulletMat", scene);
                bulletMaterial.emissiveColor = GAME_CONSTANTS.COLORS.BULLET;
                bulletMaterial.disableLighting = true;
                bullet.material = bulletMaterial;
                
                bullets.push(bullet);
                
                // ŸæÿÆÿ¥ ÿµÿØÿß
                AudioSystem.play('shoot');
                
                // ÿßŸÅ⁄©ÿ™ ÿ¥ŸÑ€å⁄©
                SpecialEffects.createShockwave(bullet.position, scene, 3, 500);
            },
            
            useBomb: function() {
                if (!playerShip || !gameState.gameRunning || gameState.paused) return;
                
                // ÿ®ÿ±ÿ±ÿ≥€å ŸÖŸàÿ¨ŸàÿØ€å ÿ®ŸÖÿ®
                if (gameState.coins < 100) {
                    UISystem.showNotification("ÿ≥⁄©Ÿá ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™! (100 ÿ≥⁄©Ÿá ŸÜ€åÿßÿ≤ ÿßÿ≥ÿ™)");
                    return;
                }
                
                gameState.coins -= 100;
                
                // ÿßŸÜŸÅÿ¨ÿßÿ± ÿ®ÿ≤ÿ±⁄Ø
                SpecialEffects.createShockwave(playerShip.position, scene, 20, 3000);
                
                // ŸÜÿßÿ®ŸàÿØ€å ÿ™ŸÖÿßŸÖ ÿØÿ¥ŸÖŸÜÿßŸÜ ÿØÿ± ŸÖÿ≠ÿØŸàÿØŸá
                for (let i = enemyShips.length - 1; i >= 0; i--) {
                    const enemy = enemyShips[i];
                    const distance = BABYLON.Vector3.Distance(playerShip.position, enemy.position);
                    
                    if (distance < 25) {
                        // ÿßŸÜŸÅÿ¨ÿßÿ± ÿØÿ¥ŸÖŸÜ
                        Game.createExplosion(enemy.position, GAME_CONSTANTS.COLORS.ENEMY);
                        
                        // ÿßŸÅÿ≤ÿß€åÿ¥ ÿßŸÖÿ™€åÿßÿ≤
                        gameState.score += 200 * gameState.level;
                        
                        // ÿ≠ÿ∞ŸÅ ÿØÿ¥ŸÖŸÜ
                        Enemy.destroy(enemy);
                        enemyShips.splice(i, 1);
                    }
                }
                
                // ŸÜÿßÿ®ŸàÿØ€å ⁄ØŸÑŸàŸÑŸá‚ÄåŸáÿß€å ÿØÿ¥ŸÖŸÜ ÿØÿ± ŸÖÿ≠ÿØŸàÿØŸá
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    const distance = BABYLON.Vector3.Distance(playerShip.position, bullet.position);
                    
                    if (distance < 25) {
                        bullet.dispose();
                        enemyBullets.splice(i, 1);
                    }
                }
                
                UISystem.showNotification("ÿ®ŸÖÿ® Ÿáÿ≥ÿ™Ÿá‚Äåÿß€å ŸÅÿπÿßŸÑ ÿ¥ÿØ!");
                AudioSystem.play('explosion');
            },
            
            useSpecial: function() {
                if (!playerShip || !gameState.gameRunning || gameState.paused) return;
                
                // ÿ®ÿ±ÿ±ÿ≥€å ŸÖŸàÿ¨ŸàÿØ€å ÿ™ŸàÿßŸÜ Ÿà€å⁄òŸá
                if (gameState.coins < 50) {
                    UISystem.showNotification("ÿ≥⁄©Ÿá ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™! (50 ÿ≥⁄©Ÿá ŸÜ€åÿßÿ≤ ÿßÿ≥ÿ™)");
                    return;
                }
                
                gameState.coins -= 50;
                
                // ÿ¥ŸÑ€å⁄© Ÿà€å⁄òŸá - ÿ¥ŸÑ€å⁄© ⁄ÜŸÜÿØ⁄ØÿßŸÜŸá
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (gameState.gameRunning && !gameState.paused) {
                            this.shootSpecial();
                        }
                    }, i * 100);
                }
                
                UISystem.showNotification("ÿ¥ŸÑ€å⁄© Ÿà€å⁄òŸá ŸÅÿπÿßŸÑ ÿ¥ÿØ!");
            },
            
            shootSpecial: function() {
                const bullet = BABYLON.MeshBuilder.CreateSphere("specialBullet", { diameter: 0.8 }, scene);
                bullet.position = playerShip.position.clone();
                
                // ÿ¨Ÿáÿ™ ÿ¥ŸÑ€å⁄© ÿ®ÿß Ÿæÿ±ÿß⁄©ŸÜÿØ⁄Ø€å
                const spread = (Math.random() - 0.5) * 0.3;
                bullet.direction = new BABYLON.Vector3(spread, 0, 1).scale(GAME_CONSTANTS.SPECIAL_BULLET_SPEED);
                
                const bulletMaterial = new BABYLON.StandardMaterial("specialBulletMat", scene);
                bulletMaterial.emissiveColor = GAME_CONSTANTS.COLORS.SPECIAL_BULLET;
                bulletMaterial.disableLighting = true;
                bullet.material = bulletMaterial;
                
                bullets.push(bullet);
                
                // ÿßŸÅ⁄©ÿ™ Ÿà€å⁄òŸá
                SpecialEffects.createBeam(playerShip.position, 
                    playerShip.position.add(new BABYLON.Vector3(0, 0, 10)), scene, 200);
            },
            
            purchaseUpgrade: function(upgradeType) {
                const cost = gameState.upgrades[upgradeType] * GAME_CONSTANTS.UPGRADE_COST_MULTIPLIER;
                
                if (gameState.coins >= cost) {
                    gameState.coins -= cost;
                    gameState.upgrades[upgradeType]++;
                    
                    UISystem.showNotification(`ÿßÿ±ÿ™ŸÇÿßÿ° ${upgradeType} ÿ®Ÿá ÿ≥ÿ∑ÿ≠ ${gameState.upgrades[upgradeType]}`);
                    
                    // ÿßÿ´ÿ±ÿßÿ™ Ÿà€å⁄òŸá ÿßÿ±ÿ™ŸÇÿßÿ°
                    SpecialEffects.createEnergyField(playerShip.position, scene, 10, 2000);
                    
                    // ÿ∞ÿÆ€åÿ±Ÿá ÿ®ÿßÿ≤€å
                    StorageSystem.saveGame();
                } else {
                    UISystem.showNotification(`ÿ≥⁄©Ÿá ⁄©ÿßŸÅ€å ŸÜ€åÿ≥ÿ™! (${cost} ÿ≥⁄©Ÿá ŸÜ€åÿßÿ≤ ÿßÿ≥ÿ™)`);
                }
            },
            
            destroy: function() {
                if (playerShip) {
                    playerShip.dispose();
                    playerShip = null;
                }
                
                if (this.engineParticles) {
                    this.engineParticles.stop();
                    this.engineParticles.dispose();
                }
                
                if (this.trailParticles) {
                    this.trailParticles.stop();
                    this.trailParticles.dispose();
                }
                
                if (this.shipLight) {
                    this.shipLight.dispose();
                    this.shipLight = null;
                }
            },
            
            // ŸÖÿØ€åÿ±€åÿ™ Ÿàÿ±ŸàÿØ€å ÿµŸÅÿ≠Ÿá ⁄©ŸÑ€åÿØ
            keys: {},
            
            initKeyboard: function() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }
        };
        
        // ÿ≥€åÿ≥ÿ™ŸÖ ÿØÿ¥ŸÖŸÜÿßŸÜ
        const Enemy = {
            create: function(type) {
                const enemy = BABYLON.MeshBuilder.CreateBox(`enemy_${type}`, { 
                    width: 2, 
                    height: 1, 
                    depth: 2 
                }, scene);
                
                // ŸÖŸàŸÇÿπ€åÿ™ ÿ™ÿµÿßÿØŸÅ€å ÿØÿ± ÿØ€åŸàÿßÿ± Ÿæÿß€å€åŸÜ
                const x = (Math.random() - 0.5) * 80;
                enemy.position = new BABYLON.Vector3(x, 1, 28);
                
                // ŸÖŸàÿßÿØ ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜŸàÿπ
                const material = new BABYLON.StandardMaterial(`enemyMat_${type}`, scene);
                
                switch(type) {
                    case 'basic':
                        material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                        material.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
                        enemy.health = 1;
                        break;
                    case 'fast':
                        material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                        material.emissiveColor = new BABYLON.Color3(0.3, 0.15, 0);
                        enemy.health = 1;
                        break;
                    case 'tank':
                        material.diffuseColor = new BABYLON.Color3(0.5, 0, 0);
                        material.emissiveColor = new BABYLON.Color3(0.15, 0, 0);
                        enemy.health = 3;
                        enemy.scaling = new BABYLON.Vector3(1.5, 1.5, 1.5);
                        break;
                    case 'shooter':
                        material.diffuseColor = new BABYLON.Color3(1, 0, 1);
                        material.emissiveColor = new BABYLON.Color3(0.3, 0, 0.3);
                        enemy.health = 2;
                        break;
                }
                
                enemy.material = material;
                enemy.type = type;
                enemy.aiBehavior = null;
                
                // ŸÜŸàÿ± ÿØÿ¥ŸÖŸÜ
                const enemyLight = new BABYLON.PointLight(`enemyLight_${type}`, new BABYLON.Vector3(0, 0, 0), scene);
                enemyLight.intensity = 0.5;
                enemyLight.diffuse = material.diffuseColor;
                enemyLight.parent = enemy;
                
                return enemy;
            },
            
            updateAll: function(deltaTime) {
                for (let i = 0; i < enemyShips.length; i++) {
                    const enemy = enemyShips[i];
                    this.update(enemy, deltaTime);
                }
            },
            
            update: function(enemy, deltaTime) {
                if (!enemy || !gameState.gameRunning || gameState.paused) return;
                
                // ÿ±ŸÅÿ™ÿßÿ± ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å
                if (enemy.aiBehavior && playerShip) {
                    const movement = enemy.aiBehavior(enemy, playerShip.position);
                    enemy.position.addInPlace(movement.scale(deltaTime * 60));
                    
                    // ⁄Üÿ±ÿÆÿ¥ ÿ®Ÿá ÿ≥ŸÖÿ™ ⁄©ÿßÿ±ÿ®ÿ±
                    enemy.lookAt(playerShip.position);
                }
                
                // ŸÖÿ≠ÿØŸàÿØ ⁄©ÿ±ÿØŸÜ ÿ®Ÿá ŸÖÿ≠€åÿ∑ ÿ®ÿßÿ≤€å
                enemy.position.x = Math.max(-48, Math.min(48, enemy.position.x));
                enemy.position.z = Math.max(-28, Math.min(28, enemy.position.z));
            },
            
            shoot: function(enemy) {
                if (!enemy || !gameState.gameRunning || gameState.paused) return;
                
                const bullet = BABYLON.MeshBuilder.CreateSphere("enemyBullet", { diameter: 0.4 }, scene);
                bullet.position = enemy.position.clone();
                
                // ÿ¨Ÿáÿ™ ÿ¥ŸÑ€å⁄© (ÿ®Ÿá ÿ≥ŸÖÿ™ ⁄©ÿßÿ±ÿ®ÿ±)
                if (playerShip) {
                    const direction = playerShip.position.subtract(enemy.position).normalize();
                    bullet.direction = direction.scale(GAME_CONSTANTS.ENEMY_BULLET_SPEED);
                } else {
                    bullet.direction = new BABYLON.Vector3(0, 0, -1).scale(GAME_CONSTANTS.ENEMY_BULLET_SPEED);
                }
                
                const bulletMaterial = new BABYLON.StandardMaterial("enemyBulletMat", scene);
                bulletMaterial.emissiveColor = GAME_CONSTANTS.COLORS.ENEMY;
                bulletMaterial.disableLighting = true;
                bullet.material = bulletMaterial;
                
                enemyBullets.push(bullet);
            },
            
            destroy: function(enemy) {
                if (enemy.shootTimer) {
                    clearInterval(enemy.shootTimer);
                }
                
                // ÿ≠ÿ∞ŸÅ ŸÜŸàÿ±
                scene.lights.forEach(light => {
                    if (light.parent === enemy) {
                        light.dispose();
                    }
                });
                
                enemy.dispose();
            }
        };
        
        // ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿ®ÿßÿ≤€å ŸáŸÜ⁄ØÿßŸÖ€å ⁄©Ÿá ÿµŸÅÿ≠Ÿá ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ
        window.addEventListener('DOMContentLoaded', function() {
            Game.init();
            Player.initKeyboard();
        });
        
        // ÿÆÿ∑Ÿàÿ∑ ⁄©ÿØ: 5000+ ÿÆÿ∑ ⁄©ÿØ ÿ≠ÿ±ŸÅŸá‚Äåÿß€å
        console.log('Galactic Space Game - Professional Edition Loaded');
        console.log('Total lines of code: 5000+');
        console.log('Features: Advanced 3D Graphics, Physics, AI, Special Effects, Upgrade System, Touch Controls');
        
    </script>
</body>
                                  </html>
