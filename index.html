<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM STRIKE | بازی اکشن سه‌بعدی</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        /* UI Styles */
        #uiContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .hud-element {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 18px;
            font-weight: bold;
        }
        
        #healthBar {
            top: 20px;
            left: 20px;
            width: 300px;
            height: 30px;
            padding: 0;
            overflow: hidden;
        }
        
        #healthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            transition: width 0.3s ease;
        }
        
        #scoreDisplay {
            top: 20px;
            right: 20px;
            background: rgba(0, 100, 255, 0.8);
        }
        
        #ammoDisplay {
            bottom: 20px;
            right: 20px;
            background: rgba(255, 165, 0, 0.8);
        }
        
        #waveInfo {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(138, 43, 226, 0.8);
        }
        
        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            text-align: center;
            pointer-events: all;
        }
        
        .menu-button {
            background: linear-gradient(45deg, #00ff88, #0088ff);
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .menu-button:hover {
            transform: scale(1.1);
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 20px;
            overflow: hidden;
        }
        
        .loading-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0088ff);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>
        
        <div id="uiContainer">
            <div class="hud-element" id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div class="hud-element" id="scoreDisplay">امتیاز: 0</div>
            <div class="hud-element" id="ammoDisplay">خشاب: 30/150</div>
            <div class="hud-element" id="waveInfo">موج: 1 | ربات‌ها: 10</div>
            
            <div id="gameMenu" style="display: none;">
                <h2 style="margin-bottom: 30px; color: #00ff88;">QUANTUM STRIKE</h2>
                <button class="menu-button" onclick="game.startGame()">شروع بازی</button>
                <button class="menu-button" onclick="game.showSettings()">تنظیمات</button>
                <button class="menu-button" onclick="game.showControls()">کنترل‌ها</button>
            </div>
        </div>
        
        <div id="loadingScreen">
            <h1 style="color: #00ff88; margin-bottom: 30px;">QUANTUM STRIKE</h1>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
            <div id="loadingText">در حال بارگذاری...</div>
        </div>
    </div>

    <!-- Babylon.js Libraries -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materials/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTextures/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcesses/babylonjs.postProcesses.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <script>
        // =============================================
        // QUANTUM STRIKE - بازی اکشن سه‌بعدی کامل
        // =============================================

        class QuantumStrikeGame {
            constructor() {
                this.engine = null;
                this.scene = null;
                this.player = null;
                this.currentWave = 1;
                this.score = 0;
                this.isGameRunning = false;
                this.isPaused = false;
                
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.powerUps = [];
                
                this.initializeGame();
            }

            async initializeGame() {
                try {
                    this.showLoadingProgress(10, "در حال راه‌اندازی موتور بازی...");
                    
                    // Initialize Babylon.js engine
                    const canvas = document.getElementById("renderCanvas");
                    this.engine = new BABYLON.Engine(canvas, true, {
                        preserveDrawingBuffer: true,
                        stencil: true,
                        antialias: true
                    });

                    this.showLoadingProgress(20, "در حال ایجاد صحنه...");
                    await this.createScene();

                    this.showLoadingProgress(40, "در حال ساخت محیط...");
                    await this.createEnvironment();

                    this.showLoadingProgress(60, "در حال ایجاد بازیکن...");
                    await this.createPlayer();

                    this.showLoadingProgress(80, "در حال راه‌اندازی دشمنان...");
                    await this.setupEnemies();

                    this.showLoadingProgress(90, "در حال راه‌اندازی صداها...");
                    await this.setupAudio();

                    this.showLoadingProgress(100, "آماده!");
                    
                    setTimeout(() => {
                        this.hideLoadingScreen();
                        this.showMainMenu();
                    }, 1000);

                    this.setupGameLoop();

                } catch (error) {
                    console.error("خطا در راه‌اندازی بازی:", error);
                }
            }

            showLoadingProgress(percent, text) {
                document.getElementById('loadingFill').style.width = percent + '%';
                document.getElementById('loadingText').textContent = text;
            }

            hideLoadingScreen() {
                document.getElementById('loadingScreen').style.display = 'none';
            }

            showMainMenu() {
                document.getElementById('gameMenu').style.display = 'block';
            }

            async createScene() {
                // Create scene
                this.scene = new BABYLON.Scene(this.engine);
                this.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1.0);
                
                // Setup advanced lighting
                this.setupLighting();
                
                // Setup camera
                this.setupCamera();
                
                // Setup physics
                await this.setupPhysics();
                
                // Setup input
                this.setupInput();
                
                // Setup post-processing
                this.setupPostProcessing();
            }

            setupLighting() {
                // Main directional light (sun)
                this.sunLight = new BABYLON.DirectionalLight("sunLight", 
                    new BABYLON.Vector3(-1, -2, -1), this.scene);
                this.sunLight.intensity = 1.2;
                this.sunLight.shadowEnabled = true;
                
                // Shadow generator
                this.shadowGenerator = new BABYLON.ShadowGenerator(2048, this.sunLight);
                this.shadowGenerator.useBlurExponentialShadowMap = true;
                this.shadowGenerator.blurScale = 2;
                
                // Ambient light
                this.ambientLight = new BABYLON.HemisphericLight("ambientLight",
                    new BABYLON.Vector3(0, 1, 0), this.scene);
                this.ambientLight.intensity = 0.4;
                
                // Point lights for dynamic lighting
                this.setupPointLights();
            }

            setupPointLights() {
                this.pointLights = [];
                
                // Create colored point lights around the arena
                const colors = [
                    new BABYLON.Color3(1, 0.2, 0.2), // قرمز
                    new BABYLON.Color3(0.2, 1, 0.2), // سبز
                    new BABYLON.Color3(0.2, 0.2, 1), // آبی
                    new BABYLON.Color3(1, 1, 0.2)   // زرد
                ];
                
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const x = Math.cos(angle) * 25;
                    const z = Math.sin(angle) * 25;
                    
                    const light = new BABYLON.PointLight(`pointLight${i}`, 
                        new BABYLON.Vector3(x, 8, z), this.scene);
                    light.intensity = 0.8;
                    light.range = 30;
                    light.diffuse = colors[i];
                    light.specular = colors[i];
                    
                    this.pointLights.push(light);
                }
            }

            setupCamera() {
                // Third person follow camera
                this.camera = new BABYLON.FollowCamera("followCamera", 
                    new BABYLON.Vector3(0, 5, -12), this.scene);
                this.camera.radius = 12;
                this.camera.heightOffset = 4;
                this.camera.rotationOffset = 180;
                this.camera.cameraAcceleration = 0.1;
                this.camera.maxCameraSpeed = 5;
                this.camera.fov = 1.2;
                
                this.scene.activeCamera = this.camera;
            }

            async setupPhysics() {
                // Enable physics
                const gravity = new BABYLON.Vector3(0, -9.81, 0);
                this.havokPlugin = new BABYLON.HavokPlugin();
                this.scene.enablePhysics(gravity, this.havokPlugin);
            }

            setupInput() {
                this.inputMap = {};
                this.mousePosition = new BABYLON.Vector2(0, 0);
                
                // Keyboard input
                this.scene.onKeyboardObservable.add((kbInfo) => {
                    if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
                        this.inputMap[kbInfo.event.key.toLowerCase()] = true;
                    } else if (kbInfo.type === BABYLON.KeyboardEventTypes.KEYUP) {
                        this.inputMap[kbInfo.event.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse input
                this.scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                        this.mousePosition.x = pointerInfo.event.clientX;
                        this.mousePosition.y = pointerInfo.event.clientY;
                    }
                    
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                        if (this.isGameRunning && !this.isPaused) {
                            this.player.shoot();
                        }
                    }
                });
            }

            setupPostProcessing() {
                // Bloom effect for glowing objects
                this.bloomEffect = new BABYLON.BloomEffect("bloom", 2, 2);
                this.bloomEffect.threshold = 0.8;
                this.bloomEffect.weight = 1.0;
                
                // Depth of field
                this.dofEffect = new BABYLON.DepthOfFieldEffect(this.scene, {
                    blendMode: BABYLON.DepthOfFieldEffect.BLENDMODE_STANDARD,
                    focalLength: 0.1
                });
                
                // Create rendering pipeline
                this.postProcessPipeline = new BABYLON.DefaultRenderingPipeline(
                    "defaultPipeline", true, this.scene, [this.camera]
                );
                this.postProcessPipeline.bloomEnabled = true;
                this.postProcessPipeline.depthOfFieldEnabled = true;
                this.postProcessPipeline.samples = 4;
            }

            async createEnvironment() {
                // Create ground
                this.createGround();
                
                // Create arena walls
                this.createArenaWalls();
                
                // Create obstacles
                this.createObstacles();
                
                // Create skybox
                this.createSkybox();
                
                // Create ambient particles
                this.createAmbientParticles();
            }

            createGround() {
                // Main ground
                this.ground = BABYLON.MeshBuilder.CreateGround("ground", {
                    width: 100,
                    height: 100
                }, this.scene);
                
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", this.scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
                groundMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                
                // Add grid texture
                const gridTexture = new BABYLON.GridMaterial("gridMat", this.scene);
                gridTexture.mainColor = new BABYLON.Color3(0.2, 0.2, 0.3);
                gridTexture.lineColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                gridTexture.gridRatio = 1;
                gridTexture.majorUnitFrequency = 5;
                
                this.ground.material = gridTexture;
                
                // Physics for ground
                this.ground.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.ground, BABYLON.PhysicsImpostor.BoxImpostor, 
                    { mass: 0, restitution: 0.3 }, this.scene
                );
            }

            createArenaWalls() {
                this.walls = [];
                
                // Create 4 walls around the arena
                const wallPositions = [
                    { position: new BABYLON.Vector3(0, 5, -50), size: new BABYLON.Vector3(100, 10, 2) },
                    { position: new BABYLON.Vector3(0, 5, 50), size: new BABYLON.Vector3(100, 10, 2) },
                    { position: new BABYLON.Vector3(-50, 5, 0), size: new BABYLON.Vector3(2, 10, 100) },
                    { position: new BABYLON.Vector3(50, 5, 0), size: new BABYLON.Vector3(2, 10, 100) }
                ];
                
                wallPositions.forEach((wall, index) => {
                    const wallMesh = BABYLON.MeshBuilder.CreateBox(`wall${index}`, {
                        width: wall.size.x,
                        height: wall.size.y,
                        depth: wall.size.z
                    }, this.scene);
                    
                    wallMesh.position = wall.position;
                    
                    const wallMaterial = new BABYLON.StandardMaterial(`wallMat${index}`, this.scene);
                    wallMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.6);
                    wallMaterial.alpha = 0.8;
                    wallMesh.material = wallMaterial;
                    
                    // Physics
                    wallMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                        wallMesh, BABYLON.PhysicsImpostor.BoxImpostor,
                        { mass: 0, restitution: 0.5 }, this.scene
                    );
                    
                    this.walls.push(wallMesh);
                });
            }

            createObstacles() {
                this.obstacles = [];
                
                // Create various obstacles
                const obstacleConfigs = [
                    { type: 'box', position: new BABYLON.Vector3(20, 2, 20), size: new BABYLON.Vector3(4, 4, 4) },
                    { type: 'cylinder', position: new BABYLON.Vector3(-20, 2, -20), size: new BABYLON.Vector3(3, 4, 3) },
                    { type: 'box', position: new BABYLON.Vector3(15, 1, -15), size: new BABYLON.Vector3(6, 2, 6) },
                    { type: 'cylinder', position: new BABYLON.Vector3(-15, 3, 15), size: new BABYLON.Vector3(2, 6, 2) }
                ];
                
                obstacleConfigs.forEach((config, index) => {
                    let obstacle;
                    
                    if (config.type === 'box') {
                        obstacle = BABYLON.MeshBuilder.CreateBox(`obstacle${index}`, {
                            width: config.size.x,
                            height: config.size.y,
                            depth: config.size.z
                        }, this.scene);
                    } else {
                        obstacle = BABYLON.MeshBuilder.CreateCylinder(`obstacle${index}`, {
                            height: config.size.y,
                            diameter: config.size.x
                        }, this.scene);
                    }
                    
                    obstacle.position = config.position;
                    
                    const material = new BABYLON.StandardMaterial(`obstacleMat${index}`, this.scene);
                    material.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                    material.specularColor = new BABYLON.Color3(0.3, 0.2, 0.1);
                    obstacle.material = material;
                    
                    // Physics
                    obstacle.physicsImpostor = new BABYLON.PhysicsImpostor(
                        obstacle, config.type === 'box' ? 
                        BABYLON.PhysicsImpostor.BoxImpostor : BABYLON.PhysicsImpostor.CylinderImpostor,
                        { mass: 0, restitution: 0.4 }, this.scene
                    );
                    
                    this.obstacles.push(obstacle);
                });
            }

            createSkybox() {
                // Create a simple skybox
                const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000 }, this.scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", this.scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
                    "https://assets.babylonjs.com/textures/skybox", this.scene
                );
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skybox.material = skyboxMaterial;
            }

            createAmbientParticles() {
                // Create ambient particle system for atmosphere
                this.ambientParticleSystem = new BABYLON.ParticleSystem("ambientParticles", 2000, this.scene);
                
                this.ambientParticleSystem.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", this.scene);
                this.ambientParticleSystem.emitter = new BABYLON.Vector3(0, 0, 0);
                this.ambientParticleSystem.minEmitBox = new BABYLON.Vector3(-50, 5, -50);
                this.ambientParticleSystem.maxEmitBox = new BABYLON.Vector3(50, 20, 50);
                
                this.ambientParticleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 0.1);
                this.ambientParticleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 0.1);
                this.ambientParticleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
                
                this.ambientParticleSystem.minSize = 0.1;
                this.ambientParticleSystem.maxSize = 0.3;
                
                this.ambientParticleSystem.minLifeTime = 2;
                this.ambientParticleSystem.maxLifeTime = 4;
                
                this.ambientParticleSystem.emitRate = 100;
                this.ambientParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                
                this.ambientParticleSystem.direction1 = new BABYLON.Vector3(-0.5, -0.5, -0.5);
                this.ambientParticleSystem.direction2 = new BABYLON.Vector3(0.5, 0.5, 0.5);
                
                this.ambientParticleSystem.minAngularSpeed = 0;
                this.ambientParticleSystem.maxAngularSpeed = Math.PI;
                
                this.ambientParticleSystem.start();
            }

            async createPlayer() {
                this.player = new Player(this.scene, this);
                await this.player.initialize();
                
                // Set camera to follow player
                this.camera.lockedTarget = this.player.mesh;
            }

            async setupEnemies() {
                this.enemyManager = new EnemyManager(this.scene, this);
                await this.enemyManager.initialize();
            }

            async setupAudio() {
                this.audioManager = new AudioManager();
                await this.audioManager.initialize();
            }

            setupGameLoop() {
                // Main game loop
                this.engine.runRenderLoop(() => {
                    if (this.isGameRunning && !this.isPaused) {
                        const deltaTime = this.engine.getDeltaTime() / 1000;
                        this.update(deltaTime);
                    }
                    this.scene.render();
                });
            }

            update(deltaTime) {
                // Update player
                if (this.player) {
                    this.player.update(deltaTime);
                }
                
                // Update enemies
                if (this.enemyManager) {
                    this.enemyManager.update(deltaTime);
                }
                
                // Update bullets
                this.updateBullets(deltaTime);
                
                // Update particles
                this.updateParticles(deltaTime);
                
                // Update power-ups
                this.updatePowerUps(deltaTime);
                
                // Check game state
                this.checkGameState();
                
                // Update UI
                this.updateUI();
            }

            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    this.bullets[i].update(deltaTime);
                    
                    // Remove bullets that are too old
                    if (this.bullets[i].isExpired()) {
                        this.bullets[i].dispose();
                        this.bullets.splice(i, 1);
                    }
                }
            }

            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update(deltaTime);
                    
                    if (this.particles[i].isDead) {
                        this.particles[i].dispose();
                        this.particles.splice(i, 1);
                    }
                }
            }

            updatePowerUps(deltaTime) {
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    this.powerUps[i].update(deltaTime);
                    
                    if (this.powerUps[i].isExpired) {
                        this.powerUps[i].dispose();
                        this.powerUps.splice(i, 1);
                    }
                }
            }

            checkGameState() {
                // Check if player is dead
                if (this.player && this.player.health <= 0) {
                    this.gameOver();
                }
                
                // Check if wave is cleared
                if (this.enemyManager && this.enemyManager.getEnemyCount() === 0) {
                    this.nextWave();
                }
            }

            updateUI() {
                if (this.player) {
                    // Update health bar
                    const healthPercent = this.player.health / this.player.maxHealth;
                    document.getElementById('healthFill').style.width = (healthPercent * 100) + '%';
                    
                    // Update ammo display
                    document.getElementById('ammoDisplay').textContent = 
                        `خشاب: ${this.player.currentAmmo}/${this.player.totalAmmo}`;
                }
                
                // Update score
                document.getElementById('scoreDisplay').textContent = `امتیاز: ${this.score}`;
                
                // Update wave info
                document.getElementById('waveInfo').textContent = 
                    `موج: ${this.currentWave} | ربات‌ها: ${this.enemyManager ? this.enemyManager.getEnemyCount() : 0}`;
            }

            startGame() {
                this.isGameRunning = true;
                this.isPaused = false;
                this.currentWave = 1;
                this.score = 0;
                
                document.getElementById('gameMenu').style.display = 'none';
                
                // Reset player
                this.player.reset();
                
                // Start first wave
                this.enemyManager.startWave(this.currentWave);
                
                // Play background music
                this.audioManager.playBackgroundMusic();
            }

            nextWave() {
                this.currentWave++;
                this.enemyManager.startWave(this.currentWave);
                
                // Spawn power-up between waves
                this.spawnRandomPowerUp();
            }

            spawnRandomPowerUp() {
                const powerUpTypes = ['health', 'ammo', 'speed', 'damage'];
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                const position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 40,
                    2,
                    (Math.random() - 0.5) * 40
                );
                
                const powerUp = new PowerUp(this.scene, randomType, position);
                this.powerUps.push(powerUp);
            }

            gameOver() {
                this.isGameRunning = false;
                
                // Show game over menu
                this.showGameOverMenu();
                
                // Stop background music
                this.audioManager.stopBackgroundMusic();
            }

            showGameOverMenu() {
                const gameOverMenu = document.createElement('div');
                gameOverMenu.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    padding: 40px;
                    border-radius: 15px;
                    border: 3px solid #ff4444;
                    text-align: center;
                    color: white;
                    pointer-events: all;
                `;
                
                gameOverMenu.innerHTML = `
                    <h2 style="color: #ff4444; margin-bottom: 20px;">بازی پایان یافت!</h2>
                    <p style="margin-bottom: 20px; font-size: 18px;">امتیاز نهایی: ${this.score}</p>
                    <p style="margin-bottom: 30px; font-size: 16px;">بالاترین موج: ${this.currentWave}</p>
                    <button class="menu-button" onclick="this.parentElement.remove(); game.startGame()">دوباره شروع کن</button>
                    <button class="menu-button" onclick="this.parentElement.remove(); game.showMainMenu()">منوی اصلی</button>
                `;
                
                document.getElementById('uiContainer').appendChild(gameOverMenu);
            }

            showSettings() {
                // Settings menu implementation
                alert("منوی تنظیمات - این قسمت در نسخه کامل پیاده‌سازی می‌شود");
            }

            showControls() {
                // Controls menu implementation
                const controls = `
                    کنترل‌های بازی:
                    
                    حرکت: W, A, S, D
                    شلیک: کلیک چپ ماوس
                    دویدن: Shift
                    پرش: Space
                    تعویض سلاح: 1, 2, 3
                    reload: R
                    
                    هدف: از بین بردن تمام ربات‌های هر موج!
                `;
                alert(controls);
            }

            addScore(points) {
                this.score += points;
            }

            addParticle(particle) {
                this.particles.push(particle);
            }

            addBullet(bullet) {
                this.bullets.push(bullet);
            }
        }

        // ==================== PLAYER CLASS ====================
        class Player {
            constructor(scene, game) {
                this.scene = scene;
                this.game = game;
                this.mesh = null;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 0.1;
                this.jumpForce = 0.5;
                this.isGrounded = true;
                
                this.weapons = [];
                this.currentWeaponIndex = 0;
                this.currentAmmo = 30;
                this.totalAmmo = 150;
                
                this.animations = {};
            }

            async initialize() {
                await this.createModel();
                this.setupAnimations();
                this.setupPhysics();
                this.setupWeapons();
            }

            async createModel() {
                // Create player character
                this.mesh = BABYLON.MeshBuilder.CreateCapsule("player", {
                    height: 2,
                    radius: 0.4
                }, this.scene);
                
                this.mesh.position = new BABYLON.Vector3(0, 3, 0);
                
                // Create player material
                const material = new BABYLON.StandardMaterial("playerMat", this.scene);
                material.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1.0);
                material.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                material.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.3);
                this.mesh.material = material;
                
                // Add to shadow generator
                this.game.shadowGenerator.addShadowCaster(this.mesh);
            }

            setupAnimations() {
                // Setup animation groups for different states
                this.animations.idle = this.createIdleAnimation();
                this.animations.run = this.createRunAnimation();
                this.animations.jump = this.createJumpAnimation();
                this.animations.shoot = this.createShootAnimation();
                
                this.currentAnimation = this.animations.idle;
                this.currentAnimation.start(true);
            }

            createIdleAnimation() {
                const animationGroup = new BABYLON.AnimationGroup("idleAnim");
                // Add subtle breathing animation
                return animationGroup;
            }

            createRunAnimation() {
                const animationGroup = new BABYLON.AnimationGroup("runAnim");
                // Add running animation
                return animationGroup;
            }

            createJumpAnimation() {
                const animationGroup = new BABYLON.AnimationGroup("jumpAnim");
                // Add jumping animation
                return animationGroup;
            }

            createShootAnimation() {
                const animationGroup = new BABYLON.AnimationGroup("shootAnim");
                // Add shooting animation
                return animationGroup;
            }

            setupPhysics() {
                this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.mesh, BABYLON.PhysicsImpostor.CapsuleImpostor,
                    { mass: 1, friction: 0.5, restitution: 0.3 }, this.scene
                );
                
                // Collision detection
                this.mesh.physicsImpostor.registerOnPhysicsCollide(
                    this.scene.meshes.filter(m => m !== this.mesh),
                    this.onCollision.bind(this)
                );
            }

            onCollision(collider, collisionPoint) {
                // Handle collisions with enemies, bullets, etc.
                if (collider.transformNode.name.includes('enemy')) {
                    this.takeDamage(10);
                }
                
                if (collider.transformNode.name.includes('bullet')) {
                    this.takeDamage(5);
                }
            }

            setupWeapons() {
                this.weapons = [
                    new AssaultRifle(this.scene, this, this.game),
                    new Shotgun(this.scene, this, this.game),
                    new SniperRifle(this.scene, this, this.game)
                ];
            }

            update(deltaTime) {
                this.handleInput();
                this.updateAnimations();
                this.updateWeapon(deltaTime);
            }

            handleInput() {
                if (!this.game.inputMap) return;
                
                const moveVector = new BABYLON.Vector3(0, 0, 0);
                
                // Movement
                if (this.game.inputMap['w'] || this.game.inputMap['arrowup']) {
                    moveVector.z = 1;
                }
                if (this.game.inputMap['s'] || this.game.inputMap['arrowdown']) {
                    moveVector.z = -1;
                }
                if (this.game.inputMap['a'] || this.game.inputMap['arrowleft']) {
                    moveVector.x = -1;
                }
                if (this.game.inputMap['d'] || this.game.inputMap['arrowright']) {
                    moveVector.x = 1;
                }
                
                // Normalize movement vector
                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.scaleInPlace(this.speed);
                    
                    // Rotate player to face movement direction
                    const targetRotation = Math.atan2(moveVector.x, moveVector.z);
                    this.mesh.rotation.y = BABYLON.Scalar.Lerp(
                        this.mesh.rotation.y, targetRotation, 0.2
                    );
                }
                
                // Apply movement
                this.mesh.position.addInPlace(moveVector);
                
                // Jump
                if ((this.game.inputMap[' '] || this.game.inputMap['space']) && this.isGrounded) {
                    this.jump();
                }
                
                // Weapon switching
                if (this.game.inputMap['1']) {
                    this.switchWeapon(0);
                }
                if (this.game.inputMap['2']) {
                    this.switchWeapon(1);
                }
                if (this.game.inputMap['3']) {
                    this.switchWeapon(2);
                }
                
                // Reload
                if (this.game.inputMap['r']) {
                    this.reload();
                }
            }

            updateAnimations() {
                // Update animations based on player state
                // This is a simplified version - real implementation would be more complex
            }

            updateWeapon(deltaTime) {
                if (this.weapons[this.currentWeaponIndex]) {
                    this.weapons[this.currentWeaponIndex].update(deltaTime);
                }
            }

            jump() {
                if (this.isGrounded) {
                    this.mesh.physicsImpostor.applyImpulse(
                        new BABYLON.Vector3(0, this.jumpForce, 0),
                        this.mesh.getAbsolutePosition()
                    );
                    this.isGrounded = false;
                }
            }

            shoot() {
                if (this.currentAmmo > 0 && this.weapons[this.currentWeaponIndex]) {
                    this.weapons[this.currentWeaponIndex].shoot();
                    this.currentAmmo--;
                    
                    // Play shoot animation
                    this.animations.shoot.start(false);
                } else if (this.currentAmmo <= 0) {
                    // Auto-reload when out of ammo
                    this.reload();
                }
            }

            switchWeapon(index) {
                if (index >= 0 && index < this.weapons.length) {
                    this.currentWeaponIndex = index;
                    // Play weapon switch animation/sound
                }
            }

            reload() {
                if (this.totalAmmo > 0) {
                    const ammoNeeded = 30 - this.currentAmmo;
                    const ammoToReload = Math.min(ammoNeeded, this.totalAmmo);
                    
                    this.currentAmmo += ammoToReload;
                    this.totalAmmo -= ammoToReload;
                    
                    // Play reload animation/sound
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.health = Math.max(0, this.health);
                
                // Visual feedback
                this.flashDamage();
                
                // Audio feedback
                this.game.audioManager.playSound('player_hurt');
                
                if (this.health <= 0) {
                    this.die();
                }
            }

            flashDamage() {
                // Flash red when damaged
                const originalEmissive = this.mesh.material.emissiveColor.clone();
                this.mesh.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                
                setTimeout(() => {
                    this.mesh.material.emissiveColor = originalEmissive;
                }, 200);
            }

            heal(amount) {
                this.health = Math.min(this.health + amount, this.maxHealth);
            }

            addAmmo(amount) {
                this.totalAmmo += amount;
            }

            die() {
                // Play death animation
                // Show death effects
                this.game.audioManager.playSound('player_death');
            }

            reset() {
                this.health = this.maxHealth;
                this.currentAmmo = 30;
                this.totalAmmo = 150;
                this.mesh.position = new BABYLON.Vector3(0, 3, 0);
                this.mesh.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                this.mesh.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
            }
        }

        // ==================== WEAPON SYSTEM ====================
        class Weapon {
            constructor(scene, owner, game, config) {
                this.scene = scene;
                this.owner = owner;
                this.game = game;
                this.config = config;
                this.cooldown = 0;
                this.mesh = null;
            }

            update(deltaTime) {
                if (this.cooldown > 0) {
                    this.cooldown -= deltaTime;
                }
            }

            shoot() {
                if (this.cooldown > 0) return;
                
                this.cooldown = this.config.fireRate;
                
                this.createBullet();
                this.playMuzzleFlash();
                this.playShootSound();
            }

            createBullet() {
                const bullet = new Bullet(
                    this.scene,
                    this.owner.mesh.position.add(new BABYLON.Vector3(0, 1, 0)),
                    this.owner.mesh.forward.scale(-1), // Forward direction
                    this.config
                );
                
                this.game.addBullet(bullet);
            }

            playMuzzleFlash() {
                // Create muzzle flash particle effect
                const muzzleFlash = new ParticleEffect(this.scene, 10);
                muzzleFlash.emit(
                    this.owner.mesh.position.add(this.owner.mesh.forward.scale(-2).add(new BABYLON.Vector3(0, 1, 0))),
                    new BABYLON.Color3(1, 0.8, 0.2)
                );
                this.game.addParticle(muzzleFlash);
            }

            playShootSound() {
                this.game.audioManager.playSound('shoot');
            }
        }

        class AssaultRifle extends Weapon {
            constructor(scene, owner, game) {
                super(scene, owner, game, {
                    damage: 25,
                    fireRate: 0.1,
                    bulletSpeed: 50,
                    spread: 0.05
                });
            }
        }

        class Shotgun extends Weapon {
            constructor(scene, owner, game) {
                super(scene, owner, game, {
                    damage: 15,
                    fireRate: 0.8,
                    bulletSpeed: 40,
                    spread: 0.2,
                    pelletCount: 8
                });
            }
        }

        class SniperRifle extends Weapon {
            constructor(scene, owner, game) {
                super(scene, owner, game, {
                    damage: 100,
                    fireRate: 1.5,
                    bulletSpeed: 100,
                    spread: 0.01
                });
            }
        }

        // ==================== BULLET CLASS ====================
        class Bullet {
            constructor(scene, position, direction, config) {
                this.scene = scene;
                this.position = position.clone();
                this.direction = direction.clone();
                this.config = config;
                this.speed = config.bulletSpeed;
                this.lifetime = 3; // seconds
                this.age = 0;
                this.mesh = null;
                
                this.createMesh();
                this.setupPhysics();
            }

            createMesh() {
                this.mesh = BABYLON.MeshBuilder.CreateSphere("bullet", {
                    diameter: 0.1
                }, this.scene);
                
                this.mesh.position = this.position;
                
                const material = new BABYLON.StandardMaterial("bulletMat", this.scene);
                material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
                material.diffuseColor = new BABYLON.Color3(1, 0.7, 0);
                this.mesh.material = material;
            }

            setupPhysics() {
                this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.mesh, BABYLON.PhysicsImpostor.SphereImpostor,
                    { mass: 0.1, restitution: 0.3 }, this.scene
                );
                
                // Apply initial velocity
                const velocity = this.direction.scale(this.speed);
                this.mesh.physicsImpostor.setLinearVelocity(velocity);
                
                // Register collision
                this.mesh.physicsImpostor.registerOnPhysicsCollide(
                    this.scene.meshes.filter(m => !m.name.includes('bullet') && m !== this.mesh),
                    this.onCollision.bind(this)
                );
            }

            update(deltaTime) {
                this.age += deltaTime;
                
                // Add trail effect
                if (Math.random() < 0.3) {
                    this.addTrailParticle();
                }
            }

            onCollision(collider, collisionPoint) {
                // Handle bullet impact
                if (collider.transformNode.name.includes('enemy')) {
                    const enemy = this.scene.getMeshByName(collider.transformNode.name);
                    if (enemy && enemy.enemyInstance) {
                        enemy.enemyInstance.takeDamage(this.config.damage);
                    }
                }
                
                // Create impact effect
                this.createImpactEffect(collisionPoint);
                
                // Remove bullet
                this.dispose();
            }

            addTrailParticle() {
                const trail = new ParticleEffect(this.scene, 1);
                trail.emit(
                    this.mesh.position,
                    new BABYLON.Color3(1, 0.8, 0.2)
                );
                // Note: You'd need to add this to game's particle system
            }

            createImpactEffect(position) {
                const impact = new ParticleEffect(this.scene, 15);
                impact.emit(position, new BABYLON.Color3(1, 0.3, 0.1));
                // Add to game's particle system
            }

            isExpired() {
                return this.age >= this.lifetime;
            }

            dispose() {
                if (this.mesh) {
                    this.mesh.dispose();
                }
            }
        }

        // ==================== ENEMY MANAGER ====================
        class EnemyManager {
            constructor(scene, game) {
                this.scene = scene;
                this.game = game;
                this.enemies = [];
                this.currentWave = 0;
            }

            async initialize() {
                // Preload enemy models and assets
            }

            startWave(waveNumber) {
                this.currentWave = waveNumber;
                this.enemies = [];
                
                const enemyCount = 5 + waveNumber * 2;
                
                for (let i = 0; i < enemyCount; i++) {
                    this.spawnEnemy(waveNumber);
                }
            }

            spawnEnemy(waveNumber) {
                const spawnPosition = this.getRandomSpawnPosition();
                const enemyType = this.getEnemyTypeForWave(waveNumber);
                
                const enemy = new Enemy(this.scene, enemyType, spawnPosition, this.game);
                this.enemies.push(enemy);
            }

            getRandomSpawnPosition() {
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 10;
                
                return new BABYLON.Vector3(
                    Math.cos(angle) * distance,
                    2,
                    Math.sin(angle) * distance
                );
            }

            getEnemyTypeForWave(waveNumber) {
                if (waveNumber < 3) return 'drone';
                if (waveNumber < 6) return 'soldier';
                if (waveNumber < 10) return 'heavy';
                return 'boss';
            }

            update(deltaTime) {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    this.enemies[i].update(deltaTime);
                    
                    if (!this.enemies[i].isAlive) {
                        this.enemies.splice(i, 1);
                    }
                }
            }

            getEnemyCount() {
                return this.enemies.length;
            }
        }

        // ==================== ENEMY CLASS ====================
        class Enemy {
            constructor(scene, type, position, game) {
                this.scene = scene;
                this.type = type;
                this.position = position;
                this.game = game;
                this.mesh = null;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 0.05;
                this.damage = 10;
                this.isAlive = true;
                this.lastAttackTime = 0;
                
                this.initialize();
            }

            async initialize() {
                await this.createModel();
                this.setupPhysics();
                this.setupAI();
            }

            async createModel() {
                // Create enemy model based on type
                switch (this.type) {
                    case 'drone':
                        this.mesh = BABYLON.MeshBuilder.CreateSphere("enemy_drone", {
                            diameter: 1
                        }, this.scene);
                        this.health = 50;
                        this.maxHealth = 50;
                        this.speed = 0.08;
                        this.damage = 5;
                        break;
                        
                    case 'soldier':
                        this.mesh = BABYLON.MeshBuilder.CreateCapsule("enemy_soldier", {
                            height: 2,
                            radius: 0.4
                        }, this.scene);
                        this.health = 100;
                        this.maxHealth = 100;
                        this.speed = 0.06;
                        this.damage = 10;
                        break;
                        
                    case 'heavy':
                        this.mesh = BABYLON.MeshBuilder.CreateCylinder("enemy_heavy", {
                            height: 2.5,
                            diameter: 1.2
                        }, this.scene);
                        this.health = 200;
                        this.maxHealth = 200;
                        this.speed = 0.04;
                        this.damage = 20;
                        break;
                        
                    case 'boss':
                        this.mesh = BABYLON.MeshBuilder.CreateBox("enemy_boss", {
                            width: 3,
                            height: 3,
                            depth: 3
                        }, this.scene);
                        this.health = 500;
                        this.maxHealth = 500;
                        this.speed = 0.03;
                        this.damage = 30;
                        break;
                }
                
                this.mesh.position = this.position;
                this.mesh.enemyInstance = this;
                
                // Set material based on type
                const material = new BABYLON.StandardMaterial(`enemyMat_${this.type}`, this.scene);
                
                switch (this.type) {
                    case 'drone':
                        material.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
                        break;
                    case 'soldier':
                        material.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.8);
                        break;
                    case 'heavy':
                        material.diffuseColor = new BABYLON.Color3(0.3, 0.3, 1);
                        break;
                    case 'boss':
                        material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                        break;
                }
                
                material.emissiveColor = material.diffuseColor.scale(0.3);
                this.mesh.material = material;
                
                // Add to shadow generator
                this.game.shadowGenerator.addShadowCaster(this.mesh);
            }

            setupPhysics() {
                let impostorType;
                switch (this.type) {
                    case 'drone':
                        impostorType = BABYLON.PhysicsImpostor.SphereImpostor;
                        break;
                    case 'soldier':
                        impostorType = BABYLON.PhysicsImpostor.CapsuleImpostor;
                        break;
                    default:
                        impostorType = BABYLON.PhysicsImpostor.BoxImpostor;
                }
                
                this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.mesh, impostorType,
                    { mass: 1, restitution: 0.3 }, this.scene
                );
            }

            setupAI() {
                // Basic AI behavior
                this.aiState = 'chase'; // chase, attack, flee
                this.lastStateChange = 0;
            }

            update(deltaTime) {
                if (!this.isAlive) return;
                
                this.updateAI(deltaTime);
                this.updateMovement(deltaTime);
                this.checkHealth();
            }

            updateAI(deltaTime) {
                const player = this.game.player;
                if (!player) return;
                
                const distanceToPlayer = BABYLON.Vector3.Distance(
                    this.mesh.position, player.mesh.position
                );
                
                if (distanceToPlayer < 3) {
                    // Close enough to attack
                    this.aiState = 'attack';
                    this.attackPlayer();
                } else if (distanceToPlayer < 20) {
                    // Chase player
                    this.aiState = 'chase';
                } else {
                    // Wander around
                    this.aiState = 'wander';
                }
            }

            updateMovement(deltaTime) {
                if (this.aiState === 'chase' && this.game.player) {
                    const direction = this.game.player.mesh.position.subtract(this.mesh.position);
                    direction.y = 0;
                    direction.normalize();
                    
                    const movement = direction.scale(this.speed);
                    this.mesh.position.addInPlace(movement);
                    
                    // Rotate towards player
                    const targetRotation = Math.atan2(direction.x, direction.z);
                    this.mesh.rotation.y = BABYLON.Scalar.Lerp(
                        this.mesh.rotation.y, targetRotation, 0.1
                    );
                }
            }

            attackPlayer() {
                const currentTime = Date.now();
                if (currentTime - this.lastAttackTime > 1000) { // 1 second cooldown
                    if (this.game.player) {
                        this.game.player.takeDamage(this.damage);
                        this.lastAttackTime = currentTime;
                        
                        // Play attack sound
                        this.game.audioManager.playSound('enemy_attack');
                    }
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                
                // Visual feedback
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.die();
                }
            }

            flashDamage() {
                const originalEmissive = this.mesh.material.emissiveColor.clone();
                this.mesh.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                
                setTimeout(() => {
                    this.mesh.material.emissiveColor = originalEmissive;
                }, 100);
            }

            checkHealth() {
                // Show health bar or other indicators
            }

            die() {
                this.isAlive = false;
                
                // Add score
                let scoreValue = 0;
                switch (this.type) {
                    case 'drone': scoreValue = 100; break;
                    case 'soldier': scoreValue = 200; break;
                    case 'heavy': scoreValue = 500; break;
                    case 'boss': scoreValue = 2000; break;
                }
                this.game.addScore(scoreValue);
                
                // Play death effects
                this.createDeathEffects();
                
                // Spawn power-up with chance
                if (Math.random() < 0.2) { // 20% chance
                    this.spawnPowerUp();
                }
                
                // Remove mesh
                setTimeout(() => {
                    if (this.mesh) {
                        this.mesh.dispose();
                    }
                }, 2000);
                
                // Play death sound
                this.game.audioManager.playSound('enemy_death');
            }

            createDeathEffects() {
                // Create explosion particles
                const explosion = new ParticleEffect(this.scene, 30);
                explosion.emit(this.mesh.position, new BABYLON.Color3(1, 0.3, 0.1));
                this.game.addParticle(explosion);
                
                // Shake camera slightly
                this.shakeCamera(0.5);
            }

            shakeCamera(intensity) {
                const originalPosition = this.game.camera.position.clone();
                const shakeInterval = setInterval(() => {
                    this.game.camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                    this.game.camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                    this.game.camera.position.z = originalPosition.z + (Math.random() - 0.5) * intensity;
                }, 50);
                
                setTimeout(() => {
                    clearInterval(shakeInterval);
                    this.game.camera.position = originalPosition;
                }, 200);
            }

            spawnPowerUp() {
                const powerUpTypes = ['health', 'ammo'];
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                
                const powerUp = new PowerUp(this.scene, randomType, this.mesh.position.clone());
                this.game.powerUps.push(powerUp);
            }
        }

        // ==================== POWER-UP CLASS ====================
        class PowerUp {
            constructor(scene, type, position) {
                this.scene = scene;
                this.type = type;
                this.position = position;
                this.mesh = null;
                this.isExpired = false;
                this.lifetime = 10; // seconds
                this.age = 0;
                
                this.createMesh();
                this.setupPhysics();
            }

            createMesh() {
                // Create different meshes based on power-up type
                switch (this.type) {
                    case 'health':
                        this.mesh = BABYLON.MeshBuilder.CreateSphere("powerup_health", {
                            diameter: 1
                        }, this.scene);
                        break;
                    case 'ammo':
                        this.mesh = BABYLON.MeshBuilder.CreateBox("powerup_ammo", {
                            size: 1
                        }, this.scene);
                        break;
                    case 'speed':
                        this.mesh = BABYLON.MeshBuilder.CreateCylinder("powerup_speed", {
                            height: 1,
                            diameter: 1
                        }, this.scene);
                        break;
                    case 'damage':
                        this.mesh = BABYLON.MeshBuilder.CreateTorus("powerup_damage", {
                            diameter: 1,
                            thickness: 0.3
                        }, this.scene);
                        break;
                }
                
                this.mesh.position = this.position;
                
                // Create material
                const material = new BABYLON.StandardMaterial(`powerupMat_${this.type}`, this.scene);
                
                switch (this.type) {
                    case 'health':
                        material.diffuseColor = new BABYLON.Color3(0, 1, 0);
                        break;
                    case 'ammo':
                        material.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                        break;
                    case 'speed':
                        material.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
                        break;
                    case 'damage':
                        material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                        break;
                }
                
                material.emissiveColor = material.diffuseColor;
                this.mesh.material = material;
                
                // Add floating animation
                this.startFloatingAnimation();
            }

            setupPhysics() {
                this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.mesh, BABYLON.PhysicsImpostor.SphereImpostor,
                    { mass: 0, restitution: 0.5 }, this.scene
                );
                
                // Register collision with player
                this.mesh.physicsImpostor.registerOnPhysicsCollide(
                    [this.scene.getMeshByName('player')],
                    this.onPlayerCollision.bind(this)
                );
            }

            startFloatingAnimation() {
                // Simple floating animation
                const anim = new BABYLON.Animation(
                    "floatAnim",
                    "position.y",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const keys = [
                    { frame: 0, value: this.position.y },
                    { frame: 30, value: this.position.y + 0.5 },
                    { frame: 60, value: this.position.y }
                ];
                
                anim.setKeys(keys);
                this.mesh.animations = [anim];
                this.scene.beginAnimation(this.mesh, 0, 60, true);
                
                // Rotation animation
                const rotAnim = new BABYLON.Animation(
                    "rotateAnim",
                    "rotation.y",
                    30,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
                );
                
                const rotKeys = [
                    { frame: 0, value: 0 },
                    { frame: 60, value: Math.PI * 2 }
                ];
                
                rotAnim.setKeys(rotKeys);
                this.mesh.animations.push(rotAnim);
                this.scene.beginAnimation(this.mesh, 0, 60, true);
            }

            update(deltaTime) {
                this.age += deltaTime;
                
                // Blink when about to expire
                if (this.age > this.lifetime - 3) {
                    const blink = Math.sin(this.age * 10) > 0;
                    this.mesh.setEnabled(blink);
                }
                
                if (this.age >= this.lifetime) {
                    this.isExpired = true;
                }
            }

            onPlayerCollision(collider) {
                if (collider.transformNode.name === 'player' && this.game.player) {
                    this.applyEffect(this.game.player);
                    this.isExpired = true;
                }
            }

            applyEffect(player) {
                switch (this.type) {
                    case 'health':
                        player.heal(25);
                        break;
                    case 'ammo':
                        player.addAmmo(50);
                        break;
                    case 'speed':
                        // Temporary speed boost
                        const originalSpeed = player.speed;
                        player.speed *= 1.5;
                        setTimeout(() => {
                            player.speed = originalSpeed;
                        }, 10000);
                        break;
                    case 'damage':
                        // Temporary damage boost
                        // This would require modifying weapon damage
                        break;
                }
                
                // Play collection sound
                this.game.audioManager.playSound('powerup_collect');
                
                // Create collection effect
                this.createCollectionEffect();
            }

            createCollectionEffect() {
                const collectionEffect = new ParticleEffect(this.scene, 20);
                collectionEffect.emit(this.mesh.position, this.mesh.material.diffuseColor);
                this.game.addParticle(collectionEffect);
            }

            dispose() {
                if (this.mesh) {
                    this.mesh.dispose();
                }
            }
        }

        // ==================== PARTICLE EFFECT SYSTEM ====================
        class ParticleEffect {
            constructor(scene, count) {
                this.scene = scene;
                this.particles = [];
                this.isDead = false;
            }

            emit(position, color) {
                for (let i = 0; i < 15; i++) {
                    const particle = {
                        mesh: BABYLON.MeshBuilder.CreateSphere("particle", { diameter: 0.2 }, this.scene),
                        velocity: new BABYLON.Vector3(
                            (Math.random() - 0.5) * 4,
                            Math.random() * 3,
                            (Math.random() - 0.5) * 4
                        ),
                        lifetime: 1.0,
                        maxLifetime: 1.0
                    };
                    
                    particle.mesh.position = position.clone();
                    
                    const material = new BABYLON.StandardMaterial("particleMat", this.scene);
                    material.emissiveColor = color;
                    material.diffuseColor = color;
                    particle.mesh.material = material;
                    
                    this.particles.push(particle);
                }
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.lifetime -= deltaTime;
                    
                    if (particle.lifetime <= 0) {
                        particle.mesh.dispose();
                        this.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Update position
                    particle.mesh.position.addInPlace(particle.velocity.scale(deltaTime));
                    
                    // Update scale
                    const scale = particle.lifetime / particle.maxLifetime;
                    particle.mesh.scaling.set(scale, scale, scale);
                    
                    // Apply gravity
                    particle.velocity.y -= 9.81 * deltaTime * 0.5;
                }
                
                if (this.particles.length === 0) {
                    this.isDead = true;
                }
            }

            dispose() {
                this.particles.forEach(particle => {
                    if (particle.mesh) {
                        particle.mesh.dispose();
                    }
                });
                this.particles = [];
            }
        }

        // ==================== AUDIO MANAGER ====================
        class AudioManager {
            constructor() {
                this.sounds = new Map();
                this.backgroundMusic = null;
            }

            async initialize() {
                // In a real game, you would load actual audio files here
                // This is a placeholder implementation
                
                this.sounds.set('shoot', { play: () => console.log('Pew!') });
                this.sounds.set('player_hurt', { play: () => console.log('Ouch!') });
                this.sounds.set('player_death', { play: () => console.log('Game Over!') });
                this.sounds.set('enemy_attack', { play: () => console.log('Enemy attacks!') });
                this.sounds.set('enemy_death', { play: () => console.log('Enemy dies!') });
                this.sounds.set('powerup_collect', { play: () => console.log('Powerup!') });
            }

            playSound(name) {
                const sound = this.sounds.get(name);
                if (sound) {
                    sound.play();
                }
            }

            playBackgroundMusic() {
                console.log('Background music started');
                // Actual implementation would use Web Audio API
            }

            stopBackgroundMusic() {
                console.log('Background music stopped');
            }
        }

        // ==================== INITIALIZE GAME ====================
        let game;

        window.addEventListener('DOMContentLoaded', () => {
            game = new QuantumStrikeGame();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (game && game.engine) {
                game.engine.resize();
            }
        });

    </script>
</body>
  </html>
