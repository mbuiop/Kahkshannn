<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>پروتوتایپ: بازی شبیه کلش - دید از بالا (Babylon.js)</title>
  <style>
    html,body { height:100%; margin:0; padding:0; overflow:hidden; font-family: Tahoma, Arial, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action: none; display:block; }
    #ui { position: absolute; left: 12px; top: 12px; z-index: 10; background: rgba(255,255,255,0.85); padding:8px; border-radius:8px; }
    #ui button { margin:4px 0; width:140px; }
    #info { position: absolute; right: 12px; top: 12px; z-index: 10; background: rgba(0,0,0,0.4); color: #fff; padding:8px; border-radius:8px; }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="ui">
    <button id="addWallBtn">افزودن دیوار (براکت)</button>
    <button id="snapGridBtn">خاموش/روشن گرید</button>
    <button id="clearBtn">پاک کردن دیوارها</button>
  </div>
  <div id="info">نمای بالا — برای حرکت پینچ/درگ استفاده کنید.</div>

  <script>
    // ساده، خوانا و آماده برای گسترش
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});

    const createScene = function() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.92, 0.96, 1);

      // نور محیطی
      const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0,1,0), scene);
      hemi.intensity = 0.9;

      // دوربین از بالا (orthographic برای دید بازی از بالا)
      const camera = new BABYLON.ArcRotateCamera('cam', -Math.PI/2, 1.55, 60, new BABYLON.Vector3(0,0,0), scene);
      camera.attachControl(canvas, true);
      camera.upperRadiusLimit = 200;
      camera.lowerRadiusLimit = 10;
      // تبدیل به اورتوگرافیک
      camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
      const aspect = engine.getRenderWidth() / engine.getRenderHeight();
      const orthoSize = 30;
      camera.orthoLeft   = -orthoSize * aspect;
      camera.orthoRight  =  orthoSize * aspect;
      camera.orthoTop    =  orthoSize;
      camera.orthoBottom = -orthoSize;

      // زمین (صفحه بازی)
      const ground = BABYLON.MeshBuilder.CreateGround('ground',{width:120, height:120}, scene);
      const groundMat = new BABYLON.StandardMaterial('gmat', scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.87,0.87,0.77);
      ground.material = groundMat;

      // گرید بصری روی زمین (اختیاری)
      const grid = new BABYLON.GridMaterial('grid', scene);
      grid.majorUnitFrequency = 1;
      grid.gridRatio = 2;
      grid.backFaceCulling = false;
      grid.mainColor = new BABYLON.Color3(0.6,0.6,0.6);
      grid.lineColor = new BABYLON.Color3(0.85,0.85,0.85);
      grid.opacity = 0.7;
      // برای استفاده از GridMaterial باید آن را از افزونه بیاوریم — اگر نشد، فِیِلبک به material ساده
      try { ground.material = grid; } catch(e) { ground.material = groundMat; }

      // یک لایه برای قرار دادن دیوارها
      const walls = new BABYLON.TransformNode('wallsRoot', scene);

      // تابع ساخت یک بخش دیوار در مختصات شبکه
      const WALL_SIZE = 2;
      function createWall(x,z,rot=0) {
        const box = BABYLON.MeshBuilder.CreateBox(`wall_${x}_${z}_${Math.random().toString(36).slice(2,6)}`,
          {width:WALL_SIZE, depth:0.6, height:2.6}, scene);
        box.position = new BABYLON.Vector3(x, 1.3, z);
        box.rotation.y = rot;
        box.parent = walls;

        // متریال سنگی/آجر
        const mat = new BABYLON.StandardMaterial('wallMat', scene);
        mat.diffuseTexture = new BABYLON.Texture('https://i.imgur.com/6v5Z2rQ.jpg', scene);
        mat.diffuseTexture.uScale = 1;
        mat.diffuseTexture.vScale = 0.5;
        box.material = mat;

        // سایه سبک
        box.receiveShadows = true;
        return box;
      }

      // نمونه چیدمان اولیه — یک قلعه کوچک با چهار گوشه دیوار
      const basePositions = [
        {x:-6,z:-6},{x:-4,z:-6},{x:-2,z:-6},{x:0,z:-6},{x:2,z:-6},{x:4,z:-6},{x:6,z:-6},
        {x:6,z:-4},{x:6,z:-2},{x:6,z:0},{x:6,z:2},{x:6,z:4},{x:6,z:6},
        {x:4,z:6},{x:2,z:6},{x:0,z:6},{x:-2,z:6},{x:-4,z:6},{x:-6,z:6},
        {x:-6,z:4},{x:-6,z:2},{x:-6,z:0},{x:-6,z:-2},{x:-6,z:-4}
      ];
      basePositions.forEach(p => createWall(p.x, p.z));

      // یک ساختمان مرکزی ساده (خانه)
      const keep = BABYLON.MeshBuilder.CreateBox('keep',{width:4,depth:4,height:3.5},scene);
      keep.position = new BABYLON.Vector3(0,1.75,0);
      const keepMat = new BABYLON.StandardMaterial('keepMat', scene);
      keepMat.diffuseColor = new BABYLON.Color3(0.8,0.45,0.3);
      keep.material = keepMat;

      // تعامل: کلیک برای اضافه کردن دیوار روی نزدیک‌ترین خانه‌ی شبکه
      let snapGrid = true;
      function worldToGrid(v){
        const cell = 2; // اندازه سلول
        return { x: Math.round(v.x / cell) * cell, z: Math.round(v.z / cell) * cell };
      }

      const addBtn = document.getElementById('addWallBtn');
      addBtn.addEventListener('click', ()=>{
        // میانیاب نقطه‌ی جلوی دوربین
        const pick = scene.pick(scene.pointerX, scene.pointerY, mesh => mesh===ground);
        if(pick && pick.hit){
          const w = pick.pickedPoint;
          const g = snapGrid ? worldToGrid(w) : {x: w.x, z: w.z};
          createWall(g.x, g.z);
        }
      });

      document.getElementById('snapGridBtn').addEventListener('click', ()=>{
        snapGrid = !snapGrid;
        document.getElementById('snapGridBtn').innerText = snapGrid ? 'خاموش/روشن گرید' : 'خاموش/روشن گرید';
      });

      document.getElementById('clearBtn').addEventListener('click', ()=>{
        walls.getChildren().forEach(c => { if(c.dispose) c.dispose(); });
      });

      // کوچک‌سازی فعال/غیرفعال گرید بصری با کلید G
      window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='g') { ground.material = (ground.material === grid) ? groundMat : grid; } });

      return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(function(){
      scene.render();
    });

    window.addEventListener('resize', function(){
      engine.resize();
    });
  </script>
</body>
</html>
