<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ú©Ù‡Ú©Ø´Ø§Ù† ÙØ±Ø§Ø±ÛŒ - Ú¯Ø±Ø§ÙÛŒÚ© Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }
        #renderCanvas { 
            width: 100%; 
            height: 100%; 
            display: block;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 1000;
            font-size: 24px;
        }
        #gameUI {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            z-index: 1000;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(0, 150, 255, 0.8);
        }
        #score, #health, #gameStatus {
            margin-bottom: 10px;
            background: rgba(0, 20, 40, 0.7);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 150, 255, 0.5);
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 1000;
            font-size: 14px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 150, 255, 0.5);
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="loading">ğŸš€ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¬Ù‡Ø§Ù† Ø¨ÛŒâ€ŒÚ©Ø±Ø§Ù†...</div>
    
    <div id="gameUI">
        <div id="score">Ø§Ù…ØªÛŒØ§Ø²: 0</div>
        <div id="health">Ø³Ù„Ø§Ù…ØªÛŒ: 100%</div>
        <div id="gameStatus">ÙˆØ¶Ø¹ÛŒØª: ÙØ¹Ø§Ù„</div>
    </div>
    
    <div id="controls">
        <div>Ø­Ø±Ú©Øª: WASD ÛŒØ§ Arrow Keys</div>
        <div>Ø´Ù„ÛŒÚ©: Space ÛŒØ§ Gamepad A</div>
        <div>Ø³Ø±Ø¹Øª: Shift ÛŒØ§ Gamepad B</div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    
    <script>
        // ğŸ¬ Ù…ÙˆØªÙˆØ± Ø¨Ø§Ø²ÛŒ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
        class CinematicSpaceGame {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.engine = new BABYLON.Engine(this.canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                this.scene = new BABYLON.Scene(this.engine);
                
                // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒ
                this.score = 0;
                this.health = 100;
                this.gameActive = true;
                this.bullets = [];
                this.enemyBullets = [];
                this.coins = [];
                this.lastShotTime = 0;
                this.shotDelay = 200; // Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡ Ø¨ÛŒÙ† Ø´Ù„ÛŒÚ©â€ŒÙ‡Ø§
                this.boostActive = false;
                
                this.setupCinematicScene();
                this.createGalaxyEnvironment();
                this.createPlayerShip();
                this.createEnemies();
                this.createCoins();
                this.setupPostProcessing();
                this.setupUI();
                
                this.startGameLoop();
            }
            
            setupCinematicScene() {
                // Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ Ø¹Ù…ÛŒÙ‚
                this.scene.clearColor = new BABYLON.Color4(0.02, 0.03, 0.08, 1.0);
                this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                this.scene.fogDensity = 0.01;
                this.scene.fogColor = new BABYLON.Color3(0.05, 0.05, 0.1);
                
                // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                this.camera = new BABYLON.ArcRotateCamera(
                    "cinematicCamera", 
                    -Math.PI / 2, Math.PI / 3, 
                    25, 
                    BABYLON.Vector3.Zero(), 
                    this.scene
                );
                this.camera.attachControl(this.canvas, true);
                this.camera.fov = 0.8;
                this.camera.minZ = 0.1;
                this.camera.maxZ = 1000;
                
                // Ù†ÙˆØ±Ù¾Ø±Ø¯Ø§Ø²ÛŒ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                this.setupCinematicLighting();
            }
            
            setupCinematicLighting() {
                // Ù†ÙˆØ± Ø§ØµÙ„ÛŒ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                this.mainLight = new BABYLON.DirectionalLight(
                    "mainLight", 
                    new BABYLON.Vector3(-1, -2, -1), 
                    this.scene
                );
                this.mainLight.intensity = 1.2;
                this.mainLight.shadowEnabled = true;
                this.mainLight.shadowMinZ = 1;
                this.mainLight.shadowMaxZ = 50;
                
                // Ù†ÙˆØ± Ù…Ø­ÛŒØ·ÛŒ Ø±Ù†Ú¯ÛŒ
                const ambientLight = new BABYLON.HemisphericLight(
                    "ambientLight", 
                    new BABYLON.Vector3(0, 1, 0), 
                    this.scene
                );
                ambientLight.intensity = 0.3;
                ambientLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.3);
                ambientLight.diffuse = new BABYLON.Color3(0.3, 0.3, 0.8);
                
                // Ù†ÙˆØ± Ù†Ù‚Ø·Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÙ‡â€ŒÙ‡Ø§ÛŒ ÙˆÛŒÚ˜Ù‡
                this.engineLight = new BABYLON.PointLight(
                    "engineLight", 
                    new BABYLON.Vector3(0, 0, 0), 
                    this.scene
                );
                this.engineLight.intensity = 3;
                this.engineLight.diffuse = new BABYLON.Color3(0, 0.8, 1);
                this.engineLight.specular = new BABYLON.Color3(0.5, 0.8, 1);
            }
            
            createGalaxyEnvironment() {
                // Ú©Ù‡Ú©Ø´Ø§Ù† Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
                this.createStarfield();
                this.createNebulas();
                this.createAsteroidField();
                this.createBlackHoles();
            }
            
            createStarfield() {
                // Ø³ÛŒØ³ØªÙ… Ø°Ø±Ø§Øª Ø³ØªØ§Ø±Ú¯Ø§Ù†
                this.starParticleSystem = new BABYLON.ParticleSystem("stars", 10000, this.scene);
                this.starParticleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs.com/assets/Flare.png", this.scene);
                
                this.starParticleSystem.minEmitBox = new BABYLON.Vector3(-500, -500, -500);
                this.starParticleSystem.maxEmitBox = new BABYLON.Vector3(500, 500, 500);
                
                // Ø³ØªØ§Ø±Ú¯Ø§Ù† Ø±Ù†Ú¯Ø§Ø±Ù†Ú¯
                this.starParticleSystem.color1 = new BABYLON.Color4(1, 1, 1, 1);
                this.starParticleSystem.color2 = new BABYLON.Color4(0.8, 0.8, 1, 1);
                this.starParticleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);
                
                this.starParticleSystem.minSize = 0.1;
                this.starParticleSystem.maxSize = 0.4;
                this.starParticleSystem.emitRate = 500;
                this.starParticleSystem.minLifeTime = Number.MAX_SAFE_INTEGER;
                this.starParticleSystem.maxLifeTime = Number.MAX_SAFE_INTEGER;
                this.starParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                
                this.starParticleSystem.start();
            }
            
            createNebulas() {
                // Ø³Ø­Ø§Ø¨ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±Ù†Ú¯Ø§Ø±Ù†Ú¯
                const nebulaColors = [
                    new BABYLON.Color3(0.4, 0.1, 0.8), // Ø¨Ù†ÙØ´
                    new BABYLON.Color3(0.1, 0.3, 0.9), // Ø¢Ø¨ÛŒ
                    new BABYLON.Color3(0.8, 0.1, 0.4), // ØµÙˆØ±ØªÛŒ
                    new BABYLON.Color3(0.1, 0.8, 0.6)  // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ
                ];
                
                nebulaColors.forEach((color, index) => {
                    const nebula = BABYLON.MeshBuilder.CreateSphere(`nebula${index}`, {
                        diameter: 80 + Math.random() * 40,
                        segments: 32
                    }, this.scene);
                    
                    nebula.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 300,
                        (Math.random() - 0.5) * 200,
                        -200 - Math.random() * 200
                    );
                    
                    const nebulaMat = new BABYLON.StandardMaterial(`nebulaMat${index}`, this.scene);
                    nebulaMat.emissiveColor = color;
                    nebulaMat.diffuseColor = color;
                    nebulaMat.alpha = 0.03 + Math.random() * 0.02;
                    nebulaMat.specularColor = new BABYLON.Color3(0, 0, 0);
                    nebula.material = nebulaMat;
                });
            }
            
            createAsteroidField() {
                this.asteroids = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒØ¯Ø§Ù† Ø³ÛŒØ§Ø±Ú©â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ
                for (let i = 0; i < 100; i++) {
                    const size = 0.5 + Math.random() * 3;
                    const asteroid = BABYLON.MeshBuilder.CreateSphere(`asteroid${i}`, {
                        diameter: size,
                        segments: 6 + Math.floor(Math.random() * 6)
                    }, this.scene);
                    
                    // Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ Ø¯Ø± ÙØ¶Ø§
                    asteroid.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 400,
                        (Math.random() - 0.5) * 300,
                        -50 - Math.random() * 300
                    );
                    
                    // Ú†Ø±Ø®Ø´ ØªØµØ§Ø¯ÙÛŒ
                    asteroid.rotation = new BABYLON.Vector3(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    // Ù…ØªØ±ÛŒØ§Ù„ Ø³ÛŒØ§Ø±Ú© ÙˆØ§Ù‚Ø¹ÛŒ
                    const asteroidMat = new BABYLON.PBRMetallicRoughnessMaterial(`asteroidMat${i}`, this.scene);
                    asteroidMat.baseColor = new BABYLON.Color3(0.3 + Math.random() * 0.3, 0.2 + Math.random() * 0.2, 0.1 + Math.random() * 0.1);
                    asteroidMat.metallic = 0.1 + Math.random() * 0.3;
                    asteroidMat.roughness = 0.7 + Math.random() * 0.3;
                    asteroid.material = asteroidMat;
                    
                    this.asteroids.push({
                        mesh: asteroid,
                        rotationSpeed: new BABYLON.Vector3(
                            (Math.random() - 0.5) * 0.01,
                            (Math.random() - 0.5) * 0.01,
                            (Math.random() - 0.5) * 0.01
                        ),
                        size: size
                    });
                }
            }
            
            createBlackHoles() {
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³ÛŒØ§Ù‡Ú†Ø§Ù„Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø±Ù…ÙˆØ²
                for (let i = 0; i < 3; i++) {
                    const blackHole = BABYLON.MeshBuilder.CreateSphere(`blackHole${i}`, {
                        diameter: 15 + Math.random() * 10,
                        segments: 32
                    }, this.scene);
                    
                    blackHole.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 150,
                        -150 - Math.random() * 100
                    );
                    
                    const blackHoleMat = new BABYLON.PBRMetallicRoughnessMaterial(`blackHoleMat${i}`, this.scene);
                    blackHoleMat.baseColor = new BABYLON.Color3(0.02, 0.02, 0.02);
                    blackHoleMat.metallic = 0.9;
                    blackHoleMat.roughness = 0.1;
                    blackHoleMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.3);
                    blackHole.material = blackHoleMat;
                    
                    // Ù†ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø³ÛŒØ§Ù‡Ú†Ø§Ù„Ù‡
                    const blackHoleLight = new BABYLON.PointLight(`blackHoleLight${i}`, blackHole.position, this.scene);
                    blackHoleLight.diffuse = new BABYLON.Color3(0.1, 0.1, 0.5);
                    blackHoleLight.intensity = 2;
                    blackHoleLight.radius = 30;
                }
            }
            
            createPlayerShip() {
                // ğŸš€ Ø¬Ù†Ú¯Ù†Ø¯Ù‡ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                this.playerShip = new BABYLON.TransformNode("playerShip");
                
                // Ø¨Ø¯Ù†Ù‡ Ø§ØµÙ„ÛŒ ÙÙ„Ø²ÛŒ
                const fuselage = BABYLON.MeshBuilder.CreateCylinder("fuselage", {
                    diameterTop: 0.8,
                    diameterBottom: 1.5,
                    height: 4,
                    tessellation: 16
                }, this.scene);
                fuselage.parent = this.playerShip;
                fuselage.rotation.x = Math.PI / 2;
                
                const fuselageMat = new BABYLON.PBRMetallicRoughnessMaterial("fuselageMat", this.scene);
                fuselageMat.baseColor = new BABYLON.Color3(0.1, 0.2, 0.4);
                fuselageMat.metallic = 0.9;
                fuselageMat.roughness = 0.1;
                fuselageMat.emissiveColor = new BABYLON.Color3(0, 0.1, 0.3);
                fuselage.material = fuselageMat;
                
                // Ú©Ø§Ø¨ÛŒÙ† Ø´ÛŒØ´Ù‡â€ŒØ§ÛŒ
                const cockpit = BABYLON.MeshBuilder.CreateSphere("cockpit", {
                    diameter: 1.2,
                    segments: 16
                }, this.scene);
                cockpit.parent = this.playerShip;
                cockpit.position.z = 0.8;
                
                const cockpitMat = new BABYLON.PBRMetallicRoughnessMaterial("cockpitMat", this.scene);
                cockpitMat.baseColor = new BABYLON.Color3(0.3, 0.5, 0.8);
                cockpitMat.metallic = 0.3;
                cockpitMat.roughness = 0.05;
                cockpitMat.alpha = 0.7;
                cockpit.material = cockpitMat;
                
                // Ø¨Ø§Ù„Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ù†Ø¨ÛŒ
                const leftWing = BABYLON.MeshBuilder.CreateBox("leftWing", {
                    width: 3, height: 0.3, depth: 1.2
                }, this.scene);
                leftWing.parent = this.playerShip;
                leftWing.position.set(-1.5, 0, -0.8);
                
                const rightWing = leftWing.clone("rightWing");
                rightWing.position.set(1.5, 0, -0.8);
                
                // Ù…ÙˆØªÙˆØ±Ù‡Ø§ Ø¨Ø§ Ù†ÙˆØ±
                this.createEngines();
                
                // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø­Ø±Ú©Øª
                this.playerVelocity = new BABYLON.Vector3(0, 0, 0);
                this.moveSpeed = 0.15;
                this.boostSpeed = 0.3;
            }
            
            createEngines() {
                // Ø¨Ø¯Ù†Ù‡ Ù…ÙˆØªÙˆØ±Ù‡Ø§
                const leftEngine = BABYLON.MeshBuilder.CreateCylinder("leftEngine", {
                    diameter: 0.6,
                    height: 1.5,
                    tessellation: 12
                }, this.scene);
                leftEngine.parent = this.playerShip;
                leftEngine.position.set(-0.8, 0, -1.8);
                leftEngine.rotation.x = Math.PI / 2;
                
                const rightEngine = leftEngine.clone("rightEngine");
                rightEngine.position.set(0.8, 0, -1.8);
                
                // Ù†ÙˆØ± Ù…ÙˆØªÙˆØ±Ù‡Ø§
                this.leftEngineLight = new BABYLON.PointLight("leftEngineLight", 
                    new BABYLON.Vector3(-0.8, 0, -2.2), this.scene);
                this.leftEngineLight.diffuse = new BABYLON.Color3(1, 0.4, 0.1);
                this.leftEngineLight.intensity = 2;
                
                this.rightEngineLight = new BABYLON.PointLight("rightEngineLight", 
                    new BABYLON.Vector3(0.8, 0, -2.2), this.scene);
                this.rightEngineLight.diffuse = new BABYLON.Color3(1, 0.4, 0.1);
                this.rightEngineLight.intensity = 2;
                
                // Ø³ÛŒØ³ØªÙ… Ø°Ø±Ø§Øª Ø´Ø¹Ù„Ù‡ Ù…ÙˆØªÙˆØ±
                this.createEngineParticles();
            }
            
            createEngineParticles() {
                this.engineParticleSystem = new BABYLON.ParticleSystem("engineParticles", 200, this.scene);
                this.engineParticleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs.com/assets/Flare.png", this.scene);
                
                this.engineParticleSystem.emitter = new BABYLON.Vector3(0, 0, -2);
                this.engineParticleSystem.minEmitBox = new BABYLON.Vector3(-0.8, -0.1, -0.1);
                this.engineParticleSystem.maxEmitBox = new BABYLON.Vector3(0.8, 0.1, 0.1);
                
                this.engineParticleSystem.color1 = new BABYLON.Color4(1, 1, 0, 1);
                this.engineParticleSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1);
                this.engineParticleSystem.colorDead = new BABYLON.Color4(0.5, 0, 0, 0);
                
                this.engineParticleSystem.minSize = 0.1;
                this.engineParticleSystem.maxSize = 0.3;
                this.engineParticleSystem.minLifeTime = 0.3;
                this.engineParticleSystem.maxLifeTime = 0.8;
                this.engineParticleSystem.emitRate = 300;
                this.engineParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                
                this.engineParticleSystem.start();
                this.engineParticleSystem.emitter = this.playerShip;
            }
            
            createEnemies() {
                this.enemies = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù†Ø§Ù† Ù…Ø®ØªÙ„Ù
                for (let i = 0; i < 8; i++) {
                    this.spawnEnemy(i);
                }
            }
            
            spawnEnemy(index) {
                const type = Math.random() > 0.5 ? "fighter" : "scout";
                const size = type === "fighter" ? 1.5 : 1;
                const color = type === "fighter" ? new BABYLON.Color3(1, 0.3, 0.3) : new BABYLON.Color3(1, 0.6, 0.2);
                
                const enemy = BABYLON.MeshBuilder.CreateSphere(`enemy${index}`, {
                    diameter: size,
                    segments: 12
                }, this.scene);
                
                enemy.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 30,
                    -30 - Math.random() * 50
                );
                
                const enemyMat = new BABYLON.PBRMetallicRoughnessMaterial(`enemyMat${index}`, this.scene);
                enemyMat.baseColor = color;
                enemyMat.metallic = 0.7;
                enemyMat.roughness = 0.3;
                enemyMat.emissiveColor = color;
                enemy.material = enemyMat;
                
                // Ù†ÙˆØ± Ø¯Ø´Ù…Ù†
                const enemyLight = new BABYLON.PointLight(`enemyLight${index}`, enemy.position, this.scene);
                enemyLight.diffuse = color;
                enemyLight.intensity = 1;
                enemyLight.parent = enemy;
                
                this.enemies.push({
                    mesh: enemy,
                    light: enemyLight,
                    type: type,
                    speed: 0.02 + Math.random() * 0.03,
                    health: type === "fighter" ? 60 : 30,
                    lastShotTime: 0,
                    shotDelay: 1500 + Math.random() * 1000
                });
            }
            
            createCoins() {
                this.coins = [];
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø±Ø®Ø´Ø§Ù†
                for (let i = 0; i < 20; i++) {
                    const coin = BABYLON.MeshBuilder.CreateSphere(`coin${i}`, {
                        diameter: 0.5,
                        segments: 16
                    }, this.scene);
                    
                    coin.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 40,
                        -20 - Math.random() * 80
                    );
                    
                    const coinMat = new BABYLON.PBRMetallicRoughnessMaterial(`coinMat${i}`, this.scene);
                    coinMat.baseColor = new BABYLON.Color3(1, 0.84, 0);
                    coinMat.metallic = 1.0;
                    coinMat.roughness = 0.1;
                    coinMat.emissiveColor = new BABYLON.Color3(1, 0.9, 0.3);
                    coin.material = coinMat;
                    
                    // Ù†ÙˆØ± Ø³Ú©Ù‡
                    const coinLight = new BABYLON.PointLight(`coinLight${i}`, coin.position, this.scene);
                    coinLight.diffuse = new BABYLON.Color3(1, 0.9, 0.3);
                    coinLight.intensity = 1.5;
                    coinLight.parent = coin;
                    
                    this.coins.push({
                        mesh: coin,
                        light: coinLight,
                        rotationSpeed: 0.02
                    });
                }
            }
            
            setupPostProcessing() {
                // Ø§ÙÚ©Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø³Øª-Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                if (BABYLON.DefaultRenderingPipeline) {
                    const pipeline = new BABYLON.DefaultRenderingPipeline(
                        "defaultPipeline", 
                        true, 
                        this.scene, 
                        [this.camera]
                    );
                    
                    pipeline.bloomEnabled = true;
                    pipeline.bloomThreshold = 0.8;
                    pipeline.bloomWeight = 0.3;
                    pipeline.bloomKernel = 64;
                    pipeline.bloomScale = 0.5;
                    
                    pipeline.chromaticAberrationEnabled = true;
                    pipeline.chromaticAberration.aberrationAmount = 0.5;
                    
                    pipeline.grainEnabled = true;
                    pipeline.grain.animated = true;
                    pipeline.grain.intensity = 0.1;
                    
                    pipeline.depthOfFieldEnabled = true;
                    pipeline.depthOfField.focalLength = 100;
                    pipeline.depthOfField.fStop = 1.4;
                    pipeline.depthOfField.focusDistance = 50;
                }
            }
            
            setupUI() {
                this.updateUI();
            }
            
            updateUI() {
                document.getElementById('score').textContent = `Ø§Ù…ØªÛŒØ§Ø²: ${this.score}`;
                document.getElementById('health').textContent = `Ø³Ù„Ø§Ù…ØªÛŒ: ${this.health}%`;
                document.getElementById('gameStatus').textContent = `ÙˆØ¶Ø¹ÛŒØª: ${this.gameActive ? 'ÙØ¹Ø§Ù„' : 'Ù¾Ø§ÛŒØ§Ù†'}`;
            }
            
            setupControls() {
                this.keys = {};
                this.gamepads = [];
                
                // Ú©Ù†ØªØ±Ù„ Ú©ÛŒØ¨ÙˆØ±Ø¯
                this.scene.onKeyboardObservable.add((kbInfo) => {
                    this.keys[kbInfo.event.key.toLowerCase()] = 
                        kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;
                });
                
                // Ú©Ù†ØªØ±Ù„ Ú¯ÛŒÙ…â€ŒÙ¾Ø¯
                window.addEventListener("gamepadconnected", (e) => {
                    console.log("Ú¯ÛŒÙ…â€ŒÙ¾Ø¯ Ù…ØªØµÙ„ Ø´Ø¯:", e.gamepad.id);
                    this.gamepads[e.gamepad.index] = e.gamepad;
                });
                
                window.addEventListener("gamepaddisconnected", (e) => {
                    console.log("Ú¯ÛŒÙ…â€ŒÙ¾Ø¯ Ù‚Ø·Ø¹ Ø´Ø¯:", e.gamepad.id);
                    delete this.gamepads[e.gamepad.index];
                });
            }
            
            updateGamepads() {
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                
                for (let i = 0; i < gamepads.length; i++) {
                    const gamepad = gamepads[i];
                    if (!gamepad) continue;
                    
                    // Ú©Ù†ØªØ±Ù„ Ø­Ø±Ú©Øª Ø¨Ø§ Ø§Ø³ØªÛŒÚ© Ú†Ù¾
                    const leftStickX = gamepad.axes[0];
                    const leftStickY = gamepad.axes[1];
                    
                    if (Math.abs(leftStickX) > 0.1) this.keys[leftStickX > 0 ? 'd' : 'a'] = true;
                    if (Math.abs(leftStickY) > 0.1) this.keys[leftStickY > 0 ? 's' : 'w'] = true;
                    
                    // Ø¯Ú©Ù…Ù‡ A Ø¨Ø±Ø§ÛŒ Ø´Ù„ÛŒÚ©
                    if (gamepad.buttons[0].pressed) this.keys[' '] = true;
                    
                    // Ø¯Ú©Ù…Ù‡ B Ø¨Ø±Ø§ÛŒ Ø³Ø±Ø¹Øª
                    if (gamepad.buttons[1].pressed) this.keys['shift'] = true;
                }
            }
            
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime < this.shotDelay) return;
                
                this.lastShotTime = currentTime;
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ù„ÙˆÙ„Ù‡
                const bullet = BABYLON.MeshBuilder.CreateSphere("bullet", {
                    diameter: 0.3,
                    segments: 8
                }, this.scene);
                
                bullet.position = this.playerShip.position.clone();
                bullet.position.z -= 2;
                
                const bulletMat = new BABYLON.StandardMaterial("bulletMat", this.scene);
                bulletMat.emissiveColor = new BABYLON.Color3(0, 0.8, 1);
                bulletMat.diffuseColor = new BABYLON.Color3(0, 0.5, 1);
                bullet.material = bulletMat;
                
                // Ù†ÙˆØ± Ú¯Ù„ÙˆÙ„Ù‡
                const bulletLight = new BABYLON.PointLight("bulletLight", bullet.position, this.scene);
                bulletLight.diffuse = new BABYLON.Color3(0, 0.8, 1);
                bulletLight.intensity = 2;
                bulletLight.parent = bullet;
                
                this.bullets.push({
                    mesh: bullet,
                    light: bulletLight,
                    velocity: new BABYLON.Vector3(0, 0, -0.8),
                    lifeTime: 2000 // 2 Ø«Ø§Ù†ÛŒÙ‡
                });
                
                // Ø§ÙÚ©Øª ØµÙˆØªÛŒ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)
                this.createMuzzleFlash();
            }
            
            enemyShoot(enemy) {
                const currentTime = Date.now();
                if (currentTime - enemy.lastShotTime < enemy.shotDelay) return;
                
                enemy.lastShotTime = currentTime;
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ù„ÙˆÙ„Ù‡ Ø¯Ø´Ù…Ù†
                const bullet = BABYLON.MeshBuilder.CreateSphere("enemyBullet", {
                    diameter: 0.3,
                    segments: 8
                }, this.scene);
                
                bullet.position = enemy.mesh.position.clone();
                
                const bulletMat = new BABYLON.StandardMaterial("enemyBulletMat", this.scene);
                bulletMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0.2);
                bulletMat.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
                bullet.material = bulletMat;
                
                // Ù†ÙˆØ± Ú¯Ù„ÙˆÙ„Ù‡ Ø¯Ø´Ù…Ù†
                const bulletLight = new BABYLON.PointLight("enemyBulletLight", bullet.position, this.scene);
                bulletLight.diffuse = new BABYLON.Color3(1, 0.2, 0.2);
                bulletLight.intensity = 2;
                bulletLight.parent = bullet;
                
                // Ø¬Ù‡Øª Ø´Ù„ÛŒÚ© Ø¨Ù‡ Ø³Ù…Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
                const direction = this.playerShip.position.subtract(enemy.mesh.position);
                direction.normalize();
                direction.scaleInPlace(0.5);
                
                this.enemyBullets.push({
                    mesh: bullet,
                    light: bulletLight,
                    velocity: direction,
                    lifeTime: 3000 // 3 Ø«Ø§Ù†ÛŒÙ‡
                });
            }
            
            createMuzzleFlash() {
                // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙÚ©Øª Ø´Ø¹Ù„Ù‡ Ø´Ù„ÛŒÚ©
                const muzzleFlash = new BABYLON.PointLight("muzzleFlash", this.playerShip.position, this.scene);
                muzzleFlash.diffuse = new BABYLON.Color3(1, 0.8, 0.2);
                muzzleFlash.intensity = 5;
                muzzleFlash.position = this.playerShip.position.clone();
                muzzleFlash.position.z -= 2;
                
                // Ù…Ø­Ùˆ Ú©Ø±Ø¯Ù† Ù†ÙˆØ±
                setTimeout(() => {
                    muzzleFlash.dispose();
                }, 100);
            }
            
            createExplosion(position, color = new BABYLON.Color3(1, 0.5, 0)) {
                // Ø³ÛŒØ³ØªÙ… Ø°Ø±Ø§Øª Ø§Ù†ÙØ¬Ø§Ø±
                const explosionParticles = new BABYLON.ParticleSystem("explosion", 200, this.scene);
                explosionParticles.particleTexture = new BABYLON.Texture("https://www.babylonjs.com/assets/Flare.png", this.scene);
                
                explosionParticles.emitter = position;
                explosionParticles.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                explosionParticles.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                
                explosionParticles.color1 = new BABYLON.Color4(color.r, color.g, color.b, 1);
                explosionParticles.color2 = new BABYLON.Color4(1, 1, 0.3, 1);
                explosionParticles.colorDead = new BABYLON.Color4(0.2, 0, 0, 0);
                
                explosionParticles.minSize = 0.1;
                explosionParticles.maxSize = 0.5;
                explosionParticles.minLifeTime = 0.3;
                explosionParticles.maxLifeTime = 1.0;
                explosionParticles.emitRate = 500;
                explosionParticles.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
                explosionParticles.gravity = new BABYLON.Vector3(0, 0, 0);
                
                explosionParticles.start();
                
                // ØªÙˆÙ‚Ù Ø³ÛŒØ³ØªÙ… Ø°Ø±Ø§Øª Ø¨Ø¹Ø¯ Ø§Ø² Ù…Ø¯Øª Ú©ÙˆØªØ§Ù‡
                setTimeout(() => {
                    explosionParticles.stop();
                    setTimeout(() => {
                        explosionParticles.dispose();
                    }, 1000);
                }, 200);
            }
            
            checkCollisions() {
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ Ø¯Ø´Ù…Ù†Ø§Ù†
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        
                        if (BABYLON.Vector3.Distance(bullet.mesh.position, enemy.mesh.position) < 1.5) {
                            // Ø¨Ø±Ø®ÙˆØ±Ø¯ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯
                            enemy.health -= 20;
                            
                            // Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù†ÙØ¬Ø§Ø±
                            this.createExplosion(bullet.mesh.position, new BABYLON.Color3(1, 0.2, 0.2));
                            
                            // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡
                            bullet.mesh.dispose();
                            bullet.light.dispose();
                            this.bullets.splice(i, 1);
                            
                            // Ø¨Ø±Ø±Ø³ÛŒ Ù†Ø§Ø¨ÙˆØ¯ÛŒ Ø¯Ø´Ù…Ù†
                            if (enemy.health <= 0) {
                                // Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù†ÙØ¬Ø§Ø± Ø¨Ø²Ø±Ú¯
                                this.createExplosion(enemy.mesh.position, new BABYLON.Color3(1, 0, 0));
                                
                                // Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù…ØªÛŒØ§Ø²
                                this.score += enemy.type === "fighter" ? 100 : 50;
                                this.updateUI();
                                
                                // Ø­Ø°Ù Ø¯Ø´Ù…Ù†
                                enemy.mesh.dispose();
                                enemy.light.dispose();
                                this.enemies.splice(j, 1);
                                
                                // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø´Ù…Ù† Ø¬Ø¯ÛŒØ¯
                                this.spawnEnemy(this.enemies.length);
                            }
                            
                            break;
                        }
                    }
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú¯Ù„ÙˆÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø´Ù…Ù† Ø¨Ø§ Ø¨Ø§Ø²ÛŒÚ©Ù†
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemyBullets[i];
                    
                    if (BABYLON.Vector3.Distance(bullet.mesh.position, this.playerShip.position) < 2) {
                        // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¨Ø§Ø²ÛŒÚ©Ù†
                        this.health -= 10;
                        this.updateUI();
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù†ÙØ¬Ø§Ø±
                        this.createExplosion(bullet.mesh.position, new BABYLON.Color3(1, 0.8, 0));
                        
                        // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡
                        bullet.mesh.dispose();
                        bullet.light.dispose();
                        this.enemyBullets.splice(i, 1);
                        
                        // Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ
                        if (this.health <= 0) {
                            this.gameActive = false;
                            this.updateUI();
                            this.createExplosion(this.playerShip.position, new BABYLON.Color3(1, 0, 0));
                        }
                    }
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø³ÛŒØ§Ø±Ú©â€ŒÙ‡Ø§
                for (let i = 0; i < this.asteroids.length; i++) {
                    const asteroid = this.asteroids[i];
                    
                    if (BABYLON.Vector3.Distance(this.playerShip.position, asteroid.mesh.position) < asteroid.size + 1.5) {
                        // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø³ÛŒØ§Ø±Ú©
                        this.health -= 5;
                        this.updateUI();
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù†ÙØ¬Ø§Ø±
                        this.createExplosion(asteroid.mesh.position, new BABYLON.Color3(0.5, 0.5, 0.5));
                        
                        // Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ Ø³ÛŒØ§Ø±Ú©
                        asteroid.mesh.position = new BABYLON.Vector3(
                            (Math.random() - 0.5) * 400,
                            (Math.random() - 0.5) * 300,
                            -50 - Math.random() * 300
                        );
                        
                        // Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ
                        if (this.health <= 0) {
                            this.gameActive = false;
                            this.updateUI();
                            this.createExplosion(this.playerShip.position, new BABYLON.Color3(1, 0, 0));
                        }
                    }
                }
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡â€ŒÙ‡Ø§
                for (let i = this.coins.length - 1; i >= 0; i--) {
                    const coin = this.coins[i];
                    
                    if (BABYLON.Vector3.Distance(this.playerShip.position, coin.mesh.position) < 1.5) {
                        // Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø³Ú©Ù‡
                        this.score += 10;
                        this.updateUI();
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ Ø§ÙÚ©Øª Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ
                        this.createExplosion(coin.mesh.position, new BABYLON.Color3(1, 0.9, 0));
                        
                        // Ø­Ø°Ù Ø³Ú©Ù‡
                        coin.mesh.dispose();
                        coin.light.dispose();
                        this.coins.splice(i, 1);
                        
                        // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ú©Ù‡ Ø¬Ø¯ÛŒØ¯
                        this.createNewCoin();
                    }
                }
            }
            
            createNewCoin() {
                const i = this.coins.length;
                const coin = BABYLON.MeshBuilder.CreateSphere(`coin${i}`, {
                    diameter: 0.5,
                    segments: 16
                }, this.scene);
                
                coin.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 40,
                    -20 - Math.random() * 80
                );
                
                const coinMat = new BABYLON.PBRMetallicRoughnessMaterial(`coinMat${i}`, this.scene);
                coinMat.baseColor = new BABYLON.Color3(1, 0.84, 0);
                coinMat.metallic = 1.0;
                coinMat.roughness = 0.1;
                coinMat.emissiveColor = new BABYLON.Color3(1, 0.9, 0.3);
                coin.material = coinMat;
                
                // Ù†ÙˆØ± Ø³Ú©Ù‡
                const coinLight = new BABYLON.PointLight(`coinLight${i}`, coin.position, this.scene);
                coinLight.diffuse = new BABYLON.Color3(1, 0.9, 0.3);
                coinLight.intensity = 1.5;
                coinLight.parent = coin;
                
                this.coins.push({
                    mesh: coin,
                    light: coinLight,
                    rotationSpeed: 0.02
                });
            }
            
            updateGame(deltaTime) {
                if (!this.gameActive) return;
                
                this.updateGamepads();
                this.updatePlayer(deltaTime);
                this.updateEnemies(deltaTime);
                this.updateAsteroids(deltaTime);
                this.updateBullets(deltaTime);
                this.updateEnemyBullets(deltaTime);
                this.updateCoins(deltaTime);
                this.updateCamera(deltaTime);
                this.updateEngineEffects(deltaTime);
                this.checkCollisions();
            }
            
            updatePlayer(deltaTime) {
                // Ø­Ø±Ú©Øª Ø¨Ø§ WASD
                let moveX = 0, moveY = 0;
                if (this.keys['w'] || this.keys['arrowup']) moveY += 1;
                if (this.keys['s'] || this.keys['arrowdown']) moveY -= 1;
                if (this.keys['a'] || this.keys['arrowleft']) moveX -= 1;
                if (this.keys['d'] || this.keys['arrowright']) moveX += 1;
                
                // ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø³Ø±Ø¹Øª Ø¨Ø§ Shift
                this.boostActive = this.keys['shift'];
                const currentSpeed = this.boostActive ? this.boostSpeed : this.moveSpeed;
                
                // Ø§Ø¹Ø§Øµ Ø­Ø±Ú©Øª Ù†Ø±Ù…
                this.playerVelocity.x = BABYLON.Scalar.Lerp(this.playerVelocity.x, moveX * currentSpeed, 0.2);
                this.playerVelocity.y = BABYLON.Scalar.Lerp(this.playerVelocity.y, moveY * currentSpeed, 0.2);
                
                this.playerShip.position.x += this.playerVelocity.x * 60 * deltaTime;
                this.playerShip.position.y += this.playerVelocity.y * 60 * deltaTime;
                
                // Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø­Ø±Ú©Øª
                const bounds = 12;
                this.playerShip.position.x = Math.max(-bounds, Math.min(bounds, this.playerShip.position.x));
                this.playerShip.position.y = Math.max(-bounds, Math.min(bounds, this.playerShip.position.y));
                
                // Ú†Ø±Ø®Ø´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø­Ø±Ú©Øª
                this.playerShip.rotation.z = -this.playerVelocity.x * 3;
                this.playerShip.rotation.x = this.playerVelocity.y * 2;
                
                // Ø´Ù„ÛŒÚ© Ø¨Ø§ Space
                if (this.keys[' ']) {
                    this.shoot();
                }
                
                // Ø¢Ù¾Ø¯ÛŒØª Ø§ÙÚ©Øª Ù…ÙˆØªÙˆØ± Ø¨Ø±Ø§ÛŒ Ø­Ø§Ù„Øª Ø³Ø±Ø¹Øª
                if (this.engineParticleSystem) {
                    this.engineParticleSystem.emitRate = this.boostActive ? 600 : 300;
                    this.engineParticleSystem.minLifeTime = this.boostActive ? 0.1 : 0.3;
                    this.engineParticleSystem.maxLifeTime = this.boostActive ? 0.4 : 0.8;
                }
            }
            
            updateEnemies(deltaTime) {
                this.enemies.forEach(enemy => {
                    // Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³Ù…Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
                    const direction = this.playerShip.position.subtract(enemy.mesh.position);
                    direction.normalize();
                    direction.scaleInPlace(enemy.speed * 60 * deltaTime);
                    
                    enemy.mesh.position.addInPlace(direction);
                    enemy.mesh.lookAt(this.playerShip.position);
                    
                    // Ú†Ø±Ø®Ø´ Ø¨Ø±Ø§ÛŒ Ø§Ø«Ø± Ø¯Ø±Ø§Ù…Ø§ØªÛŒÚ©
                    enemy.mesh.rotation.y += 0.02;
                    
                    // Ø´Ù„ÛŒÚ© Ø¯Ø´Ù…Ù†
                    this.enemyShoot(enemy);
                });
            }
            
            updateAsteroids(deltaTime) {
                this.asteroids.forEach(asteroid => {
                    asteroid.mesh.rotation.x += asteroid.rotationSpeed.x;
                    asteroid.mesh.rotation.y += asteroid.rotationSpeed.y;
                    asteroid.mesh.rotation.z += asteroid.rotationSpeed.z;
                });
            }
            
            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    // Ø­Ø±Ú©Øª Ú¯Ù„ÙˆÙ„Ù‡
                    bullet.mesh.position.addInPlace(new BABYLON.Vector3(
                        bullet.velocity.x * 60 * deltaTime,
                        bullet.velocity.y * 60 * deltaTime,
                        bullet.velocity.z * 60 * deltaTime
                    ));
                    
                    // Ú©Ø§Ù‡Ø´ Ø¹Ù…Ø± Ú¯Ù„ÙˆÙ„Ù‡
                    bullet.lifeTime -= deltaTime * 1000;
                    
                    // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡ Ù‚Ø¯ÛŒÙ…ÛŒ
                    if (bullet.lifeTime <= 0) {
                        bullet.mesh.dispose();
                        bullet.light.dispose();
                        this.bullets.splice(i, 1);
                    }
                }
            }
            
            updateEnemyBullets(deltaTime) {
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemyBullets[i];
                    
                    // Ø­Ø±Ú©Øª Ú¯Ù„ÙˆÙ„Ù‡ Ø¯Ø´Ù…Ù†
                    bullet.mesh.position.addInPlace(new BABYLON.Vector3(
                        bullet.velocity.x * 60 * deltaTime,
                        bullet.velocity.y * 60 * deltaTime,
                        bullet.velocity.z * 60 * deltaTime
                    ));
                    
                    // Ú©Ø§Ù‡Ø´ Ø¹Ù…Ø± Ú¯Ù„ÙˆÙ„Ù‡
                    bullet.lifeTime -= deltaTime * 1000;
                    
                    // Ø­Ø°Ù Ú¯Ù„ÙˆÙ„Ù‡ Ù‚Ø¯ÛŒÙ…ÛŒ
                    if (bullet.lifeTime <= 0) {
                        bullet.mesh.dispose();
                        bullet.light.dispose();
                        this.enemyBullets.splice(i, 1);
                    }
                }
            }
            
            updateCoins(deltaTime) {
                this.coins.forEach(coin => {
                    // Ú†Ø±Ø®Ø´ Ø³Ú©Ù‡
                    coin.mesh.rotation.y += coin.rotationSpeed;
                });
            }
            
            updateCamera(deltaTime) {
                // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¯Ù†Ø¨Ø§Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡ Ø¨Ø§ ØªØ§Ø®ÛŒØ± Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ
                const targetPosition = this.playerShip.position.clone();
                targetPosition.z += 20;
                targetPosition.y += 5;
                
                this.camera.position = BABYLON.Vector3.Lerp(
                    this.camera.position,
                    targetPosition,
                    0.05
                );
                
                const targetLookAt = this.playerShip.position.clone();
                targetLookAt.z += 5;
                
                this.camera.setTarget(targetLookAt);
            }
            
            updateEngineEffects(deltaTime) {
                // Ø¢Ù¾Ø¯ÛŒØª Ù†ÙˆØ± Ù…ÙˆØªÙˆØ±Ù‡Ø§
                if (this.leftEngineLight && this.rightEngineLight) {
                    this.leftEngineLight.position = this.playerShip.position.clone();
                    this.leftEngineLight.position.x -= 0.8;
                    this.leftEngineLight.position.z -= 2.2;
                    
                    this.rightEngineLight.position = this.playerShip.position.clone();
                    this.rightEngineLight.position.x += 0.8;
                    this.rightEngineLight.position.z -= 2.2;
                    
                    // ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ Ù…ÙˆØªÙˆØ± Ø¯Ø± Ø­Ø§Ù„Øª Ø³Ø±Ø¹Øª
                    if (this.boostActive) {
                        this.leftEngineLight.diffuse = new BABYLON.Color3(1, 0.7, 0.1);
                        this.rightEngineLight.diffuse = new BABYLON.Color3(1, 0.7, 0.1);
                        this.leftEngineLight.intensity = 4;
                        this.rightEngineLight.intensity = 4;
                    } else {
                        this.leftEngineLight.diffuse = new BABYLON.Color3(1, 0.4, 0.1);
                        this.rightEngineLight.diffuse = new BABYLON.Color3(1, 0.4, 0.1);
                        this.leftEngineLight.intensity = 2;
                        this.rightEngineLight.intensity = 2;
                    }
                }
                
                // Ø¢Ù¾Ø¯ÛŒØª Ù†ÙˆØ± Ø§ØµÙ„ÛŒ Ù…ÙˆØªÙˆØ±
                if (this.engineLight) {
                    this.engineLight.position = this.playerShip.position.clone();
                    this.engineLight.position.z -= 2;
                }
            }
            
            startGameLoop() {
                this.setupControls();
                
                // Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† ØµÙØ­Ù‡ Ù„ÙˆØ¯ÛŒÙ†Ú¯
                document.getElementById('loading').style.display = 'none';
                
                this.engine.runRenderLoop(() => {
                    const deltaTime = this.engine.getDeltaTime() / 1000;
                    this.updateGame(deltaTime);
                    this.scene.render();
                });
                
                window.addEventListener("resize", () => {
                    this.engine.resize();
                });
            }
        }
        
        // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø§Ø²ÛŒ
        window.addEventListener('load', () => {
            new CinematicSpaceGame();
            console.log('ğŸ¬ Ø¨Ø§Ø²ÛŒ Ø³ÛŒÙ†Ù…Ø§ÛŒÛŒ Ú©Ù‡Ú©Ø´Ø§Ù†ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!');
        });
    </script>
</body>
  </html>
